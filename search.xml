<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2019/02/25/About_me/</url>
    <content><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h5 id="山东枣庄人，目前在沈阳读研，深度学习，机器人抓取方向。在此记录研究生期间的学习历程。"><a href="#山东枣庄人，目前在沈阳读研，深度学习，机器人抓取方向。在此记录研究生期间的学习历程。" class="headerlink" title="山东枣庄人，目前在沈阳读研，深度学习，机器人抓取方向。在此记录研究生期间的学习历程。"></a>山东枣庄人，目前在沈阳读研，深度学习，机器人抓取方向。在此记录研究生期间的学习历程。</h5><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528155305.jpg" alt="image" style="zoom:67%;" />

<h6 id="数学不太好但是喜欢数学，喜欢读科普读物，敬佩向往古往今来的伟大的数学家、物理学家、计算机科学家。"><a href="#数学不太好但是喜欢数学，喜欢读科普读物，敬佩向往古往今来的伟大的数学家、物理学家、计算机科学家。" class="headerlink" title="数学不太好但是喜欢数学，喜欢读科普读物，敬佩向往古往今来的伟大的数学家、物理学家、计算机科学家。"></a>数学不太好但是喜欢数学，喜欢读科普读物，敬佩向往古往今来的伟大的数学家、物理学家、计算机科学家。</h6><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528155313.jpg" alt="_109347319_gettyimages-611195980" style="zoom:67%;" />

<h6 id="喜欢摇滚乐，Pink-Floyd、Guns-N’-Roses。喜欢老歌，张国荣、张学友、陈慧娴。喜欢坂井泉水，永远的女神！"><a href="#喜欢摇滚乐，Pink-Floyd、Guns-N’-Roses。喜欢老歌，张国荣、张学友、陈慧娴。喜欢坂井泉水，永远的女神！" class="headerlink" title="喜欢摇滚乐，Pink Floyd、Guns N’ Roses。喜欢老歌，张国荣、张学友、陈慧娴。喜欢坂井泉水，永远的女神！"></a>喜欢摇滚乐，Pink Floyd、Guns N’ Roses。喜欢老歌，张国荣、张学友、陈慧娴。喜欢坂井泉水，永远的女神！</h6><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528155327.jpg" alt="3"> </p>
<h6 id="热爱生活，喜欢玩魔方，擅长三单，目标中国前百。"><a href="#热爱生活，喜欢玩魔方，擅长三单，目标中国前百。" class="headerlink" title="热爱生活，喜欢玩魔方，擅长三单，目标中国前百。"></a>热爱生活，喜欢玩魔方，擅长三单，目标中国前百。</h6><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528163127.png" alt="4"></p>
<h6 id="母胎solo。。。"><a href="#母胎solo。。。" class="headerlink" title="母胎solo。。。"></a>母胎solo。。。</h6><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528153509.jpeg" alt="921d429f162248289b3d5b8f02ccc493" style="zoom:67%;" />

<h6 id="成为一名真正的文艺程序员。"><a href="#成为一名真正的文艺程序员。" class="headerlink" title="成为一名真正的文艺程序员。"></a>成为一名真正的文艺程序员。</h6><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210528155609.png" alt="codelove" style="zoom:67%;" />

]]></content>
  </entry>
  <entry>
    <title>C基础 - main函数参数、动态内存管理</title>
    <url>/2021/05/22/CNote2/</url>
    <content><![CDATA[<h1 id="C基础-2"><a href="#C基础-2" class="headerlink" title="C基础 2"></a>C基础 2</h1><h2 id="1-main函数的参数"><a href="#1-main函数的参数" class="headerlink" title="1 - main函数的参数"></a>1 - main函数的参数</h2><p>main函数有三个参数: argc、argv 和 envp<br><code>int main(int argc,char *argv[],char *envp[])</code></p>
<ul>
<li>int argc，存放了命令行参数的个数。</li>
<li>char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</li>
<li>char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</li>
<li>argc的值是参数个数加1，因为程序名称是程序的第一个参数，即argv[0]</li>
<li>main函数的参数，不管是书写的整数还是浮点数，全部被认为是字符串。</li>
</ul>
<h2 id="2-动态内存管理"><a href="#2-动态内存管理" class="headerlink" title="2 - 动态内存管理"></a>2 - 动态内存管理</h2><h3 id="相关的库函数"><a href="#相关的库函数" class="headerlink" title="相关的库函数"></a>相关的库函数</h3><ul>
<li>malloc函数<br>malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。<br><code>void *malloc(unsigned int size)</code><br>malloc的返回值的地址的基类型为 void，即不指向任何类型的数据，只提供一个地址，程序中需要定义一个指针来指向动态分配的内存地址。<br><code>int *pi=malloc(sizeof(int));</code></li>
<li>free函数<br>free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。<br><code>void free(void *p);</code></li>
</ul>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针就是无效的指针，与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。</p>
<ul>
<li>1、内存指针变量未初始化</li>
</ul>
<p>指针变量刚被创建时不一定会自动初始化成为空指针（与编译器有关），它的缺省值是可能随机的，它会随便乱指。所以，指针变量在创建的同时应当被初始化，要么将指针的值设置为0，要么让它指向合法的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *pi=&amp;i;</span><br></pre></td></tr></table></figure>



<ul>
<li>2、内存释放后指针没用置空</li>
</ul>
<p>调用free函数把指针所指的内存给释放掉，但指针不一定会赋值 0（也与编译器有关），如果对释放后的指针进行操作，相当于非法操作内存。释放内存后应立即将指针置为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言学习笔记</tag>
        <tag>C语言基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础 - 概念、随机数、字符与编码、字符串、编码、结构体 等</title>
    <url>/2021/05/22/CNote1/</url>
    <content><![CDATA[<h1 id="C基础-1"><a href="#C基础-1" class="headerlink" title="C基础 1"></a>C基础 1</h1><h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1 - 函数"></a>1 - 函数</h2><ul>
<li><ol>
<li>在变量前加const约束，主要用于定义函数的参数，表示该参数在函数中是只读取，不允许改变，如果函数中试图改变它的值，编译的时候就会报错。</li>
</ol>
</li>
<li><ol start="2">
<li>局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量</li>
</ol>
</li>
</ul>
<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 - 指针"></a>2 - 指针</h2><ul>
<li><ol>
<li>在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。</li>
</ol>
</li>
<li><ol start="2">
<li>空指针就是说指针没有指向任何内存变量，指针的值是空，所以不能操作内存，否则可能会引起程序的崩溃。</li>
</ol>
</li>
<li><ol start="3">
<li>在C语言中，数组占用的内存空间是连续的，数组名是数组元素的首地址，也是数组的地址。数组名、对数组取地址和数组元素的首地址<code>(arr,&amp;arr,&amp;arr[0])</code>是同一回事。在应用开发中，程序员一般用数组名，书写最简单。</li>
</ol>
</li>
<li><ol start="4">
<li>指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）</li>
</ol>
</li>
</ul>
<h2 id="3-整数"><a href="#3-整数" class="headerlink" title="3 - 整数"></a>3 - 整数</h2><ul>
<li>二进制0b(0B)开头,八进制0开头,十六进制0x(0X)开头</li>
<li>%hd、%d、%ld 以十进制、有符号的形式输出short、int、long 类型的整数。</li>
<li>%hu、%u、%lu 以十进制、无符号的形式输出short、int、long 类型的整数。</li>
<li>库函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;   <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> j)</span></span>;            <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">labs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;     <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型的别名"><a href="#4-数据类型的别名" class="headerlink" title="4 - 数据类型的别名"></a>4 - 数据类型的别名</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">size_t</span> ii; <span class="comment">// 等同于 unsigned int ii;</span></span><br></pre></td></tr></table></figure></li>
<li>strlen的返回值是size_t类型。</li>
<li>man strlen 查看strlen的文档</li>
</ul>
<h2 id="5-随机数"><a href="#5-随机数" class="headerlink" title="5 - 随机数"></a>5 - 随机数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>; <span class="comment">// 随机数生成器的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span></span>;  <span class="comment">// 获取一个随机数</span></span><br><span class="line"></span><br><span class="line">srand(time(<span class="number">0</span>));  <span class="comment">// 播下随机种子,每次运行都不同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,rand());</span><br></pre></td></tr></table></figure>
<ul>
<li>rand函数初始化随机数发生器（俗称种子），在实际开发中，可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同，通常我们采用<code>&lt;time.h&gt;</code> 头文件中的 time 函数即可得到一个精确到秒的时间作为种子。</li>
<li>生成一定范围的随机数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">50</span>;   <span class="comment">// 产生0~49的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">100</span>;   <span class="comment">// 产生100~150的随机数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="6-字符与ASCII码"><a href="#6-字符与ASCII码" class="headerlink" title="6 - 字符与ASCII码"></a>6 - 字符与ASCII码</h2><ul>
<li>32是空格。</li>
<li>48～57为0到9十个阿拉伯数字；</li>
<li>65～90为26个大写英文字母；</li>
<li>97～122号为26个小写英文字母；</li>
<li><strong>在char的取值范围内（0-255），字符和整数没有本质区别</strong>,char 变量在内存中存储的是字符对应的 ASCII 码值。如果以 %c 输出，会根据 ASCII 码表转换成对应的字符，如果以 %d 输出，那么还是整数。int 变量在内存中存储的是整数本身，如果以 %c 输出时，也会根据 ASCII 码表转换成对应的字符<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalpha</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（'A'-'Z','a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalnum</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（'A'-'Z','a'-'z'）或数字（'0'-'9'），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isdigit</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是数字（'0'-'9'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（'a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（'A'-'Z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（'A'-'Z'）返回相应的小写字母（'a'-'z'）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（'a'-'z'）返回相应的大写字母（'A'-'Z'）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ispunct</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是标点字符（0x00-0x1F）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isspace</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">// 若ch是空格（' '），水平制表符（'/t'）,回车符（'/r'），走纸换行（'/f'），垂直制表符（'/v'），换行符（'/n'），返回非0值，否则返回0。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="7-浮点数"><a href="#7-浮点数" class="headerlink" title="7 - 浮点数"></a>7 - 浮点数</h2><ul>
<li><p>浮点数的精度:</p>
<ul>
<li>float只能表达6-7位的有效数字，不能用“==”判断两个数字是否相等。</li>
<li>double能表达15-16位有效的数字，可以用“==”判断两个数字是否相等。</li>
<li>long double占用的内存是double的两倍，但表达数据的精度和double相同。</li>
<li>实际开发中，建议弃用float，只采用double就可以</li>
</ul>
</li>
<li><p>浮点数的输出:</p>
<ul>
<li>float采用%f占位符。</li>
<li>double采用%lf占位符.</li>
<li>long double采用%Lf占位符，注意，L是大写。</li>
</ul>
</li>
<li><p>float只能表达6-7位的有效数字，不能用“==”判断两个数字是否相等。</p>
</li>
<li><p>double能表达15-16位有效的数字，可以用“==”判断两个数字是否相等。</p>
</li>
<li><p>long double占用的内存是double的两倍，但表达数据的精度和double相同。</p>
<p><strong>在实际开发中，建议弃用float，只采用double就可以，long double暂时没有必要，但不知道以后的操作系统和编译器对long double是否有改进</strong></p>
</li>
<li><p>常用库函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;       <span class="comment">// 把字符串nptr转换为double</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;                <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;      <span class="comment">// 求 x 的 y 次幂（次方）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;                <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;      <span class="comment">// 求x/y整除后的双精度余数</span></span><br><span class="line"><span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> val,<span class="keyword">double</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>科学计数法</p>
<ul>
<li>科学计数法采用%e或%E输出，完整的输出格式是%m.ne或%m.nE，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出</li>
</ul>
</li>
<li><p>浮点数有一些坑，例如两个浮点数不相等和精度的问题，在实际开发中，我们经常用整数代替浮点数，因为整数是精确的，效率也更高。例如人的身高一米七五，以米为单位，用浮点数表示是1.75米，如果以厘米为单位，用整数表示是175。</p>
</li>
</ul>
<h2 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8 - 字符串"></a>8 - 字符串</h2><ul>
<li><p>因为字符串需要用\0结尾，所以在定义字符串的时候，字符数组的长度要预留多一个字节用来存放\0, \0就是数字0。这是约定。</p>
</li>
<li><p>一个中文字符占两个字节（GBK编码）。char strname[21]用于存放中文的时候，只能存10个汉字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> strname[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个英文字符或十个中文的字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> strname[<span class="number">21</span>]; <span class="comment">// 一个字符占一个字节</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="keyword">sizeof</span>(strname));  <span class="comment">// 把全部的元素置为0</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串越界问题 c80_str.c</p>
</li>
<li><p>字符串常用的库函数</p>
</li>
</ul>
<ol>
<li>strlen <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span>  <span class="title">strlen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>*  str)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值：返回字符串的字符数</span></span><br><span class="line"><span class="comment">strlen 函数计算的是字符串的实际长度，遇到第一个0结束。</span></span><br><span class="line"><span class="comment">函数返回值一定是size_t，是无符号的整数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>strcpy<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功 能: 将参数src字符串拷贝至参数dest所指的地址。</span></span><br><span class="line"><span class="comment">返回值: 返回参数dest的字符串起始地址。</span></span><br><span class="line"><span class="comment">复制完字符串后，在dest后追加0。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>strncpy<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：把src前n字符的内容复制到dest中</span></span><br><span class="line"><span class="comment">如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。*/</span></span><br></pre></td></tr></table></figure></li>
<li>strcat<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：将src字符串拼接到dest所指的字符串尾部。</span></span><br><span class="line"><span class="comment">返回值：返回dest字符串起始地址。</span></span><br><span class="line"><span class="comment">dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。</span></span><br><span class="line"><span class="comment">dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>strncat<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span> <span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。</span></span><br></pre></td></tr></table></figure></li>
<li>strchr<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 返回一个指向在字符串s中第一个出现c的位置，如果找不到，返回0。</span></span><br></pre></td></tr></table></figure></li>
<li>strnchr<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 返回一个指向在字符串s中最后一个出现c的位置，如果找不到，返回0.</span></span><br></pre></td></tr></table></figure></li>
<li>strstr<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">const</span> <span class="keyword">char</span>* substr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>位置（地址）偏移的用法<br>字符串的地址偏移其本质是指针的运算，常用于灵活的处理字符串。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="keyword">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">"abcdefghijk"</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line"><span class="keyword">char</span> strname1[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname1,<span class="number">0</span>,<span class="keyword">sizeof</span>(strname1));</span><br><span class="line"><span class="built_in">strcpy</span>(strname1,strname+<span class="number">1</span>);       <span class="comment">// 把bcdefghijk的值赋给strname1</span></span><br><span class="line"><span class="built_in">strncpy</span>(strname1,strname+<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 把cde的值赋给strname1</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="9-数据类型转换"><a href="#9-数据类型转换" class="headerlink" title="9 - 数据类型转换"></a>9 - 数据类型转换</h2><ul>
<li><p>计算机进行算术运算时，要求各操作数的类型具有相同的大小（存储位数）及存储方式，不能将 char 型（ 1 字节）数据与 int 型（ 2、4或8字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 double 型数据直接参与运算。</p>
</li>
<li><p>一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换。一般情况下，数据的取值范围越大、精度越高，其类型也越“高级”。</p>
</li>
</ul>
<h2 id="10-结构体"><a href="#10-结构体" class="headerlink" title="10 - 结构体"></a>10 - 结构体</h2><h3 id="10-1-占用内存的情况"><a href="#10-1-占用内存的情况" class="headerlink" title="10.1 占用内存的情况"></a>10.1 占用内存的情况</h3><ul>
<li>理论上讲结构体的各个成员在内存中是连续存放的，和数组非常类似，但是，结构体的占用内存的总大小不一定等于全部成员变量占用内存大小之和。在编译器的具体实现中，为了提高内存寻址的效率，各个成员之间可能会存在缝隙。</li>
<li>C语言提供了结构体成员内存对齐的方法，在定义结构体之前，增加以下代码可以使结构体成员变量之间的内存没有空隙。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-结构体的复制"><a href="#10-2-结构体的复制" class="headerlink" title="10.2 结构体的复制"></a>10.2 结构体的复制</h3><ul>
<li>使用内存拷贝，C语言提供了memcpy（memory copy的简写）实现内存拷贝功能。<ul>
<li><strong>src</strong> 源内存变量的起始地址。</li>
<li><strong>dest</strong> 目的内存变量的起始地址。</li>
<li><strong>n</strong> 需要复制内容的字节数。</li>
<li>函数返回指向dest的地址，函数的返回值意义不大，程序员一般不关心这个返回值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>strcpy 和 memcpy 比较：</p>
<p>1）复制的内容不同，strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p>
<p>2）用途不同，通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p>
<p>3）复制的方法不同，strcpy不需要指定长度，它遇到被复制字符的串结尾符0才结束，memcpy则是根据其第3个参数决定复制的长度。</p>
</li>
</ul>
<h3 id="10-3-结构体作为函数的参数"><a href="#10-3-结构体作为函数的参数" class="headerlink" title="10.3 结构体作为函数的参数"></a>10.3 结构体作为函数的参数</h3><ul>
<li>结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。</li>
</ul>
<h3 id="10-4-memset和bzero函数"><a href="#10-4-memset和bzero函数" class="headerlink" title="10.4 memset和bzero函数"></a>10.4 memset和bzero函数</h3><p><strong>memset函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> v, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>memset 函数是内存空间赋值函数，用来给某一块内存空间进行赋值的。包含在&lt;string.h&gt;头文件中。<ul>
<li>s为内存空间的地址，一般是数组名或结构体的地址。</li>
<li>v为要填充的值，填0就是初始化。</li>
<li>n为要填充的字节数。</li>
</ul>
</li>
</ul>
<p><strong>bzero函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>bzero函数是内存空间清零。包含在&lt;string.h&gt;头文件中。<ul>
<li>s为内存空间的地址，一般是数组名或结构体的地址。</li>
<li>n为要清零的字节数。</li>
<li>如果要对数组或结构体清零，用memset和bzero都可以，没什么差别，看程序员的习惯。</li>
</ul>
</li>
</ul>
<h2 id="11-格式化输出"><a href="#11-格式化输出" class="headerlink" title="11 - 格式化输出"></a>11 - 格式化输出</h2><h3 id="11-1-格式说明符的形式如下（方括号-中的项为可选项）："><a href="#11-1-格式说明符的形式如下（方括号-中的项为可选项）：" class="headerlink" title="11.1 格式说明符的形式如下（方括号 [] 中的项为可选项）："></a>11.1 格式说明符的形式如下（方括号 [] 中的项为可选项）：</h3><p><strong><code>%[flags][width][.prec]type</code></strong></p>
<h4 id="对齐标志-flags："><a href="#对齐标志-flags：" class="headerlink" title="对齐标志 flags："></a>对齐标志 flags：</h4><ul>
<li>flag: 不填或+是右对齐,  - 是左对齐</li>
</ul>
<h4 id="宽度-width："><a href="#宽度-width：" class="headerlink" title="宽度 width："></a>宽度 width：</h4><ul>
<li>如果本身输出的长度大于指定宽度，则宽度限制无效，输出本身</li>
<li>数字会在前面补充0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%12s=\n"</span>,<span class="string">"abc"</span>);     <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=%12d=\n"</span>,<span class="number">123</span>);       <span class="comment">// 输出=         123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=%12lf=\n"</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=  123.500000=</span></span><br></pre></td></tr></table></figure>

<h4 id="精度-prec"><a href="#精度-prec" class="headerlink" title="精度 .prec"></a>精度 .prec</h4><p>如果输出的内容是浮点数，用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%12.2lf=\n"</span>,<span class="number">123.5</span>);   <span class="comment">// 输出=      123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=%.2lf=\n"</span>,<span class="number">123.5</span>);     <span class="comment">// 输出=123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=%12.2e=\n"</span>,<span class="number">123500000000.0</span>);  <span class="comment">// 输出=    1.24e+11=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=%.2e=\n"</span>,<span class="number">123500000000.0</span>);    <span class="comment">// 输出=1.24e+11=</span></span><br></pre></td></tr></table></figure>

<h4 id="类型符-type："><a href="#类型符-type：" class="headerlink" title="类型符 type："></a>类型符 type：</h4><ul>
<li>%hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。</li>
<li>%hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数</li>
<li>%c 输出字符。</li>
<li>%lf 以普通方式输出double（float弃用，long doube无用）。</li>
<li>%e 以科学计数法输出double。</li>
<li>%s 输出字符串。</li>
<li>%p 输出内存的地址</li>
</ul>
<h3 id="11-2-格式化输出到字符串"><a href="#11-2-格式化输出到字符串" class="headerlink" title="11.2 格式化输出到字符串"></a>11.2 格式化输出到字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能：printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</strong></p>
<p>sprintf 和 snprintf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化输出到str中</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d,%c,%f,%s"</span>,<span class="number">10</span>,<span class="string">'A'</span>,<span class="number">25.97</span>,<span class="string">"一共输入了三个数。"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 格式化输出到str中，只截取前7个字符</span></span><br><span class="line"><span class="built_in">snprintf</span>(str,<span class="number">8</span>,<span class="string">"%d,%c,%f,%s"</span>,<span class="number">10</span>,<span class="string">'A'</span>,<span class="number">25.97</span>,<span class="string">"一共输入了三个数。"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br></pre></td></tr></table></figure>

<p><strong>如果 n = 7，snprintf函数在unix和windows平台下的表现略有不同，在windows平台下，会输出7个字符。unix则输出6个字符</strong></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言学习笔记</tag>
        <tag>C语言基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础 - 文件操作、文件读取、输入输出、目录操作</title>
    <url>/2021/05/22/CNote3/</url>
    <content><![CDATA[<h1 id="C基础-3"><a href="#C基础-3" class="headerlink" title="C基础 3"></a>C基础 3</h1><h2 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1 - 文件操作"></a>1 - 文件操作</h2><h4 id="文件指针："><a href="#文件指针：" class="headerlink" title="文件指针："></a>文件指针：</h4><ul>
<li><p>操作文件的时候，C语言为文件分配一个信息区，该信息区包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息用一个结构体来存放（struct _IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE），FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。</p>
</li>
<li><p>打开文件的时候，fopen函数中会动态分配一个FILE结构体大小的内存空间，并把FILE结构体内存的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。</p>
</li>
<li><p>关闭文件的时候，fclose函数除了关闭文件，还会释放FILE结构体占用的内存空间。</p>
</li>
<li><p>FILE结构体指针习惯称为文件指针。</p>
</li>
</ul>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>含 义</strong></th>
<th><strong>说 明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td>只读</td>
<td>文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td><strong>w</strong></td>
<td>只写</td>
<td>如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。</td>
</tr>
<tr>
<td><strong>a</strong></td>
<td>追加只写</td>
<td>如果文件存在，则打开文件，如果文件不存在，则新建文件。</td>
</tr>
<tr>
<td><strong>r+</strong></td>
<td>读写</td>
<td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。</td>
</tr>
<tr>
<td><strong>w+</strong></td>
<td>读写</td>
<td>在只写w的方式上增加可读的功能。</td>
</tr>
<tr>
<td><strong>a+</strong></td>
<td>读写</td>
<td>在追加只写a的方式上增加可读的功能</td>
</tr>
</tbody></table>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-文本文件的读写"><a href="#2-文本文件的读写" class="headerlink" title="2 - 文本文件的读写"></a>2 - 文本文件的读写</h2><p>在实际开发中，文本文件以行的形式存放字符串，如C程序的源代码，一段文字等，所以一般是按行写入和读取数据。</p>
<h4 id="向文件中写入数据："><a href="#向文件中写入数据：" class="headerlink" title="向文件中写入数据："></a>向文件中写入数据：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="从文件中读取数据："><a href="#从文件中读取数据：" class="headerlink" title="从文件中读取数据："></a>从文件中读取数据：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fgets的功能是从文件中读取一行。</li>
<li>参数buf是一个字符串，用于保存从文件中读到的数据。</li>
<li>参数size是打算读取内容的长度。</li>
<li>参数fp是待读取文件的文件指针。</li>
<li>如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。</li>
<li>调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</li>
</ul>
<h2 id="3-二进制文件的读写"><a href="#3-二进制文件的读写" class="headerlink" title="3 - 二进制文件的读写"></a>3 - 二进制文件的读写</h2><p>把内存中的数据结构直接写入二进制文件，读取的时候，也是从文件中读取数据结构的大小一块数据，直接保存到数据结构中。注意，这里所说的数据结构不只是结构体，是任意数据类型。</p>
<h4 id="向文件中写入数据：-1"><a href="#向文件中写入数据：-1" class="headerlink" title="向文件中写入数据："></a>向文件中写入数据：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。</p>
</li>
<li><p>size：固定填1。</p>
</li>
<li><p>nmemb：表示打算写入数据的字节数。</p>
</li>
<li><p>fp：表示文件指针。</p>
</li>
<li><p>函数的返回值是本次成功写入数据的字节数，一般情况下，程序员不必关心fwrite函数的返回值。</p>
</li>
</ul>
<h4 id="从文件中读取数据：-1"><a href="#从文件中读取数据：-1" class="headerlink" title="从文件中读取数据："></a>从文件中读取数据：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。</li>
<li>size：固定填1。</li>
<li>nmemb：表示打算读取的数据的字节数。</li>
<li>fp：表示文件指针。</li>
<li>调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</li>
</ul>
<h2 id="4-文件定位"><a href="#4-文件定位" class="headerlink" title="4 - 文件定位"></a>4 - 文件定位</h2><ul>
<li><p>在文件内部有一个位置指针，用来指向文件当前读写的位置。在文件打开时，如果打开方式是r和w，位置指针指向文件的第一个字节，如果打开方式是a，位置指针指向文件的尾部。每当从文件里读取n个字节或文件里写入n个字节后，位置指针也会向后移动n个字节。</p>
</li>
<li><p>文件位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，不是变量的地址。文件每读写一次，位置指针就会移动一次，它不需要您在程序中定义和赋值，而是由系统自动设置，对程序员来说是隐藏的。</p>
</li>
<li><p>在实际开发中，偶尔需要移动位置指针，实现对指定位置数据的读写。我们把移动位置指针称为文件定位。</p>
</li>
<li><p>C语言提供了ftell、rewind和fseek三个库函数来实现文件定位功能。</p>
</li>
</ul>
<h4 id="ftell"><a href="#ftell" class="headerlink" title="ftell:"></a>ftell:</h4><p>ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="rewind："><a href="#rewind：" class="headerlink" title="rewind："></a>rewind：</h4><p>rewind函数用来将位置指针移动到文件开头，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="fseek："><a href="#fseek：" class="headerlink" title="fseek："></a>fseek：</h4><p>fseek() 用来将位置指针移动到任意位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1）fp 为文件指针，也就是被移动的文件。</p>
</li>
<li><p>2）offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</p>
</li>
<li><p>3）origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</p>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p>当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。</p>
</li>
<li><p>当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。</p>
</li>
</ul>
<h2 id="5-文件缓冲区"><a href="#5-文件缓冲区" class="headerlink" title="5 - 文件缓冲区"></a>5 - 文件缓冲区</h2><ul>
<li><p>在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。</p>
</li>
<li><p>在实际开发中，如果程序员想把缓冲区的数据立即写入文件，可以调用fflush库函数，它的声明如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的参数只有一个，即文件指针，返回0成功，其它失败，程序员一般不关心它的返回值。</li>
</ul>
<h2 id="6-标准输入、标准输出和标准错误"><a href="#6-标准输入、标准输出和标准错误" class="headerlink" title="6 - 标准输入、标准输出和标准错误"></a>6 - 标准输入、标准输出和标准错误</h2><p>Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world.\n"</span>);</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello world.\n"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="7-目录操作"><a href="#7-目录操作" class="headerlink" title="7 - 目录操作"></a>7 - 目录操作</h2><h3 id="7-1-获取当前工作目录-getcwd"><a href="#7-1-获取当前工作目录-getcwd" class="headerlink" title="7.1 获取当前工作目录 getcwd"></a>7.1 获取当前工作目录 getcwd</h3><ul>
<li>C程序中调用getcwd函数可以获取当前的工作目录。函数声明：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="7-2-切换工作目录-chdir"><a href="#7-2-切换工作目录-chdir" class="headerlink" title="7.2 切换工作目录 chdir"></a>7.2 切换工作目录 chdir</h3><ul>
<li><p>就像在shell中使用cd命令切换目录一样，在C程序中使用chdir函数来改变工作目录。 </p>
</li>
<li><p>返回值：0-切换成功；非0-失败。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-目录的创建和删除"><a href="#7-3-目录的创建和删除" class="headerlink" title="7.3 目录的创建和删除"></a>7.3 目录的创建和删除</h3><ul>
<li>在shell中可以通过mkdir/rmdir命令来创建/删除目录，C程序中用mkdir/rmdir函数来创建/删除目录。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>mode的含义将按open系统调用的O_CREAT选项中的有关定义设置，当然，它还要服从umask的设置况，先固定填0755</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>(<span class="string">"/tmp/aaa"</span>,<span class="number">0755</span>);   <span class="comment">// 创建/tmp/aaa目录</span></span><br></pre></td></tr></table></figure>



<h3 id="7-4-获取目录中的文件列表"><a href="#7-4-获取目录中的文件列表" class="headerlink" title="7.4 获取目录中的文件列表"></a>7.4 获取目录中的文件列表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开目录的函数opendir的声明</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录的函数readdir的声明</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭目录的函数closedir的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">   <span class="keyword">off_t</span> d_off;                   <span class="comment">// offset to this dirent 在目录文件中的偏移</span></span><br><span class="line">   <span class="keyword">unsigned</span> short d_reclen;     <span class="comment">// length of this d_name 文件名长</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;         <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">   <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];    <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>需要关注结构体的d_type和d_name成员，其它的不必关心。</p>
<ul>
<li><p>d_name文件名或目录名。</p>
</li>
<li><p>d_type描述了文件的类型，有多种取值，最重要的是8和4，8-常规文件（A regular file）；4-目录（A directory），其它的暂时不关心。</p>
</li>
</ul>
<h3 id="7-5-access库函数"><a href="#7-5-access库函数" class="headerlink" title="7.5 access库函数"></a>7.5 access库函数</h3><ul>
<li>access函数用于判断当前操作系统用户对文件或目录的存取权限。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。</p>
</li>
<li><p>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK 2    <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：当pathname满足mode的条件时候返回0，不满足返回-1。</li>
</ul>
<h3 id="7-6-stat-库函数"><a href="#7-6-stat-库函数" class="headerlink" title="7.6 stat 库函数"></a>7.6 stat 库函数</h3><ul>
<li>struct stat结构体用于存放文件和目录的状态信息，如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">dev_t</span> st_dev;   <span class="comment">// device 文件的设备编号</span></span><br><span class="line">  <span class="keyword">ino_t</span> st_ino;   <span class="comment">// inode 文件的i-node</span></span><br><span class="line">  <span class="keyword">mode_t</span> st_mode;   <span class="comment">// protection 文件的类型和存取的权限</span></span><br><span class="line">  <span class="keyword">nlink_t</span> st_nlink;   <span class="comment">// number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">  <span class="keyword">uid_t</span> st_uid;   <span class="comment">// user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">  <span class="keyword">gid_t</span> st_gid;   <span class="comment">// group ID of owner 文件所有者的组识别码</span></span><br><span class="line">  <span class="keyword">dev_t</span> st_rdev;  <span class="comment">// device type 若此文件为设备文件, 则为其设备编号</span></span><br><span class="line">  <span class="keyword">off_t</span> st_size;  <span class="comment">// total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;  <span class="comment">// blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;  <span class="comment">// number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">  <span class="keyword">time_t</span> st_atime;  <span class="comment">// time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">  <span class="keyword">time_t</span> st_mtime;  <span class="comment">// time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">  <span class="keyword">time_t</span> st_ctime;  <span class="comment">// time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>st_mode成员的取值很多，或者使用如下两个宏来判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_ISREG(st_mode)  <span class="comment">// 是否为一般文件 </span></span><br><span class="line">S_ISDIR(st_mode)  <span class="comment">// 是否为目录</span></span><br></pre></td></tr></table></figure>

<h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>stat函数获取path指定文件或目录的信息，并将信息保存到结构体buf中，执行成功返回0，失败返回-1。</li>
</ul>
<h3 id="7-7-utime库函数"><a href="#7-7-utime库函数" class="headerlink" title="7.7 utime库函数"></a>7.7 utime库函数</h3><ul>
<li>utime函数用于修改文件的存取时间和更改时间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>utime()用来修改参数filename 文件所属的inode 存取时间。如果参数times为空指针(NULL), 则该文件的存取时间和更改时间全部会设为目前时间。其中的struct utimbuf定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">time_t</span> actime;</span><br><span class="line">  <span class="keyword">time_t</span> modtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：执行成功则返回0，失败返回-1。</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言学习笔记</tag>
        <tag>C语言基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础 - 时间操作、编译预处理、系统错误</title>
    <url>/2021/05/22/CNote4/</url>
    <content><![CDATA[<h1 id="C基础-4"><a href="#C基础-4" class="headerlink" title="C基础 4"></a>C基础 4</h1><h2 id="1-C语言时间操作"><a href="#1-C语言时间操作" class="headerlink" title="1 - C语言时间操作"></a>1 - C语言时间操作</h2><h3 id="time-t别名"><a href="#time-t别名" class="headerlink" title="time_t别名"></a>time_t别名</h3><p>在C语言中，用time_t来表示时间数据类型，它是一个long（长整数）类型的别名，在time.h文件中定义，表示一个日历时间，是从1970年1月1日0时0分0秒到现在的秒数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="两种调用time库函数方法："><a href="#两种调用time库函数方法：" class="headerlink" title="两种调用time库函数方法："></a>两种调用time库函数方法：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> tnow1, tnow2;</span><br><span class="line">tnow1 = time(<span class="number">0</span>);</span><br><span class="line">time(&amp;tnow2);</span><br></pre></td></tr></table></figure>

<h4 id="tm结构体"><a href="#tm结构体" class="headerlink" title="tm结构体"></a>tm结构体</h4><p>time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;     <span class="comment">// 秒：取值区间为[0,59]</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;     <span class="comment">// 分：取值区间为[0,59]</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;    <span class="comment">// 时：取值区间为[0,23]</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;    <span class="comment">// 日期：一个月中的日期：取值区间为[1,31]</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;     <span class="comment">// 月份：（从一月开始，0代表一月），取值区间为[0,11]</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;    <span class="comment">// 年份：其值等于实际年份减去1900</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;    <span class="comment">// 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;    <span class="comment">// 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;   <span class="comment">// 夏令时标识符，该字段意义不大，我们不用夏令时。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="locatime函数"><a href="#locatime函数" class="headerlink" title="locatime函数"></a>locatime函数</h4><p>localtime函数用于把time_t表示的时间转换为struct tm结构体表示的时间，函数返回struct tm结构体的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm * <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><p>mktime函数的功能与localtime函数相反。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-编译预处理"><a href="#2-编译预处理" class="headerlink" title="2 - 编译预处理"></a>2 - 编译预处理</h2><p>C语言由源代码生成可执行程序的过程如下：</p>
<p><strong>C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</strong></p>
<h3 id="条件编译："><a href="#条件编译：" class="headerlink" title="条件编译："></a>条件编译：</h3><h4 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef :"></a>#ifdef :</h4><p>​    如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h4 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h4><p>​    如果未定义标识符，则编译“程序段1”；否则编译“程序段2”</p>
<p>在实际开发中，用#ifndef来防止头文件被重复包含。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef 标识符</span><br><span class="line">  程序段 1</span><br><span class="line">#else</span><br><span class="line">  程序段 2 </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<h4 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h4><p>#undef取消已定义的标识符。</p>
<h2 id="3-系统错误"><a href="#3-系统错误" class="headerlink" title="3 - 系统错误"></a>3 - 系统错误</h2><h3 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errno)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数说明：strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</p>
</li>
<li><p>返回值：返回描述错误原因的字符串地址。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言学习笔记</tag>
        <tag>C语言基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda使用指南</title>
    <url>/2020/11/09/Conda%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="1-换镜像源提高下载速度"><a href="#1-换镜像源提高下载速度" class="headerlink" title="1.换镜像源提高下载速度"></a>1.换镜像源提高下载速度</h2><h3 id="1-1-Conda换镜像源"><a href="#1-1-Conda换镜像源" class="headerlink" title="1.1 Conda换镜像源"></a>1.1 Conda换镜像源</h3><ul>
<li><p>显示镜像源<br><code>conda config --show channels</code></p>
</li>
<li><p>添加镜像源(以清华源为例)<br><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code></p>
</li>
<li><p>设置镜像源<br><code>conda config --set show_channel_urls yes</code></p>
</li>
<li><p>删除镜像源<br><code>conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code></p>
</li>
<li><p>恢复默认源<br><code>conda config --remove-key channels</code></p>
</li>
<li><p>也可以使用oh-my-tuna脚本一键设置清华源 <a href="https://github.com/tuna/oh-my-tuna" target="_blank" rel="noopener">https://github.com/tuna/oh-my-tuna</a></p>
</li>
<li><p>推荐一个装pytorch比较快的源<br><a href="https://mirrors.bfsu.edu.cn/anaconda/cloud/pytorch/" target="_blank" rel="noopener">https://mirrors.bfsu.edu.cn/anaconda/cloud/pytorch/</a></p>
</li>
</ul>
<p><strong>Windows的镜像源文件在C:\Users\用户名.condarc文件中</strong><br><strong>Ubuntu的镜像源文件在/home/用户名/.condarc文件中</strong></p>
<p>国内其他源</p>
<ul>
<li><p>清华镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r</span><br></pre></td></tr></table></figure>
</li>
<li><p>中科大镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;bioconda&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;menpo&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>阿里镜像源<br><code>conda config --add channels https://mirrors.aliyun.com/pypi/simple/</code></p>
</li>
<li><p>豆瓣python源<br><code>conda config --add channels http://pypi.douban.com/simple/</code></p>
</li>
</ul>
<h3 id="1-2-pip换源"><a href="#1-2-pip换源" class="headerlink" title="1.2 pip换源"></a>1.2 pip换源</h3><ul>
<li>指定源安装，以tensorflow为例<br><code>pip install tensorflow -i http://mirrors.aliyun.com/pypi/simple/  --trusted-host mirrors.aliyun.com</code></li>
<li>如果不想每次都输入后面这一大段，可以设置全局换源<ul>
<li>全局切换阿里云源, 注意是https<br><code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></li>
<li>全局切换清华源<br><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>全局切换华为云<br><code>pip config set global.index-url https://repo.huaweicloud.com/repository/pypi/simple</code></li>
</ul>
</li>
</ul>
<p><strong>在Windows中，pip源的配置文件在 C:\Users\用户名\AppData\Roaming\pip\pip.ini</strong><br><strong>在Ubuntu中，pip源的配置文件在 ~/.config/pip/pip.conf</strong></p>
<h2 id="2-多环境配置"><a href="#2-多环境配置" class="headerlink" title="2.多环境配置"></a>2.多环境配置</h2><h3 id="2-1创建环境"><a href="#2-1创建环境" class="headerlink" title="2.1创建环境"></a>2.1创建环境</h3><ul>
<li>创建新环境,以创建python3.7为例<br><code>conda create --name yourEnv python=3.7</code></li>
<li>激活环境<br>windows：<code>activate yourEnv</code><br>linux: <code>source activate yourEnv</code></li>
<li>查看活跃的环境<br>conda info -e</li>
</ul>
<h3 id="2-2重命名环境"><a href="#2-2重命名环境" class="headerlink" title="2.2重命名环境"></a>2.2重命名环境</h3><p>conda没有重命名指令，可以通过clone间接实现</p>
<ul>
<li>1.先clone一份new name的环境<br><code>conda create -n new_name --clone old_name</code></li>
<li>2.删除old name的环境<br><code>conda remove -n old_name --all</code></li>
<li>3.查看环境名列表<br><code>conda info -e</code></li>
</ul>
]]></content>
      <categories>
        <category>深度学习环境配置</category>
      </categories>
      <tags>
        <tag>Conda</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - static 用法总结</title>
    <url>/2021/08/03/Cpp%20-%20static/</url>
    <content><![CDATA[<h1 id="C-static-用法总结"><a href="#C-static-用法总结" class="headerlink" title="C++ - static 用法总结"></a>C++ - static 用法总结</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210803135755906.png" alt="image-20210803135755906"></p>
<h2 id="1-类外："><a href="#1-类外：" class="headerlink" title="1 - 类外："></a>1 - 类外：</h2><h3 id="1-1-全局静态变量"><a href="#1-1-全局静态变量" class="headerlink" title="1.1 - 全局静态变量"></a>1.1 - 全局静态变量</h3><ul>
<li>存储：存储于<strong>静态存储区</strong>，在整个程序运行期间一直存在。</li>
<li>初始化：未经初始化的全局静态变量会被自动初始化为0。</li>
<li>作用域：全局静态变量在声明它的文件之外是不可见的，准确地说是从定义之处开始，到cpp文件结尾。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="1-2-函数中的静态变量-局部静态变量"><a href="#1-2-函数中的静态变量-局部静态变量" class="headerlink" title="1.2 - 函数中的静态变量 (局部静态变量)"></a>1.2 - 函数中的静态变量 (局部静态变量)</h3><ul>
<li>当局部变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。</li>
<li>存储：静态存储区</li>
<li>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但当局部静态变量离开作用域后，并没有销毁，而是驻留在内存中，不能再对它进行访问，知道该所属函数再次被调用，并且值不改变，不会再次初始化。</li>
<li>这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// 静态变量只初始化第一次，所以每次调用函数时，并不会对变量计数进行初始化。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">	count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)	 </span><br><span class="line">		test(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-静态函数"><a href="#1-3-静态函数" class="headerlink" title="1.3 - 静态函数"></a>1.3 - 静态函数</h3><ul>
<li>在函数返回类型前加static，函数即被定义为静态函数。函数的定义和声明默认情况下都是extern的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。换句话说，只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突，类似于全局静态变量。</li>
<li>所以不要在头文件中声明static全局函数，这样是没有意义的。</li>
<li>不要在cpp内声明非static的全局函数，如果要在多个cpp中复用该函数，就声明到头文件中。</li>
</ul>
<h2 id="2-类内："><a href="#2-类内：" class="headerlink" title="2 - 类内："></a>2 - 类内：</h2><h3 id="2-1-类中的静态变量"><a href="#2-1-类中的静态变量" class="headerlink" title="2.1 - 类中的静态变量"></a>2.1 - 类中的静态变量</h3><p>由于声明为static的变量只被初始化一次，因为它们在单独的 <strong>静态存储区</strong> 中分配了空间，因此类中的静态变量<strong>由对象共享。</strong> <strong>对于不同的对象，不能有相同静态变量的多个副本</strong>。也是因为这个原因，<strong>静态变量不能使用构造函数初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line">	Apple() &#123;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Apple obj1; </span><br><span class="line">	Apple obj2; </span><br><span class="line">	obj1.i =<span class="number">2</span>; </span><br><span class="line">	obj2.i = <span class="number">3</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; obj1.i&lt;&lt;<span class="string">" "</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Error：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static_error_variable.cpp:(.text+0x31): undefined reference to &#96;Apple::i&#39;</span><br><span class="line">static_error_variable.cpp:(.text+0x3b): undefined reference to &#96;Apple::i&#39;</span><br><span class="line">static_error_variable.cpp:(.text+0x45): undefined reference to &#96;Apple::i&#39;</span><br><span class="line">static_error_variable.cpp:(.text+0x6b): undefined reference to &#96;Apple::i&#39;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>当尝试为多个对象创建<code>静态变量i</code>的多个副本时，发生错误。因此，类中的静态变量应由用户使用<strong>类外的类名和范围解析运算符显式初始化。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    Apple()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Apple::i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Apple obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-类中的静态函数"><a href="#2-2-类中的静态函数" class="headerlink" title="2.2 - 类中的静态函数"></a>2.2 - 类中的静态函数</h3><p>类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。<strong>使用类名和范围解析运算符调用静态成员。</strong></p>
<p><strong>静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> svar;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">// 如果在类内初始化，必须定义为常量</span></span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">42</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Apple!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Apple::svar = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Apple::printMsg(); <span class="comment">// 访问类内静态函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Apple::svar &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Apple::i &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// cout &lt;&lt; Apple::var &lt;&lt; endl; ERROR！！! 无法访问类内非静态变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello Apple!</span><br><span class="line">42</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="2-3-类对象为静态"><a href="#2-3-类对象为静态" class="headerlink" title="2.3 - 类对象为静态"></a>2.3 - 类对象为静态</h3><p>与静态变量一样，对象也在声明为static时具有范围，直到程序的生命周期结束。</p>
<p><strong>如果对象是非静态的：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Apple()</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Constructor\n"</span>;  <span class="comment">// Step 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Apple() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Destructor\n"</span>; &#125; <span class="comment">// Step 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (var == <span class="number">0</span>)</span><br><span class="line">        Apple obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"End of main\n"</span>; <span class="comment">// Step 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">Inside Destructor</span><br><span class="line">End of main</span><br></pre></td></tr></table></figure>

<p><strong>如果对象是静态的：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Apple()</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Constructor\n"</span>;  <span class="comment">// Step 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Apple() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Destructor\n"</span>; &#125; <span class="comment">// Step 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (var == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">static</span> Apple obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"End of main\n"</span>; <span class="comment">// Step 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">End of main</span><br><span class="line">Inside Destructor</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>如果对象在 <code>if块</code> 内声明为<strong>非静态</strong>，那么变量的范围仅在<code>if块</code>内，出了 <code>if块</code> 即调用析构函数，其范围仅在 <code>if块</code>内。</li>
<li>如果对象在 <code>if块</code> 内声明为<strong>静态</strong>，其析构函数在main结束后才调用，因为静态对象的范围是贯穿程序的生命周期。</li>
</ul>
]]></content>
      <categories>
        <category>C++知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++基础知识</tag>
        <tag>C++知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch1 开始</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch1%20%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1 编写一个简单的C++程序"></a>1.1 编写一个简单的C++程序</h2><ul>
<li>常见的C++程序后缀名 .cc .cxx .cpp .cp .c</li>
<li>编译命令 $ CC prog.cc 会产生一个可执行文件<ul>
<li>Windows系统命名为 prog.exe</li>
<li>UNIX系统命名为 a.out</li>
</ul>
</li>
<li>运行GNU编译器的命令是g++：<ul>
<li>$ g++ -o prog prog.cc</li>
</ul>
</li>
<li>执行完一个程序后，可以通过echo命令获得其返回值。<ul>
<li>UNIX: $ echo $?</li>
<li>Windows: $ echo %ERRORLEVEL%</li>
</ul>
</li>
</ul>
<h2 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h2><ul>
<li><p>一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语“流”（stream）想表达的是，随着时间的推移，字符是顺序生成或消耗的。</p>
</li>
<li><p>标准库定义了4个IO对象：</p>
<ul>
<li>cin 标准输入</li>
<li>cout 标准输出</li>
<li>cerr 输出警告和错误消息</li>
<li>clog 输出程序运行时的一般性信息</li>
</ul>
</li>
<li><p>向流写入数据：输出运算符 (&lt;&lt;)</p>
<ul>
<li>将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
<li>&lt;&lt;运算符接收两个运算对象：<ul>
<li>左侧的运算对象必须是一个ostream对象</li>
<li>右侧的运算对象是要打印的值</li>
</ul>
</li>
<li>输出语句使用了两次 &lt;&lt; 运算符，因为此运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象，等价于：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从流读取数据 输入运算符 (&gt;&gt;)</p>
<ul>
<li>输入运算符与输出运算符类似，接收一个istream作为其左侧运算对象，接收一个对象作为其右侧运算对象。从给定的istream读入数据，并存入给定对象中。</li>
</ul>
</li>
<li><p>endl 操作符</p>
<ul>
<li>写入endl的效果是结束当前行，并将与设备关联的缓冲区buffer中的内容刷到设备中。缓冲刷新可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</li>
<li>warning：程序员常在调试打印是时添加打印语句。这类语句应该保证”一直“刷新流。否则如果程序崩溃，输出可能还停留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</li>
</ul>
</li>
<li><p>namespace 命名空间</p>
<ul>
<li>命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。</li>
</ul>
</li>
</ul>
<h2 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3 注释简介"></a>1.3 注释简介</h2><ul>
<li>注释不能嵌套使用, /* — */ 中不能有 /* — */</li>
</ul>
<h2 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h2><ul>
<li><p>读取数量不定的输入数据</p>
<ul>
<li>使用一个istream对象，其效果是检测流的状态，如果流是有效的，ok。当遇到文件结束符（end-of-file）或遇到一个无效的输入时，istream对象的状态就会变为无效，处于无效状态的istream对象会使条件变为 假<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常见的编译器可以检查出的错误</p>
<ul>
<li>语法错误（syntax error）：比如忘了写分号</li>
<li>类型错误（type error）</li>
<li>声明错误（declaration error）：比如标识符拼写错误</li>
</ul>
</li>
</ul>
<h2 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5 类简介"></a>1.5 类简介</h2><ul>
<li>通常用.h作为头文件的后缀，但也有一些程序员习惯 .H  .hpp  .hxx，标准库头文件通常不带后缀。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch3 字符串、向量和数组</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><h2 id="3-1-命名空间的-using-声明"><a href="#3-1-命名空间的-using-声明" class="headerlink" title="3.1 命名空间的 using 声明"></a>3.1 命名空间的 using 声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用cin cout endl，用using声明</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>头文件不应该包含using声明</li>
</ul>
<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-定义和初始化-string-对象"><a href="#3-2-1-定义和初始化-string-对象" class="headerlink" title="3.2.1 定义和初始化 string 对象"></a>3.2.1 定义和初始化 string 对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化string对象的方式</span></span><br><span class="line"><span class="built_in">string</span> s1;          <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;      <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;     <span class="comment">// 和上面等价</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>; <span class="comment">// s3是字面值“value”的副本，除了字面值最好的那个空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;<span class="comment">// 和上面等价</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;  <span class="comment">// 把s4初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<p><strong>直接初始化和拷贝初始化</strong></p>
<ul>
<li>如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化。</li>
<li>不使用等号，即为直接初始化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般要初始化多个值时用直接初始化，单个两者都可</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span> <span class="comment">// 拷贝～</span></span><br><span class="line"><span class="built_in">string</span> s6(<span class="string">"hiya"</span>)  <span class="comment">// 直接～</span></span><br><span class="line"><span class="built_in">string</span> s7(<span class="number">10</span>,<span class="string">'c'</span>)  <span class="comment">// 直接～</span></span><br><span class="line"><span class="built_in">string</span> s8 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="comment">// 多个值初始化强行用拷贝～，需要显式地创建一个（临时）对象用于拷贝。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul>
<li><strong>os&lt;&lt;s</strong> 将s写到输出流os当中，返回os</li>
<li><strong>is&gt;&gt;s</strong> 从is中读取字符串赋给s，字符串以空白分隔，返回is</li>
<li><strong>getline(is, s)</strong> 从is中读取一行赋给s，返回is</li>
</ul>
<p><strong>读写string对象</strong></p>
<ul>
<li>string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符读起，直到遇见下一个空白为止。</li>
</ul>
<p><strong>使用getline读取一整行</strong></p>
<ul>
<li>getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）</li>
<li>同输入运算符一样，getline也会返回它的流参数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>; <span class="comment">//每次读入一整行，直到文件末尾</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>string::size_type 类型</strong></p>
<ul>
<li>size函数返回string对象的长度</li>
<li>size函数返回的是一个string::size_type 类型的值</li>
<li>string::size_type是一个无符号类型的值，而且能足够存放下任何string对象的大小。</li>
<li>可以利用C++11新标准，用auto或者decltype来推断变量的类型</li>
<li>假设n是一个具有负值的int，则表达式<strong>s.size()&lt;n</strong> 的结果一定是true，因为负值n会自动地转换成一个比较大的无符号值。所以如果一条表达式中已有了size函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</li>
</ul>
<p><strong>字面值和string对象相加</strong></p>
<ul>
<li>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符+的两侧的运算对象至少一个是string<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">", "</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">", "</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
<li>由于历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。</li>
</ul>
<h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a>3.2.3 处理string对象中的字符</h3><p><strong>cctype头文件中的函数</strong></p>
<ul>
<li>isalnum(c) 是数字或数字？</li>
<li>isalpha(c) 是字母？</li>
<li>isdigit(c) 是数字？</li>
<li>islower(c) 是小写字母？</li>
<li>isupper(c) 是大写字母？</li>
<li>isspace(c) 是空白？</li>
<li>ispunct(c) 是标点？</li>
<li>isxdigit(c)是十六进制数？</li>
<li>tolower(c) 是大写字母则转为小写，不是则原样输出c</li>
<li>toupper(c) 和上同理</li>
</ul>
<p><strong>使用范围for语句处理每个字符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计标点符号个数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world!!!"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ispunct</span>(c))</span><br><span class="line">            ++punct_cnt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; punct_cnt</span><br><span class="line">         &lt;&lt; <span class="string">" punctuation characters in"</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变字符串中的字符</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>处理一部分字符</strong></p>
<ul>
<li>访问string对象中的单个字符有两种方式：<ul>
<li>使用下标</li>
<li>使用迭代器</li>
</ul>
</li>
<li><strong>下标运算符( [ ] )</strong> 接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的为止，返回值是该位置上的字符的引用。</li>
<li>下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下标执行迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">    index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]);</span><br><span class="line">    ++index)</span><br><span class="line">    s[index] = <span class="built_in">toupper</span>(s[index]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-3-标准库类型-vector（容器）"><a href="#3-3-标准库类型-vector（容器）" class="headerlink" title="3.3 标准库类型 vector（容器）"></a>3.3 标准库类型 vector（容器）</h2><ul>
<li>C++语言既有类模板(class template)，也有函数模板，其中vector是一个类模板</li>
<li>编译器根据模板创建类或函数的过程称为<strong>实例化</strong></li>
</ul>
<h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul>
<li>vector<T> v1 v1是空vector，执行默认初始化</li>
<li>vector<T> v2(v1) v2中包含有v2中所有元素的副本</li>
<li>vector<T> v2 = v1 同上等价</li>
<li>vector<T> v3(n, val) v3中包含了n个重复的元素val</li>
<li>vector<T> v4(n) v4包含n个元素，默认初始化</li>
<li>vector<T> v5{a,b,c…}</li>
<li>vector<T> v5 = {a,b,c..} 同上等价</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++11新标准 列表初始化vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定数量的元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>; <span class="comment">//10个-1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">"hi"</span>)</span></span>; <span class="comment">//10个string类型的元素，每个都被初始化为"hi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//10个元素，每个都被初始化为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//10个元素，每个都是空是string对象</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h3><ul>
<li>push_back</li>
<li>pop_back</li>
</ul>
<p><strong>向vector对象添加元素蕴含的编程假定</strong><br>如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。范围for语句体内不应改变其遍历序列的大小。</p>
<h2 id="3-4-迭代器"><a href="#3-4-迭代器" class="headerlink" title="3.4 迭代器"></a>3.4 迭代器</h2><ul>
<li>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</li>
</ul>
<h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><ul>
<li>有迭代器的类型同时拥有返回迭代器的成员，这些类型都有名为 begin 和 end 的成员。<ul>
<li><strong>begin</strong>，返回指向第一个元素的迭代器</li>
<li><strong>end</strong>，返回指向容器尾元素的下一个位置的迭代器。称为尾后迭代器(off-the-end iterator)</li>
<li>如果容器为空，则begin和end返回的是同一个迭代器。都是尾后迭代器。</li>
</ul>
</li>
</ul>
<p><strong>泛型编程</strong></p>
<ul>
<li>C++程序员习惯地使用!=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。</li>
</ul>
<p><strong>迭代器类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;  <span class="comment">// it2能读写string 对象中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3; <span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4; <span class="comment">// it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。</p>
<ul>
<li>如果vector对象或string对象是一个常量，只能用const_iterator</li>
<li>如果vector对象或string对象不是常量，即可用iterator也能使用const_iterator</li>
</ul>
</li>
<li><p>begin和end运算符</p>
<ul>
<li>begin和end返回的具体类型由对象是否是常量决定。是iterator还是const_iterator</li>
<li><strong>C++11新标准</strong>，为了便于专门得到const_iterator类型的返回值，引入两个新函数<ul>
<li>cbegin()</li>
<li>cend()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>结合解引用和成员访问操作</strong></p>
<ul>
<li>it-&gt;men 和 (*it).men 等价</li>
<li>箭头运算符把解引用和成员访问两个操作结合在了一起</li>
</ul>
<p><strong>某些对vector对象的操作会使迭代器失效</strong></p>
<ul>
<li>不能在范围for循环中向vector对象添加元素</li>
<li>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</li>
<li>谨记，凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</li>
</ul>
<h3 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h3><ul>
<li>只要两迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，结果是两个迭代器的举例。类型是名为 <strong>difference_type</strong> 的带符号整数类型，因为这个距离可正可负。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索，text有序，beg和end是搜索范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = <span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">end</span> = <span class="built_in">text</span>.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">min</span> = <span class="built_in">text</span>.<span class="built_in">begin</span>() + (<span class="built_in">end</span> - beg)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(mid != <span class="built_in">end</span> &amp;&amp; *mid != sought)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (<span class="built_in">end</span> - beg)/<span class="number">2</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><ul>
<li>数组是一种复合类型，声明 a[n], n是数组维度。维度必须是一个常量表达式<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;   <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];  <span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr[sz]; <span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];  <span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line">stromg strs[get_size()]; <span class="comment">// 只有get_size是constexpr时正确</span></span><br></pre></td></tr></table></figure></li>
<li>和内置类型的变量一样，如果在函数内部定义了某种类型的数组，那么默认初始化会令数组含有为定义的值。</li>
</ul>
<p><strong>字符数组的特殊性</strong></p>
<ul>
<li>字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>&#125;; <span class="comment">//列表初始化，没有空字符，维度3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'\0'</span>&#125;; <span class="comment">//列表初始化，含有显式的空字符，维度4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>; <span class="comment">//自动添加表示字符串结束的空字符，维度4</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>; <span class="comment">// 错误：没有空间放空字符！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>不允许拷贝和赋值</strong></p>
<ul>
<li>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//含有三个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[] = a; <span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;       <span class="comment">//错误：不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>理解复杂的数组声明</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组的名字开始按照由内向外的顺序阅读</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];   <span class="comment">//ptrs是含有10个整型指针的数组。</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span> <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;Parray)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul>
<li>在使用数组下标的时候，通常定义为<strong>size_t</strong>类型。这是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在<strong>cstddef头文件</strong>中定义了<strong>size_t</strong>类型。</li>
</ul>
<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; <span class="comment">// p指向nums的第一个元素</span></span><br><span class="line"><span class="built_in">string</span> *p2 = nums; <span class="comment">// 与 p2 = &amp;nums[0]等价</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针<ul>
<li>根据这个特性，当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组</li>
<li>当使用decltype关键字时上述类型转换不会发生，decltype(ia)返回的类型是由5个整数构成的数组<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;  <span class="comment">// ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">// 错误：不能用整型指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i; <span class="comment">// 正确：把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>指针也是迭代器</strong></p>
<ul>
<li>通过数组名字或者数组中首元素的地址都能得到还想首元素的指针</li>
<li>获取尾后指针，可以设法获取数组尾元素之后的那个并不存在的元素的地址<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *e = &amp;arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = arr; b != e; ++b)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>标准库函数 begin 和 end</strong></p>
<ul>
<li><strong>C++11新标准</strong>引入了begin和end，这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为他们的参数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia); <span class="comment">// 指向ia的首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">end</span> = <span class="built_in">end</span>(ia);   <span class="comment">// 指向arr尾元素的下一个位置的指针</span></span><br></pre></td></tr></table></figure></li>
<li>尾后指针不能执行解引用和递增操作</li>
</ul>
<p><strong>指针运算</strong></p>
<ul>
<li>两个指针相减的类型是 <strong>ptrdiff_t</strong> 的标准库类型，和size_t一样，也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能是负的，所以是一种带符号类型。</li>
</ul>
<p><strong>下标和指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>]; <span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];    <span class="comment">// p[1]等价于*(p+1),即ia[3]</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];   <span class="comment">// p[-2]是ia[0]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然标准库类型string和vector也能执行下标运算，但是标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上例即说明了这点。内置的下标运算符可以处理负值，结果地址必须指向原来的指针所指同一数组中的元素</li>
</ul>
<h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3><p><strong>C标准String函数</strong></p>
<ul>
<li>strlen(p)</li>
<li>strcmp(p1,p2)</li>
<li>strcat(p1,p2) 将p2附加到p1后，返回p1</li>
<li>strcpy(p1,p2) 将p2拷贝给p1，返回p1</li>
</ul>
<p><strong>目标字符串的大小由调用者指定</strong></p>
<ul>
<li>连接或拷贝C风格字符串于标准库string对象的同类操作差别很大，比如两个字符串相加<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准库string</span></span><br><span class="line"><span class="built_in">string</span> largeStr = s1 + <span class="string">" "</span> + s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C风格，使用strcat和strcpy必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳结果字符串及末尾的空字符。</span></span><br><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1);</span><br><span class="line"><span class="built_in">strcat</span>(largeStr, <span class="string">" "</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(largeStr, ca2);</span><br><span class="line"><span class="comment">// 如果计算错了largeStr的大小将引发严重错误</span></span><br></pre></td></tr></table></figure></li>
<li>使用标准库string要比C风格字符串更安全，更高效</li>
</ul>
<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><p><strong>混用string对象和C风格字符串</strong></p>
<ul>
<li>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：<ul>
<li>允许使用以空字符结束的字符数组来初始化tring对象或为string对象赋值</li>
<li>在string对象的加法运算中使用以空字符结束的字符数组作为其中一个运算对象（不能两个都是）：在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象</li>
</ul>
</li>
<li>string专门提供来一个名为c_str的成员函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *str = s;  <span class="comment">//错误：不能用string对象初始化char</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li>
<li>c_str函数的返回值是一个C风格的字符串。即以一个指针，该指针指向一个以空字符结束的字符数组。</li>
</ul>
<p><strong>使用数组初始化vector对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr),<span class="built_in">end</span>(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针</li>
<li>应尽量使用string，避免使用C风格的基于数组的字符串</li>
</ul>
<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><ul>
<li>类似于一维数组，在初始化多维数组时也并非所有的元素的值都必须包含在初始化列表中<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>&#125;, &#123;<span class="number">4</span>&#125; ,&#123;<span class="number">8</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//只初始化每行的首元素，其他未列出的元素执行默认值初始化</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>多维数组的下标引用</strong></p>
<ul>
<li>经常用两层嵌套for循环来处理多维数组的元素<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != rowCnt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j != colCnt; ++j)</span><br><span class="line">        ia[i][j] = i * colCnt + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用范围for语句处理多维数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么要用引用？<strong>为了避免数组被自动转成指针</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;col&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 上面编译通过，下面报错</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure></li>
<li>由于row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row的类型就是 int* ，显然内层的循环就不合法了。</li>
<li>使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch2 - 变量和基本类型</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch2%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><h3 id="2-1-1-算数类型"><a href="#2-1-1-算数类型" class="headerlink" title="2.1.1 算数类型"></a>2.1.1 算数类型</h3><ul>
<li><p>一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值，即一个char的大小和一个机器字节一样。</p>
</li>
<li><p>C++11 新定义了 long long 数据类型</p>
</li>
<li><p>内置类型的机器实现</p>
<ul>
<li><strong>可寻址的最小内存块称为“字节”（byte）</strong></li>
<li><strong>存储的基本但愿称为“字”（word）</strong>，通常由几个字节组成，C++中一个字节要至少能容纳机器基本字符集中的字符。</li>
<li>大多数机器的字节由8比特构成，字则有32或64比特构成，即4或8字节。</li>
<li>大多数计算机将内存中的每一个字节与一个数字（地址address）关联起来。</li>
</ul>
</li>
<li><p>通常，float以1个字（32bit）来表示，double以2个字（64bit）来表示，long double以3或4个字来表示，float和double分别有7和16个有效数字。</p>
</li>
<li><p>带符号类型和无符号类型</p>
<ul>
<li>带符号类型可表示正数，负数或0</li>
<li>无符号类型仅能表示大于等于0的值</li>
<li>unsigned int 可缩写 unsigned</li>
<li>无符号类型中所有比特都用来存储值，8比特的unsigned char可表示0到255区间内的值</li>
<li>当明确知晓数值不可能为负时，选用无符号类型</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>;   <span class="comment">// b为真</span></span><br><span class="line"><span class="keyword">int</span> i = b;     <span class="comment">// i=1</span></span><br><span class="line">i = <span class="number">3.14</span>;      <span class="comment">// i=3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;        <span class="comment">// pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>; <span class="comment">// 假设char占8bit，c=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>; <span class="comment">// 假设char占8bit，c2的值是未定义的</span></span><br><span class="line"><span class="comment">// 类型所能表示的值的番位决定了转换的过程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>含有无符号类型的表达式<ul>
<li>当一个算术表达式中即有无符号数又有int值时，那个int值会转为无符号数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出-84</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u + i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 如果int占32位，输出4294967264</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3></li>
</ul>
</li>
<li>整型字面值，以0开头为八进制，以0x或0X开头为十六进制</li>
<li>十进制字面值不会是负数。如果使用了一个形如-42的负十进制字面值，负号并不在字面值之内，它的作用仅是对字面值取负值而已</li>
<li>字符和字符串字面值<ul>
<li>‘A’表示单独的字符A</li>
<li>“A”代表了一个字符的数组，该数组包含两个字符：一个字母A和一个空字符</li>
</ul>
</li>
<li>指定字面值的类型，通过加 <strong>前缀</strong> 和 <strong>后缀</strong></li>
<li>true和false是布尔类型的字面值</li>
<li><strong>nullptr是指针字面值</strong></li>
</ul>
<h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><ul>
<li><strong>列表初始化 C++11 新标准</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4种初始化方式</span></span><br><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;  <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>默认初始化<ul>
<li>如果定义变量没有指定初值，则变量会被默认初始化。</li>
<li>内置类型的变量未被显式初始化，它的值由定义的位置决定。<strong>定义于任何函数体之外的变量被初始化为0</strong></li>
<li><strong>一种例外情况，定义在函数体内部的内置类型变量将不被初始化</strong></li>
</ul>
</li>
</ul>
<h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><ul>
<li>C++语言支持<strong>分离式编译</strong>（separate compilation），将程序分割为若干个文件，每个文件可被独立编译。</li>
<li>为支持分离式编译，需要将<strong>声明</strong>和<strong>定义</strong>区分开来。<ul>
<li>声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。</li>
<li>定义（definition）负责创建于名字关联的实体。</li>
</ul>
</li>
<li><strong>extern</strong>关键字：如果声明一个变量而非定义它，就在变量名前添加extern，extern语句如果包含初始值就不再是声明而变成定义了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j;        <span class="comment">// 声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li>
<li>静态类型<ul>
<li>C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型，</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><ul>
<li>用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</li>
</ul>
<h3 id="2-2-4-名字的作用域：嵌套作用域"><a href="#2-2-4-名字的作用域：嵌套作用域" class="headerlink" title="2.2.4 名字的作用域：嵌套作用域"></a>2.2.4 名字的作用域：嵌套作用域</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">//unique拥有块作用域</span></span><br><span class="line">    <span class="comment">// 输出#1:使用全局变量reused 输出42 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">" "</span>&lt;&lt;unique&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">//新建局部变量reused，覆盖了全局变量reused</span></span><br><span class="line">    <span class="comment">// 输出#2:使用局部变量reused 输出 42 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">" "</span>&lt;&lt;unique&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出#3:显示地访问全局变量reused 输出42 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="string">" "</span>&lt;&lt;unique&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出#3 使用<strong>作用域操作符</strong>来覆盖默认的作用域规则，因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。结果是第三条输出语句使用全局变量reused。</li>
</ul>
<h2 id="2-3-符合类型"><a href="#2-3-符合类型" class="headerlink" title="2.3 符合类型"></a>2.3 符合类型</h2><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><ul>
<li>定义引用时，程序把引用和它的初始值<strong>绑定</strong>（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>; <span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i, r2 = i2;     <span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3; <span class="comment">// i3是int，ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 = i2;  <span class="comment">// r3和r4都是引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>;   <span class="comment">// 错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval; <span class="comment">// 错误：引用类型的初始值必须是int型</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><ul>
<li><p>指针与引用的不同：</p>
<ul>
<li>指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>
<li>指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
</li>
<li><p>因为引用不是对象，没有实际地址，所以<strong>不能定义指向引用的指针</strong></p>
</li>
<li><p><strong>nullptr</strong> ：C++11新特性，用字面值nullptr来初始化指针得到空指针</p>
</li>
<li><p>要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值，最好记住<strong>赋值永远改变的等号左边的对象</strong></p>
</li>
<li><p><strong>void*指针</strong>：一种特殊的指针类型，可用于存放任意对象的地址</p>
</li>
</ul>
<h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果要连续定义多个变量</span></span><br><span class="line"><span class="keyword">int</span>* p; <span class="comment">// 合法但容易产生误导</span></span><br><span class="line"><span class="keyword">int</span>* p1, p2; <span class="comment">// p1是指向int的指针，p2是int</span></span><br><span class="line"><span class="keyword">int</span> *p1, *p2 <span class="comment">// 正确的写法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指向指针的指针<ul>
<li>通过<em>的个数可以区分指针的级别，*</em>表示指向指针的指针，以此类推，</li>
</ul>
</li>
<li>指向指针的引用<ul>
<li>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;      <span class="comment">// p是一个int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">// r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// 解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>从右往左读</strong> 确定r的类型：离r最近的是&amp;，因此r是一个引用，&amp;左边的*说明r引用的是一个指针，最后声明的基本数据类型部分指出r引用的是一个int指针。</li>
</ul>
<h2 id="2-4-const-限定符"><a href="#2-4-const-限定符" class="headerlink" title="2.4 const 限定符"></a>2.4 const 限定符</h2><ul>
<li>默认状态下，const 对象仅在文件内有效，如何在一个文件中定义const，而在多个文件中声明并使用它，解决办法是：<strong>对于const变量不管是声明还是定义都添加extern关键字</strong>，这样只需一次定义即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fcn();</span><br><span class="line"><span class="comment">// file_1.h , 与file_1.cc中定义的是同一个</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3></li>
<li>“对const的引用“简称为”常量引用“</li>
<li><strong>初始化和对const的引用</strong>：引用的类型必须与所引用对象的类型一致，但有两个例外：<ul>
<li>在初始化常量引用时用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;   <span class="comment">// 允许将const int&amp;绑定到一个普通的int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">// 正确：r2是常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>;<span class="comment">// 正确：r3是常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;      <span class="comment">// 错误：r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当一个常量引用被绑定到另外一种类型时发生了什么</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。此时绑定的对象是一个临时量temp而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则为何要给ri赋值？如此看来，既然大家基本上不会想着引用绑定到临时变量上，C++语法也就把这种行为归位非法。</li>
</ul>
<p><strong>对const的引用可能引用一个并非const的对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>; <span class="comment">//正确：可以通过r1修改i的值,r1 r2 都变成0</span></span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">//错误：r2是一个常量引用</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><ul>
<li>指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;  <span class="comment">// pi是常量，值不能变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;       <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;<span class="comment">// 正确：cptr可以指向一个double型常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;  <span class="comment">// 错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对应2.3.2节p47，指针的类型必须与其所指对象的类型一致，但有两种例外</strong>，其一：</p>
<ul>
<li>允许一个指向常量的指针指向一个非常量对象。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>; <span class="comment">//dval的值可以改变</span></span><br><span class="line">cptr = &amp;dval; <span class="comment">// 正确：但是不能通过cptr改变dval，比如*cptr=0是错误的。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>const指针</strong></p>
<ul>
<li>常量指针必须初始化，而且一旦初始化完成，则它的值（即存放指针中的那个地址）就不能再改变了<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;</span><br><span class="line"><span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>顶层const</strong></p>
<ul>
<li>顶层const（top-level const）：指针本身是个常量</li>
<li>底层const（low-level const）：指针所指的对象是一个常量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;  <span class="comment">// 不能改变p1的值，是顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;   <span class="comment">// 不能改变ci的值，是顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci; <span class="comment">// 允许改变p2的值，是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 右顶左底</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci; <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure></li>
<li>执行对象的拷贝操作时<ul>
<li>顶层const不受影响</li>
<li>底层const有限制，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i = ci; <span class="comment">//正确：拷贝ci的值，ci是顶层const，无影响</span></span><br><span class="line">p2 = p3; <span class="comment">//正确：p2和p3指向的一些类型相同，p3顶层const的部分不影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误：p3既有顶层const也有底层const的定义，包含了底层const，而p没有</span></span><br><span class="line">p2 = p3;     <span class="comment">//正确：p2和p3都是底层const</span></span><br><span class="line">p2 = &amp;i;     <span class="comment">//正确：int*能转换成const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci; <span class="comment">//错误：普通的int&amp;不能绑定到int常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; <span class="comment">//正确：const int&amp;可绑定到一个普通的const上</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-constexpr常量表达式"><a href="#2-4-4-constexpr常量表达式" class="headerlink" title="2.4.4 constexpr常量表达式"></a>2.4.4 constexpr常量表达式</h3><ul>
<li>为分辨一个初始值到底是不是常量表达式。</li>
<li>C++11新标准，允许将变量声明为constexpr类型以便编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</li>
<li>一个constexpr指针的初始值必须是nullptr或0，或是存储于某个固定地址中的对象。</li>
<li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，对指针所指的对象无关。</li>
</ul>
<h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><ul>
<li>传统方法使用关键字typedef</li>
<li><strong>C++11新标准</strong> 使用别名声明<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//别名声明</span></span><br><span class="line"><span class="keyword">typedef</span> Sales_item SI;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-2-auto类型说明符-C-11新特性"><a href="#2-5-2-auto类型说明符-C-11新特性" class="headerlink" title="2.5.2 auto类型说明符 C++11新特性"></a>2.5.2 auto类型说明符 C++11新特性</h3><ul>
<li>使用auto在一条语句中声明多个变量，该语句中所有变量的初始基本数据类型必须一样：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">//正确：i是整数，p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span> <span class="comment">//错误：sz和pi类型不同</span></span><br></pre></td></tr></table></figure></li>
<li>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。<ul>
<li>当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型。</li>
<li>auto一般会忽略掉顶层const，保留底层const<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//a是一个整数（r是i的别名，而i是一个整数）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">//b是一个整数（ci的顶层const被忽略）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">//c是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">//d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;<span class="comment">//e是一个指向整数常量的指针（对常量对象取地址的一种底层const）</span></span><br><span class="line"><span class="comment">// 如果希望推断出的auto类型是一个顶层const，需明确指出：</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;</span><br><span class="line"><span class="comment">// 还可以将引用的类型设为auto，此时原来的初始化规则仍然使用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">// g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>; <span class="comment">// 错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>; <span class="comment">// 正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-5-3-decltype类型指示符-C-11新特性"><a href="#2-5-3-decltype类型指示符-C-11新特性" class="headerlink" title="2.5.3 decltype类型指示符 C++11新特性"></a>2.5.3 decltype类型指示符 C++11新特性</h3><ul>
<li>希望从表达式的类型推断出要定义的变量和类型，但是不想用该表达式的值初始化变量。decltype的作用是选择并返回操作数的数据类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x; <span class="comment">// sum的类型就是函数f的返回值类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// 错误：z是一个引用，必须初始化。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>decltype和引用</strong></p>
<ul>
<li><p>有时表达式向decltype返回一个引用类型。这以为着该表达式的结果对象能作为一条赋值语句的左值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//正确：加法的结果是int，因此b是一个（未初始化的）int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;    <span class="comment">//错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure></li>
<li><p>因为r是一个引用，所以decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p>
</li>
<li><p>如果表达式的内容是解引用操作，则decltype将得到医用类型，decltype(*p)的结果是int&amp;，不是int。</p>
</li>
<li><p>decltype和auto的一个重要区别：decltype的结果类型于表达式形式密切相关</p>
<ul>
<li>如果变量名加了括号，编译器会把它当作一个表达式。<strong>变量是一种可以作为赋值语句左值的特殊表达式</strong>，所以这样的decltype就会得到引用类型</li>
<li>不加括号得到的结果就是该变量的类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误：d是int&amp;，未初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;  <span class="comment">//正确：e是一个（未初始化的）int</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>decltype((variable))的结果永远是引用</strong></p>
<h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><ul>
<li>C++11新特性，可以为数据成员提供一个类内初始值。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>; <span class="comment">//默认初始化</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;    <span class="comment">//默认初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><ul>
<li>头文件通常包含那些只能被定义一次的实体，如类、const 和 constexpr 变量</li>
</ul>
<p><strong>预处理器概述</strong></p>
<ul>
<li>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器（preprocessor）</strong></li>
<li><strong>头文件保护符</strong>：依赖于预处理变量，预处理变量有两种状态：已定义和未定义<ul>
<li><strong>#define</strong> 指令把一个名字设定为预处理变量</li>
<li><strong>#ifdef</strong> 当且仅当变量已定义时为真</li>
<li><strong>#ifndef</strong> 当且仅当变量未定义时为真</li>
<li>一旦检查结果为真，则执行后续操作直到遇到 <strong>#endif</strong> 指令为止</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直到遇到endif为止。此时，预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则#ifndef的检查结果为假，编译器将忽略#ifndef到#endif之间的部分。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch5 语句</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch5%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><p><strong>空语句</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">; <span class="comment">// 空语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复读入数据直至到达文件末尾或某次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ; <span class="comment">//空语句</span></span><br><span class="line"><span class="comment">// 使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if语句"><a href="#5-3-1-if语句" class="headerlink" title="5.3.1 if语句"></a>5.3.1 if语句</h3><h3 id="5-3-2-switch语句"><a href="#5-3-2-switch语句" class="headerlink" title="5.3.2 switch语句"></a>5.3.2 switch语句</h3><ul>
<li>switch语句首先对括号离的表达式求值，该表达式紧跟在关键字switch的后面，可以是一个初始化的变量声明。表达式的值转换称整数类型，然后与每个case标签的值比较。</li>
<li>case关键字和它对应的值一起被成为case标签(case label)。case标签必须是整型常量表达式<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = getVal();</span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3.14</span>: <span class="comment">// 错误：case标签不是一个整数</span></span><br><span class="line">    <span class="keyword">case</span> ival; <span class="comment">// 错误：case标签不是一个常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>switch内部的控制流</strong></p>
<ul>
<li>有时默认的switch也是必要的。每个case标签只能对应一个值，但是有时候我们希望两个或更多个值共享一个操作。此时可以故意省略break语句，使得程序能够连续执行若干个case标签<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> vowelCnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 出现了a、e、i、o、u中的任意一个都会将vowelCnt的值加1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把几个case标签写在一行里，强调这些case代表的是某个范围内的值</span></span><br><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>switch内部的变量定义</strong></p>
<ul>
<li>switch的执行流程可能会跳过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉，如果被忽略的代码中含有变量的定义怎么办？<ul>
<li>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line"><span class="comment">//因为程序执行流程可能绕开下面的初始化语句，所以该switch语句不合法</span></span><br><span class="line">    <span class="built_in">string</span> file_name; <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> ival = <span class="number">0</span>;     <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> jval;         <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line"><span class="comment">// 正确：javal虽然在作用域内，但是它没有被初始化</span></span><br><span class="line">    javal = next_num(); <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">if</span>(file_name.empty()) <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之内。</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//正确：声明语句位于语句块内部</span></span><br><span class="line">         <span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    <span class="keyword">if</span>(file_name.empty()) <span class="comment">//错误：file_name不在作用域内</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while语句"><a href="#5-4-1-while语句" class="headerlink" title="5.4.1 while语句"></a>5.4.1 while语句</h3><p><strong>使用while循环</strong></p>
<ul>
<li>当不确定到底要迭代多少次时，使用while循环比较何时，比如读取输入的内容</li>
<li>当想再循环结束后访问循环控制变量，用while循环</li>
</ul>
<h3 id="5-4-2-传统的for语句"><a href="#5-4-2-传统的for语句" class="headerlink" title="5.4.2 传统的for语句"></a>5.4.2 传统的for语句</h3><blockquote>
<p>for (init-statemen; condition; expression)<br> statement</p>
</blockquote>
<p><strong>for语句头中的多重定义</strong></p>
<ul>
<li><p>init-statment也可以定义多个对象。但是init-statement只能有一条声明语句，因此，所有变量的基础类型必须相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录下v的大小，当到达原来的最后一个元素后结束循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(v.<span class="built_in">size</span>()) i = <span class="number">0</span>, sz = v.<span class="built_in">size</span>(); i != sz; ++i)</span><br><span class="line">    v.push_back(v[i]);</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-范围for语句"><a href="#5-4-3-范围for语句" class="headerlink" title="5.4.3 范围for语句"></a>5.4.3 范围for语句</h3></li>
<li><p>范围for语句（range for statement）</p>
<blockquote>
<p>for (declaration : expression)<br>statement</p>
</blockquote>
</li>
<li><p>expression 表示的必须是一个序列，比如用花括号扩起来的初始值列表、数组或者 vector、string 等类型的对象</p>
</li>
<li><p>declaration 定义一个变量，序列中的每个元素都得能转换成该变量的类型。<strong>确保类型相容最简单的方法就是使用auto类型说明符</strong></p>
</li>
<li><p>如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">    r *= <span class="number">2</span>; <span class="comment">// 将v中每个元素的值翻倍</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-4-do-while语句"><a href="#5-4-4-do-while语句" class="headerlink" title="5.4.4 do while语句"></a>5.4.4 do while语句</h3></li>
</ul>
<blockquote>
<p>do<br> statement<br>while (condition) ;</p>
</blockquote>
<ul>
<li>do while 语句应该在括号包围起来的条件后面用一个分号表示语句结束。</li>
</ul>
<h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><p><strong>break语句</strong></p>
<ul>
<li>break负责终止离它最近的while、do while、for、switch语句，并从这些语句之后的第一条语句开始继续执行</li>
</ul>
<p><strong>continue语句</strong></p>
<ul>
<li>出现在嵌套循环中的continue语句也仅作用于理它最近的循环</li>
</ul>
<p><strong>goto语句</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>:</span><br><span class="line">    <span class="keyword">int</span> sz = get_size();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">begin</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-try语句块和异常处理"><a href="#5-6-try语句块和异常处理" class="headerlink" title="5.6 try语句块和异常处理"></a>5.6 try语句块和异常处理</h2><p><strong>异常处理包括：</strong></p>
<ul>
<li><strong>throw 表达式(throw expression):</strong> 异常检测部分使用throw表达式来表示它遇到来无法处理的问题。即throw 引发 了异常。</li>
<li><strong>try 语句块(try block):</strong> try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句”处理“异常，所以他们也被称作<strong>异常处理代码(exception handler)</strong></li>
<li>一套<strong>异常类(exception class):</strong> 用于在throw表达式和相关catch子句之间传递异常的具体信息。</li>
</ul>
<h3 id="5-6-1-throw-表达式"><a href="#5-6-1-throw-表达式" class="headerlink" title="5.6.1 throw 表达式"></a>5.6.1 throw 表达式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_item item1, item2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="keyword">if</span>(item1.isbn() == item2.isbn())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Data must refer to same ISBN"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用异常处理</span></span><br><span class="line"><span class="keyword">if</span> (item1.isbn() != item2.isbn())</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="comment">// 如果程序执行到了这里，表示两个ISBN是相同的</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该异常是类型 <strong>runtime_error</strong>的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</li>
<li><strong>类型runtime_error</strong> 是标准库异常类型的一种，定义在<strong>stdexcept头文件</strong>  中</li>
<li>必须初始化<strong>runtime_error</strong>对象，方式是给它提供一个string对象或者一个C风格的字符串</li>
</ul>
<h3 id="5-6-2-try-语句块"><a href="#5-6-2-try-语句块" class="headerlink" title="5.6.2 try 语句块"></a>5.6.2 try 语句块</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (runtime_error err)&#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.what()</span><br><span class="line">             &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>给用户的提示信息中输出了<strong>err.what()</strong>的返回值。what是runtime_error类的一个成员函数。</li>
<li>每个标准库异常类都定义类名为what的成员函数，这些函数没有参数，返回的是C风格字符串(即 const char*)</li>
<li>如果最终没能找到任何匹配的catch子句，程序转到名为<strong>terminate</strong>的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</li>
</ul>
<h3 id="5-6-3-标准异常"><a href="#5-6-3-标准异常" class="headerlink" title="5.6.3 标准异常"></a>5.6.3 标准异常</h3><ul>
<li><strong>exception头文件</strong> 定义了最通用的异常类<strong>excetion</strong>。它只报告异常的发生，不提供任何额外信息。</li>
<li><strong>stdexcept头文件</strong> 定义了集中常用的异常类</li>
<li><strong>new头文件</strong> 定义了 <strong>bad_alloc</strong>异常类型</li>
<li><strong>type_info头文件</strong> 定义了 <strong>bad_cast</strong> 异常类型</li>
</ul>
<p><strong>&lt;stdexcept&gt; 定义的异常类:</strong></p>
<ul>
<li>exception 最常见问题</li>
<li>runtime_error 只有在运行时才能检测出的问题</li>
<li>range_error   运行时错误：生成的结果超出类有意义的值域范围</li>
<li>overflow_error    运行时错误：计算上溢</li>
<li>underflow_error   运行时错误：计算下溢</li>
<li>logic_error   程序逻辑错误</li>
<li>domain_error  逻辑错误：参数对应的结果值不存在</li>
<li>invalid_argument  逻辑错误：无效参数</li>
<li>length_error  逻辑错误：试图创建一个超出该类型的最大长度的对象</li>
<li>out_of_range  逻辑错误：使用一个超出有效范围的值</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter切换内核使用Conda虚拟环境</title>
    <url>/2021/06/02/Jupyter%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E4%BD%BF%E7%94%A8Conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Jupyter切换内核使用Conda虚拟环境"><a href="#Jupyter切换内核使用Conda虚拟环境" class="headerlink" title="Jupyter切换内核使用Conda虚拟环境"></a>Jupyter切换内核使用Conda虚拟环境</h1><ol>
<li><p>默认环境为<code>base</code>,新建虚拟环境<code>my-env</code></p>
</li>
<li><p>在两个环境下分别执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install jupyter ipykernel</span><br></pre></td></tr></table></figure>
</li>
<li><p>在相应虚拟环境(my-env)下执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name my-env --display-name "Python (my-env)"</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>深度学习环境配置</category>
      </categories>
      <tags>
        <tag>Conda</tag>
        <tag>Jupyter</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch4 表达式</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch4%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值</p>
<h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><p><strong>重载运算符</strong></p>
<ul>
<li>使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</li>
</ul>
<p><strong>左值和右值</strong></p>
<ul>
<li>左值可以位于赋值语句的左侧，右值则不能</li>
<li>一个左值表达式的求值结果是一个对象或一个函数，然而以常量对象为代表的某些左值实际上不能作为负值语句的左侧运算对象</li>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）</li>
<li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li>
</ul>
<h3 id="4-1-2-优先级与结合律"><a href="#4-1-2-优先级与结合律" class="headerlink" title="4.1.2 优先级与结合律"></a>4.1.2 优先级与结合律</h3><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><p><strong>有4种运算符明确规定了运算对象的求值顺序</strong></p>
<ul>
<li>逻辑与(&amp;&amp;)，规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值</li>
<li>逻辑或(||)</li>
<li>条件(?:)运算符</li>
<li>逗号(,)运算符</li>
</ul>
<h2 id="4-2-算数运算符"><a href="#4-2-算数运算符" class="headerlink" title="4.2 算数运算符"></a>4.2 算数运算符</h2><p><strong>+、-（正负号）、*、/、%、+、-（加减号）</strong></p>
<ul>
<li><p>除非另作说明，算数运算符都能作用于任何算数类型以及任意能转换为算数类型的类型。</p>
</li>
<li><p>对于大多数运算符来说，布尔类型的运算对象将被提升为int类型。</p>
<ul>
<li>下例，布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负为-1，将-1再转回bool，除了0都会转为true。所以b2为真<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b;  <span class="comment">// b2是true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>C++新标准 除法运算取整</strong></p>
<ul>
<li>除法运算中，C++语言早起版本允许结果为负值的商向上或向下取整，C++11新标准规定商一律向0取整（即直接切除小数部分）</li>
</ul>
<p><strong>取余运算</strong></p>
<ul>
<li>m%n 不等于0，则它的符号同m相同</li>
</ul>
<h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><p><strong>！、&lt;、&lt;=、&gt;、&gt;=、==、!=、&amp;&amp;、||</strong></p>
<p><strong>逻辑与和逻辑或运算符</strong></p>
<ul>
<li>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称作<strong>短路求值(short-circuit evaluation)</strong></li>
</ul>
<h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><ul>
<li><strong>C++11新标准</strong>允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">k = &#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 错误：窄化转换</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; <span class="comment">// 初始为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>赋值运算满足右结合律<ul>
<li>对于多重赋值语句中的每一个对象，它的类型或者与右侧对象的类型相同、或者可由右边对象的类型转换得到<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval; <span class="comment">// ival的类型是int，pval是指向int的指针</span></span><br><span class="line">ival = pval = <span class="number">0</span>; <span class="comment">// 错误：不能把指针负值给int</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line">s1 = s2 = <span class="string">"OK"</span>; <span class="comment">// 字符串字面值“OK”转换成string对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="4-5-递增和递增运算符"><a href="#4-5-递增和递增运算符" class="headerlink" title="4.5 递增和递增运算符"></a>4.5 递增和递增运算符</h2><p><strong>++ 、 –</strong></p>
<ul>
<li>递增和递减有两种形式：前置版本 和 后置版本</li>
<li>前置版本，先将运算对象+1或-1，然后将改变后的对象作为求值结果</li>
<li>后置版本，也将运算对象+1或-1，但是求值结果是运算对象改变之前那个值的副本</li>
</ul>
<p><strong>建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码更符合编程的初衷</strong></p>
<ul>
<li>后置版本需要将元史之存储下来以便于返回这个未修改的内容。浪费</li>
</ul>
<p><strong>在一条语句中混用解引用和递增运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>()</span><br><span class="line"><span class="comment">// 输出元素直到遇到第一个负值为止</span></span><br><span class="line"><span class="keyword">while</span>(pbeg != v.<span class="built_in">end</span>() &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>后置递增运算符的优先级高于解引用运算符，因此 *pbeg++等价于 *(pbeg++)</p>
</li>
<li><p>简洁可以成为一种美德</p>
<ul>
<li>cout &lt;&lt; *iter++ &lt;&lt; endl;</li>
</ul>
</li>
</ul>
<h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h2><ul>
<li>点运算符和箭头运算符都可用于访问成员</li>
<li>ptr-&gt;men 等价于 (*ptr).men</li>
</ul>
<h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><ul>
<li>cond ? expr1 : expr2;</li>
<li>在输出表达式中使用条件运算符<ul>
<li>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ((grade) &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span> ); <span class="comment">// 输出pass或者fail</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>; <span class="comment">//输出1或者0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;  <span class="comment">//错误：试图比较cout和60</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><ul>
<li>～ 位求反</li>
<li>&lt;&lt; 左移</li>
<li>&gt;&gt; 右移</li>
<li>&amp; 位与</li>
<li>^ 位异或</li>
<li>| 位或</li>
</ul>
<p>如果运算对象是“小整型”，则它的值回被自动提升成较大的整数类型</p>
<p><strong>移位运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1001 1011</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">0233</span></span><br><span class="line"><span class="comment">// bits提升成int类型，然后向左移动8位</span></span><br><span class="line">bits &lt;&lt; <span class="number">8</span> <span class="comment">//00000000 00000000 10011011 00000000</span></span><br><span class="line"><span class="comment">// 向左移动31位，左边超出边界的位丢弃掉了</span></span><br><span class="line">bits &lt;&lt; <span class="number">31</span> <span class="comment">// 10000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="comment">// 向右移动3位，最右边的3位丢弃了</span></span><br><span class="line">bits &gt;&gt; <span class="number">3</span>  <span class="comment">// 00000000 00000000 00000000 00010011</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对一定不能位负，而且值必须严格小于结果的位数，否则就会产生未定义行为</li>
</ul>
<p><strong>位求反运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">0227</span>; <span class="comment">// 10010111</span></span><br><span class="line">~bits; <span class="comment">// 11111111 11111111 11111111 01101000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>char类型的运算对象首先提升成int类型</li>
</ul>
<h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><ul>
<li>sizeof运算符满足右结合律，其所得值是一个size_t类型的常量表达式</li>
<li>运算符的运算对象有两种形式：<blockquote>
<p>sizeof (type)<br>sizeof expr</p>
</blockquote>
</li>
</ul>
<p><strong>C++11新标准</strong></p>
<ul>
<li>C++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问的类的成员，但是sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data); <span class="comment">// 存储Sales_data类型的对象所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data; <span class="comment">// data的类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;   <span class="comment">// 指针所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;  <span class="comment">// p所指类型的空间大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue; <span class="comment">// Sales_data的revenue成员对应的类型大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data::revenue; <span class="comment">// 另一种获取revenue大小的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(ia) / sizeof(*ia) 返回ia的元素数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// 正确：sizof返回一个常量表达式</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><ul>
<li>逗号运算符含有两个运算对象，首先对左侧对表达式求值，然后将求值结果丢弃掉。逗号运算符真正对结果是右侧表达式对值。</li>
</ul>
<h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h2><ul>
<li>算数类型之间的隐式转换被设计得尽可能避免损失精度。很多时候如果表达式中既有整数类型也有浮点数类型的对象，整型会转换成浮点型。</li>
</ul>
<h3 id="4-11-1-算数转换"><a href="#4-11-1-算数转换" class="headerlink" title="4.11.1 算数转换"></a>4.11.1 算数转换</h3><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a>4.11.2 其他隐式类型转换</h3><ul>
<li>数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</li>
<li>指针的转换：<ul>
<li>常量整数值0或者字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转换成void*</li>
<li>指向任意对象的指针能转换成 const void*</li>
</ul>
</li>
<li>转换成布尔类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = get_string()</span><br><span class="line"><span class="keyword">if</span> (cp)  <span class="comment">// 如果指针cp不是0，条件为真</span></span><br><span class="line"><span class="keyword">while</span> (*cp) <span class="comment">// 如果*cp不是空字符，条件为真</span></span><br></pre></td></tr></table></figure></li>
<li>转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i; <span class="comment">//非常量转换成 const int 的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">// 非常量的地址转换成const的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = j, *q = p; <span class="comment">// 错误：不允许const转换成非常量</span></span><br></pre></td></tr></table></figure></li>
<li>类类型定义的转换</li>
</ul>
<h3 id="4-13-显式转换"><a href="#4-13-显式转换" class="headerlink" title="4.13 显式转换"></a>4.13 显式转换</h3><p><strong>命名的强制类型转换</strong></p>
<blockquote>
<p>cast-name<type> (expression);</p>
</blockquote>
<ul>
<li>cast-name:<ul>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
<li>static_cast</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> slope = i/j;</span><br><span class="line"><span class="comment">//需要使用某种方法将i和/ 或j显式的转换成double，才能执行浮点数除法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static_cast</span></span><br><span class="line"><span class="comment">// 任何具有明确定义的类型转换，只要不包含底层const，就可以使用static_cast</span></span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j) / i; <span class="comment">//进行强转以便执行浮点数除法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const_cast</span></span><br><span class="line"><span class="comment">// const_cast只能改变运算对象的底层const，对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc); <span class="comment">// 正确：但是通过p写值是为定义的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reinterpret_cast </span></span><br><span class="line"><span class="comment">// reinterpret_cast通常为运算对象的位模式提供较低层次上的重新编译</span></span><br><span class="line"><span class="keyword">int</span> *ip</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp-Primer-5th》Notes-Ch6 函数</title>
    <url>/2021/05/22/Cpp-Primer-5th-Notes-Ch6%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">        ret *= val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fact(3.14) </p>
</blockquote>
<ul>
<li>正确，double可以转换成int。执行调用时，实参隐式地转换成int类型(截取小数部分)</li>
</ul>
<h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><p>C++语言中，名字有作用域，对象有声明周期：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的声明周期是程序执行过程中该对象存在的一段时间</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++学习笔记</tag>
        <tag>读书笔记</tag>
        <tag>《C++ Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Github 教程</title>
    <url>/2021/06/15/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><h2 id="1-1-环境安装"><a href="#1-1-环境安装" class="headerlink" title="1.1 环境安装"></a>1.1 环境安装</h2><h2 id="1-2-常用shell命令"><a href="#1-2-常用shell命令" class="headerlink" title="1.2 常用shell命令"></a>1.2 常用shell命令</h2><h2 id="1-3-配置用户名和邮箱"><a href="#1-3-配置用户名和邮箱" class="headerlink" title="1.3 配置用户名和邮箱"></a>1.3 配置用户名和邮箱</h2><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul>
<li>git config –global user.name “zhuozhudd”</li>
<li>git config -global user.email <a href="mailto:songzhuozhu@outlook.com">songzhuozhu@outlook.com</a></li>
<li>git config -list</li>
<li>git config user.name</li>
<li>git help <ul>
<li>git help commit</li>
</ul>
</li>
</ul>
<h2 id="1-4-管理git项目"><a href="#1-4-管理git项目" class="headerlink" title="1.4 管理git项目"></a>1.4 管理git项目</h2><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul>
<li>git init</li>
<li>git init [dir_name] </li>
<li>git add [filename]</li>
<li>git status 查看仓库状态</li>
<li>add<ul>
<li>git add .  追踪所有没有被追踪的文件的文件</li>
<li>git add [name]。追踪此文件</li>
</ul>
</li>
</ul>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Shift + Command + . 查看隐藏文件</p>
<h2 id="1-5-放弃追踪"><a href="#1-5-放弃追踪" class="headerlink" title="1.5 放弃追踪"></a>1.5 放弃追踪</h2><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul>
<li>git rm –cached &lt;file_name&gt; 取消追踪</li>
</ul>
<h2 id="1-6-COMMIT-命令"><a href="#1-6-COMMIT-命令" class="headerlink" title="1.6 COMMIT 命令"></a>1.6 COMMIT 命令</h2><p>当前项目备份的一个版本是否能够生成, 取决于是否做了commit, 每次commit都会生成一个版本号,可以根据版本号查询历史记录</p>
<ul>
<li>git commit</li>
<li>git commit -m ‘更新说明’</li>
<li>git commit -am ‘更新说明’<ul>
<li>相当于add+commit, 只能对已经追踪的文件进行操作</li>
</ul>
</li>
</ul>
<h1 id="二、版本追踪"><a href="#二、版本追踪" class="headerlink" title="二、版本追踪"></a>二、版本追踪</h1><h2 id="2-1-log-追踪"><a href="#2-1-log-追踪" class="headerlink" title="2.1 log 追踪"></a>2.1 log 追踪</h2><ul>
<li>git log<ul>
<li>修改记录日志</li>
</ul>
</li>
<li>git log -p -2<ul>
<li>最近两次的修改记录,包括修改的内容</li>
</ul>
</li>
<li>git log –author=’name’<ul>
<li>输出所有此作者所做的提交</li>
</ul>
</li>
<li>git log –oneline<ul>
<li>只显示关键信息   哈希值 | 描述</li>
</ul>
</li>
<li>git log –graph<ul>
<li>版本线图</li>
<li>可以和online组合使用 git log –graph –oneline</li>
</ul>
</li>
<li>git log –pretty=online<ul>
<li>完整哈希值 | 描述</li>
</ul>
</li>
<li>git log –pretty=format 格式化输出<ul>
<li>git log –pretty=format:”%h - %an, %ar : %s”</li>
<li>输出 6ad963a - WallE, 3 hours ago : change index.html</li>
<li>对应 –&gt; 哈希值 - 作者 , 时间 : 描述</li>
</ul>
</li>
</ul>
<h2 id="2-2-追踪文件修改前后的区别"><a href="#2-2-追踪文件修改前后的区别" class="headerlink" title="2.2 追踪文件修改前后的区别"></a>2.2 追踪文件修改前后的区别</h2><ul>
<li>git diff [file_name]<ul>
<li>显示更新的具体内容, 红色为旧内容,绿色为修改后的内容</li>
</ul>
</li>
<li>git diff –staged<ul>
<li>只要没有commit, add后也可以用此命令查看文件修改内容</li>
</ul>
</li>
</ul>
<h2 id="2-3-文件删除、重命名、移动"><a href="#2-3-文件删除、重命名、移动" class="headerlink" title="2.3 文件删除、重命名、移动"></a>2.3 文件删除、重命名、移动</h2><ul>
<li>git rm [filename] 文件删除</li>
<li>git mv [oldname] [newname]   文件重命名<ul>
<li>重命名的本质是先复制一个份再删除一份</li>
<li>方法一: 在编辑器中重命名之后status中有 deleted:oldname , rm olname后,状态变成 : renamed : oldname -&gt; new name</li>
<li>方法二:git mv old.c new.c 后,status中便有renamed : old.c -&gt; new.c</li>
</ul>
</li>
<li>git mv [filename] stuff/pretty.txt  文件移动</li>
</ul>
<h2 id="2-4-文件忽略"><a href="#2-4-文件忽略" class="headerlink" title="2.4 文件忽略"></a>2.4 文件忽略</h2><ul>
<li><p>.gitignore</p>
<ul>
<li>将想要忽略的文件记录在此文件中</li>
<li>已经提交的无法忽略,如果想忽略已经提交的,需要先从缓存中提出来</li>
</ul>
</li>
<li><p>/node_modules 忽略node_modules文件夹下所有的文件</p>
</li>
<li><p>*.log   忽略.log结尾的文件</p>
</li>
<li><p>*.zip   忽略.zip结尾的文件</p>
</li>
<li><p>git rm -r –cached . 提出缓存中的所有文件</p>
</li>
</ul>
<h2 id="2-5-项目演练"><a href="#2-5-项目演练" class="headerlink" title="2.5 项目演练"></a>2.5 项目演练</h2><ul>
<li>git init </li>
<li>git status</li>
<li>git add .</li>
<li>git commit -m ‘discription’</li>
<li>.gitignore</li>
</ul>
<h1 id="四、复原变更"><a href="#四、复原变更" class="headerlink" title="四、复原变更"></a>四、复原变更</h1><h2 id="4-1-一键还原"><a href="#4-1-一键还原" class="headerlink" title="4.1 一键还原"></a>4.1 一键还原</h2><ul>
<li>git checkout - - [file_name]  恢复到上一次的状态</li>
</ul>
<h2 id="4-2-撤销追踪与操作与文件还原"><a href="#4-2-撤销追踪与操作与文件还原" class="headerlink" title="4.2 撤销追踪与操作与文件还原"></a>4.2 撤销追踪与操作与文件还原</h2><ul>
<li>git reset HEAD [file_name]  撤销当前文件的追踪 , 将文件撤销到add状态之前</li>
<li>git checkout - - [file_name] </li>
</ul>
<h2 id="4-3-版本回退-v1-gt-v2-gt-v3-—回退到版本2—-gt-v1-gt-v2"><a href="#4-3-版本回退-v1-gt-v2-gt-v3-—回退到版本2—-gt-v1-gt-v2" class="headerlink" title="4.3 版本回退   v1 -&gt; v2 -&gt; v3    —回退到版本2—&gt;  v1 -&gt; v2"></a>4.3 版本回退   v1 -&gt; v2 -&gt; v3    —回退到版本2—&gt;  v1 -&gt; v2</h2><ul>
<li>git reset –hard HEAD^ 回退到上一个版本<ul>
<li>–hard代表强制</li>
<li>HEAD是一个指针</li>
</ul>
</li>
<li>git reset –hard HEAD^^ 回退到上上个版本</li>
<li>git reset –hard [hash号]   回退到指定的hash版本</li>
<li>git reflog 指针指向日志</li>
</ul>
<h2 id="4-4-回到某个版本-v1-gt-v2-gt-v3-—回到版本2—-gt-v1-gt-v2-gt-v3-gt-2"><a href="#4-4-回到某个版本-v1-gt-v2-gt-v3-—回到版本2—-gt-v1-gt-v2-gt-v3-gt-2" class="headerlink" title="4.4 回到某个版本   v1 -&gt; v2 -&gt; v3   —回到版本2—&gt;   v1 -&gt; v2 -&gt; v3 -&gt;2"></a>4.4 回到某个版本   v1 -&gt; v2 -&gt; v3   —回到版本2—&gt;   v1 -&gt; v2 -&gt; v3 -&gt;2</h2><ul>
<li>git log –oneline</li>
<li>git checkout  [hash] – [file_name]  对一个文件回到某个版本</li>
<li>git checkout [hash] – .  将所有文件回到某个版本</li>
</ul>
<h1 id="五、分支合并"><a href="#五、分支合并" class="headerlink" title="五、分支合并"></a>五、分支合并</h1><h2 id="5-1-建立切换删除分支"><a href="#5-1-建立切换删除分支" class="headerlink" title="5.1  建立切换删除分支"></a>5.1  建立切换删除分支</h2><ul>
<li><p>git branch </p>
<ul>
<li>罗列所有分支名</li>
</ul>
</li>
<li><p>git branch [name]</p>
<ul>
<li>创建一个新分支</li>
</ul>
</li>
<li><p>git checkout [banch name]</p>
<ul>
<li>切换到某个分支</li>
<li>在一次处理没有commit就切换到其他分支,其他分支也会发生变化, 禁止!!</li>
</ul>
</li>
<li><p>git checkout -b [branch name]</p>
<ul>
<li>创建并切换到此分支</li>
</ul>
</li>
<li><p>git branch -d  [branch_name] </p>
<ul>
<li>删除分支</li>
</ul>
</li>
<li><p>git branch -D [branch_name] </p>
<ul>
<li>强制删除未合并到分支</li>
</ul>
</li>
</ul>
<h2 id="5-2-理解分支到底是什么"><a href="#5-2-理解分支到底是什么" class="headerlink" title="5.2 理解分支到底是什么"></a>5.2 理解分支到底是什么</h2><h4 id="分支概述"><a href="#分支概述" class="headerlink" title="分支概述"></a>分支概述</h4><ul>
<li><p>什么是分支 </p>
</li>
<li><p>分支的作用是什么</p>
</li>
<li><p>git branch [branch_name] [hash] 根据哈希值还原删除的分支</p>
</li>
</ul>
<h2 id="5-3-如何正确的合并分支"><a href="#5-3-如何正确的合并分支" class="headerlink" title="5.3 如何正确的合并分支"></a>5.3 如何正确的合并分支</h2><ul>
<li>git merge [branch name]<ul>
<li>在master 下 git merge develop, develop的新功能会添加到master,此时master和develop内容一致</li>
<li>在master 下 git merge develop, develop的删除的部分也会同步到master,此时master和develop内容一致</li>
</ul>
</li>
</ul>
<h2 id="5-4-如何解决合并时发生的冲突"><a href="#5-4-如何解决合并时发生的冲突" class="headerlink" title="5.4 如何解决合并时发生的冲突"></a>5.4 如何解决合并时发生的冲突</h2><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><ul>
<li>git merge [branch name]</li>
<li>git status 查看冲突原因</li>
<li>git merge –abort 忽略合并</li>
<li>手动选择正确内容</li>
<li>git commit</li>
</ul>
<h2 id="5-5-如何通过命令查看版本路线图"><a href="#5-5-如何通过命令查看版本路线图" class="headerlink" title="5.5 如何通过命令查看版本路线图"></a>5.5 如何通过命令查看版本路线图</h2><ul>
<li>git log</li>
<li>git log –oneline</li>
<li>git log –oneline –graph</li>
<li>git log –oneline –graph –all<ul>
<li>显示所有版本路线图</li>
</ul>
</li>
<li>git log –oneline –graph -[number] <ul>
<li>最近的几个版本路线图</li>
</ul>
</li>
</ul>
<h2 id="5-6-快转机制的意义"><a href="#5-6-快转机制的意义" class="headerlink" title="5.6 快转机制的意义"></a>5.6 快转机制的意义</h2><ul>
<li>快转机制的意义<ul>
<li>快转实际就是当前master的将来时</li>
<li>git merge branch_name –no-ff</li>
</ul>
</li>
<li>master 下 git merge develop后,两者内容一致,快转机制会忽略develop版本, –no-f会保留develop版本 </li>
</ul>
<h2 id="5-7-更多合并的方法"><a href="#5-7-更多合并的方法" class="headerlink" title="5.7 更多合并的方法"></a>5.7 更多合并的方法</h2><ul>
<li>git merge [branch_name]  –no-ff –no-commit <ul>
<li>需要git commit 才完成合并</li>
</ul>
</li>
<li>git merge –squash [branch_name]<ul>
<li>压缩分支版本号</li>
<li>需要git commit</li>
</ul>
</li>
<li>git reset –hard ORIG_HEAD<ul>
<li>恢复到初始状态</li>
</ul>
</li>
</ul>
<h2 id="5-8-一次性删除所有不想要的分支"><a href="#5-8-一次性删除所有不想要的分支" class="headerlink" title="5.8 一次性删除所有不想要的分支"></a>5.8 一次性删除所有不想要的分支</h2><ul>
<li>git branch –merged | egrep -v “(^*|master|develop)” | xargs git branch -d<ul>
<li>删除除了当前分支、master分支、develop分支之外的所有已经合并的分支</li>
</ul>
</li>
<li>git branch –no-merged | egrep -v “(^*|master)” | xargs git branch -D<ul>
<li>删除除了当前分支、master分支之外的所有未合并的分支</li>
</ul>
</li>
<li>git branch –merged<ul>
<li>查看已经合并的版本</li>
</ul>
</li>
<li>git branch –no-merged<ul>
<li>查看未合并的分支</li>
</ul>
</li>
</ul>
<h1 id="六、GitHub"><a href="#六、GitHub" class="headerlink" title="六、GitHub"></a>六、GitHub</h1><h2 id="6-1-注册Github"><a href="#6-1-注册Github" class="headerlink" title="6.1 注册Github"></a>6.1 注册Github</h2><ul>
<li>zhuozhudd</li>
</ul>
<h2 id="6-2-创建和删除远端仓库"><a href="#6-2-创建和删除远端仓库" class="headerlink" title="6.2 创建和删除远端仓库"></a>6.2 创建和删除远端仓库</h2><h2 id="6-3-本地仓库推送的远端仓库"><a href="#6-3-本地仓库推送的远端仓库" class="headerlink" title="6.3 本地仓库推送的远端仓库"></a>6.3 本地仓库推送的远端仓库</h2><h4 id="远端仓库"><a href="#远端仓库" class="headerlink" title="远端仓库"></a>远端仓库</h4><ul>
<li><p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/newrepo.git</p>
<ul>
<li>origin是<a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/newrepo.git的别名</li>
</ul>
</li>
<li><p>git remote</p>
</li>
<li><p>git push</p>
</li>
<li><p>git push -u origin master</p>
</li>
</ul>
<h4 id="创建本地仓库并推送到远端"><a href="#创建本地仓库并推送到远端" class="headerlink" title="创建本地仓库并推送到远端"></a>创建本地仓库并推送到远端</h4><ul>
<li>git init</li>
<li>git add .</li>
<li>git commit -m ‘first commit’</li>
<li>git remote add origin git@github:zhuozhudd/newrepo.git</li>
<li>git push -u origin master<ul>
<li>-u 是 –set-upstream 的简写</li>
<li>由于远端是空白,第一次上传需要上传master分支</li>
</ul>
</li>
</ul>
<h2 id="6-4-主仓库作为服务器"><a href="#6-4-主仓库作为服务器" class="headerlink" title="6.4 主仓库作为服务器"></a>6.4 主仓库作为服务器</h2><h4 id="仓库信息"><a href="#仓库信息" class="headerlink" title="仓库信息"></a>仓库信息</h4><ul>
<li>主仓库做服务器<ul>
<li>仓库名为 owner.+github.io</li>
<li>git remote</li>
<li>git remote romove origin</li>
<li>git remote</li>
<li>git remote add origin <a href="https://github.com/zhuozhudd/zhuozhudd.github.io.git" target="_blank" rel="noopener">https://github.com/zhuozhudd/zhuozhudd.github.io.git</a></li>
<li>git remote remove origin</li>
</ul>
</li>
<li>仓库配置</li>
</ul>
<ul>
<li>git remote remove origin<ul>
<li>删除origin</li>
</ul>
</li>
</ul>
<h1 id="七、多人协同开发"><a href="#七、多人协同开发" class="headerlink" title="七、多人协同开发"></a>七、多人协同开发</h1><h2 id="7-1-Push详解"><a href="#7-1-Push详解" class="headerlink" title="7.1 Push详解"></a>7.1 Push详解</h2><ul>
<li>git push -u origin 首次连接<ul>
<li>本地有一个分支master,但是远端并没有,</li>
</ul>
</li>
<li>git push<ul>
<li>连接远端后,可以直接用git push推送到远端</li>
</ul>
</li>
<li>git push –set-upstream origin [branch_name]</li>
<li>git push –all 提交所有分支<ul>
<li>*master 本地分支 (可见)</li>
<li>remotes/origin/master 远端追踪分支 (可见)</li>
<li>github master 远端分支 </li>
</ul>
</li>
</ul>
<h2 id="7-2-Pull详解"><a href="#7-2-Pull详解" class="headerlink" title="7.2 Pull详解"></a>7.2 Pull详解</h2><ul>
<li>git pull<ul>
<li>如果远端仓库被更新,本地再git push将会失败,因为本地没有远端的更新的部分,可以先用git pull将远端仓库内容拉取到本地,git pull后本地分支的所有内容将和远端一致,之后再本地做修改后,再git push即可</li>
</ul>
</li>
<li>git remote -v 返回<ul>
<li>origin    <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/newrepo.git (fetch)<ul>
<li>fetch意为从远端拉取内容,从上往下</li>
</ul>
</li>
<li>origin    <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/newrepo.git (push)<ul>
<li>push意味从本地推到远端地址,从下往上</li>
</ul>
</li>
</ul>
</li>
<li>git fetch <ul>
<li>从远端拉取,但是并没有更新本地内容</li>
<li>返回 Your branch is behind ‘origin/master’ by 1 commit, and can be fast-forwarded.  (use “git pull” to update your local branch)</li>
</ul>
</li>
<li>git merge<ul>
<li>git fetch 后,从远端拉取但没有更新本地内容,git merge将拉取的内容和本地的合并</li>
<li>git pull =  git fetch + git merge</li>
</ul>
</li>
</ul>
<h2 id="7-3-删除远端分支、仓库迁移"><a href="#7-3-删除远端分支、仓库迁移" class="headerlink" title="7.3 删除远端分支、仓库迁移"></a>7.3 删除远端分支、仓库迁移</h2><ul>
<li><p>git checkout remote_branch</p>
<ul>
<li>在本地切换到远端追踪分支</li>
</ul>
</li>
<li><p>git push origin –delete [branch_name]</p>
<ul>
<li>在本地删除远端分支 </li>
</ul>
</li>
<li><p>git remote set-url origin [远端仓库的地址]</p>
<ul>
<li>git push –all 即可迁移到远端仓库</li>
</ul>
</li>
</ul>
<h2 id="7-4-情景演练"><a href="#7-4-情景演练" class="headerlink" title="7.4 情景演练"></a>7.4 情景演练</h2><ul>
<li><ol>
<li><p>developer A 将项目传到远端仓库</p>
</li>
<li><p>developer B 从远端仓库拉取项目,更新项目后提交</p>
</li>
<li><p>developer A 再拉取项目,再更新,之后提交</p>
</li>
</ol>
</li>
</ul>
<h3 id="1-developA"><a href="#1-developA" class="headerlink" title="1.developA"></a>1.developA</h3><ul>
<li>git init </li>
<li>git status</li>
<li>git add </li>
<li>git commit -m</li>
<li>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/demo.git<ul>
<li>git remote remove origin ,删除原有连接</li>
</ul>
</li>
<li>git push -u origin master</li>
</ul>
<h3 id="2-developB"><a href="#2-developB" class="headerlink" title="2.developB"></a>2.developB</h3><ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/demo.git 或者<ul>
<li>git clone –bare <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/demo.git</li>
<li>git clone –no-checkout /Users/mac/Desktop/Git/git_pjt/demo.git shopping_cart2</li>
<li>rm -rf demo.git</li>
</ul>
</li>
<li>git checkout master 后本地就出出现对应的文件</li>
<li>git checkout -b developB</li>
<li>code . 编写代码</li>
<li>git commit -am ‘develop B change’</li>
<li>git checkout master 编写代码无误后,切换到master将其分支合并<ul>
<li>git merge –no-ff developB</li>
</ul>
</li>
<li>git remote set-url origin <a href="mailto:git@github.com">git@github.com</a>:zhuozhudd/demo.git<ul>
<li>由于是克隆的本地仓库,所以这重新连接远端</li>
</ul>
</li>
<li>git push –all 全部提交</li>
</ul>
<h3 id="3-developA"><a href="#3-developA" class="headerlink" title="3.developA"></a>3.developA</h3><ul>
<li>git pull 从远端拉取</li>
<li>git checkout -b developA</li>
<li>code . 编写代码无误后</li>
<li>git commit -am ‘developA change’</li>
<li>git checkout master</li>
<li>git merge developA</li>
<li>git push<ul>
<li>git push只会更新远端的master分支</li>
<li>git push –all 会在远端添加developA分支 或者<ul>
<li>git checkout developA</li>
<li>git push origin developA 也可以在远端添加developA分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="八、服务器自动部署"><a href="#八、服务器自动部署" class="headerlink" title="八、服务器自动部署"></a>八、服务器自动部署</h1><h2 id="8-1-使用SSH连接GitHub"><a href="#8-1-使用SSH连接GitHub" class="headerlink" title="8.1 使用SSH连接GitHub"></a>8.1 使用SSH连接GitHub</h2><ul>
<li>SSH是一种安全协议</li>
<li>连接客户端和服务器</li>
<li>ssh <a href="mailto:git@github.com">git@github.com</a></li>
<li>公钥 / 私钥<ul>
<li>cd ~</li>
<li>ssh-keygen<ul>
<li>返回 Generating public/private rsa key pair. Enter file in which to save the key (/Users/mac/.ssh/id_rsa):</li>
</ul>
</li>
</ul>
</li>
<li>ssh-keygen</li>
<li>~/.ssh/id_rsa ( Private Key 私钥)</li>
<li>~/.ssh/id_rsa.pub( Public Key 公钥)<ul>
<li>cat id_rsa.pub 打开公钥</li>
</ul>
</li>
<li>登录github,将公钥存入服务器中的SSH Keys 中</li>
</ul>
<h2 id="8-2-自动部署流程"><a href="#8-2-自动部署流程" class="headerlink" title="8.2 自动部署流程"></a>8.2 自动部署流程</h2><ul>
<li>将项目推送到GitHub仓库, Github连接阿里云服务器完成自动部署</li>
<li>阿里云服务器</li>
</ul>
<h2 id="8-3-使用SSH连接阿里云服务器"><a href="#8-3-使用SSH连接阿里云服务器" class="headerlink" title="8.3 使用SSH连接阿里云服务器"></a>8.3 使用SSH连接阿里云服务器</h2><h2 id="8-4-手动部署"><a href="#8-4-手动部署" class="headerlink" title="8.4 手动部署"></a>8.4 手动部署</h2><h2 id="8-5-自动部署"><a href="#8-5-自动部署" class="headerlink" title="8.5 自动部署"></a>8.5 自动部署</h2><h1 id="九、GitLab详解"><a href="#九、GitLab详解" class="headerlink" title="九、GitLab详解"></a>九、GitLab详解</h1><h2 id="9-1-GitLab"><a href="#9-1-GitLab" class="headerlink" title="9.1 GitLab"></a>9.1 GitLab</h2><h2 id="9-2-项目提交"><a href="#9-2-项目提交" class="headerlink" title="9.2 项目提交"></a>9.2 项目提交</h2><h2 id="9-3-项目操作-Fork"><a href="#9-3-项目操作-Fork" class="headerlink" title="9.3 项目操作 - Fork"></a>9.3 项目操作 - Fork</h2><h2 id="9-4-创建SSH-Key"><a href="#9-4-创建SSH-Key" class="headerlink" title="9.4 创建SSH Key"></a>9.4 创建SSH Key</h2><h2 id="9-5-GitLab-CICD简介"><a href="#9-5-GitLab-CICD简介" class="headerlink" title="9.5 GitLab CICD简介"></a>9.5 GitLab CICD简介</h2><h2 id="9-6-GitLab-Runner"><a href="#9-6-GitLab-Runner" class="headerlink" title="9.6 GitLab Runner"></a>9.6 GitLab Runner</h2><h2 id="9-7-实现GitLab-CICD"><a href="#9-7-实现GitLab-CICD" class="headerlink" title="9.7 实现GitLab CICD"></a>9.7 实现GitLab CICD</h2>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>教程</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter安装扩展和主题美化</title>
    <url>/2021/05/27/Jupyter%E6%8F%92%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-安装扩展"><a href="#1-安装扩展" class="headerlink" title="1 - 安装扩展"></a>1 - 安装扩展</h2><ul>
<li>安装nbextensions<ul>
<li><code>pip install jupyter_contrib_nbextensions</code></li>
<li><code>jupyter contrib nbextension install --user</code></li>
</ul>
</li>
<li>安装nbextensions_configurator<ul>
<li><code>pip install jupyter_nbextensions_configurator</code></li>
<li><code>jupyter nbextensions_configurator enable --user</code></li>
</ul>
</li>
<li>问题 1<ul>
<li>关于<code>ImportError: cannot import name &#39;secure_write&#39;</code>问题</li>
<li>输入：<code>pip install --upgrade jupyter_client</code></li>
</ul>
</li>
</ul>
<h2 id="2-主题美化"><a href="#2-主题美化" class="headerlink" title="2 - 主题美化"></a>2 - 主题美化</h2><ul>
<li><p>安装主题</p>
<p><code>pip install jupyterthemes -i http://mirrors.aliyun.com/pypi/simple/  --trusted-host mirrors.aliyun.com</code></p>
<p><code>pip install terminado --ignore-installed</code></p>
</li>
<li><p>查看主题列表</p>
<p><code>jt -l</code></p>
</li>
<li><p>设置主题,字体,字体大小等</p>
<p><code>jt --lineh 140  -tf ptmono -t onedork -ofs 13 -nfs 14 -tfs 14 -fs 16 -T -N -dfs 10 -cellw 90%</code></p>
<ul>
<li>-f(字体)  -fs(字体大小) -cellw(占屏比或宽度)  -ofs(输出段的字号)  -T(显示工具栏)  -N(显示自己主机名)</li>
</ul>
</li>
</ul>
<h2 id="3-代码补全"><a href="#3-代码补全" class="headerlink" title="3 - 代码补全"></a>3 - 代码补全</h2><ul>
<li>选中Hinterland即可</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210603095509104.png" alt="image-20210603095509104"></p>
<ul>
<li>其他功能也可以自行选取，如markdown，latex支持，代码格式化等。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习环境配置</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 二叉搜索树</title>
    <url>/2021/07/24/LeetCode%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="0-题目总览"><a href="#0-题目总览" class="headerlink" title="0 - 题目总览"></a>0 - 题目总览</h2><ul>
<li><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a>       <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">783. 二叉搜索树节点最小距离</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a>         <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">1038. 把二叉搜索树转换为累加树</a></p>
</li>
</ul>
<h2 id="1-二叉搜索树中的搜索"><a href="#1-二叉搜索树中的搜索" class="headerlink" title="1 - 二叉搜索树中的搜索"></a>1 - 二叉搜索树中的搜索</h2><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></p>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<h3 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h3><p>也可将<code>if else</code> 写成 三元运算符的形式，更简洁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) </span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2 - 验证二叉搜索树"></a>2 - 验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>二叉搜索树的中序遍历是有序的，可以根据此判断</p>
<h3 id="递归法：-1"><a href="#递归法：-1" class="headerlink" title="递归法："></a>递归法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        inOrder(root, v);</span><br><span class="line">        <span class="keyword">if</span> (v.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (v[i - <span class="number">1</span>] &gt;= v[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) inOrder(root-&gt;left, v);</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) inOrder(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    <code>helper函数</code> 表示考虑以 <code>root</code>为根的子树，判断子树中所有节点的值是否都在<code>(l,r)</code> 的范围内（注意是开区间）。如果<code>root</code>节点的值不在<code>(l,r)</code>的范围内说明不满足条件直接返回，否则继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> lower, <span class="keyword">long</span> upper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, lower, root-&gt;val) &amp;&amp; helper(root-&gt;right, root-&gt;val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法：-1"><a href="#迭代法：-1" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">long</span> temp = LONG_MIN;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; cur-&gt;val)</span><br><span class="line">                    temp = cur-&gt;val;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉搜索树的最小绝对差"><a href="#3-二叉搜索树的最小绝对差" class="headerlink" title="3 - 二叉搜索树的最小绝对差"></a>3 - 二叉搜索树的最小绝对差</h2><p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">783. 二叉搜索树节点最小距离</a></p>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。树中至少有2个节点</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>使用中序遍历。</p>
<p>此题关键是要学会一个技巧，即<strong>遍历时候如何保存上一个节点 pre</strong></p>
<h3 id="递归法：-2"><a href="#递归法：-2" class="headerlink" title="递归法："></a>递归法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        inOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">if</span> (pre)</span><br><span class="line">            res = min(res, root-&gt;val - pre-&gt;val);</span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法：-2"><a href="#迭代法：-2" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || cur )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (pre)</span><br><span class="line">                    res = min(res, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-二叉搜索树中的众数"><a href="#4-二叉搜索树中的众数" class="headerlink" title="4 - 二叉搜索树中的众数"></a>4 - 二叉搜索树中的众数</h2><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></p>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>众数可能不止一个，所有返回的是一个数组，此题重点是如何只遍历一遍就可得出结果，用到了上一题的思想，记录上一个访问的节点。由于中序遍历二叉搜索树的序列是有序的，所以对连续相同的数字计数， 保存最大次数值，更新时要将 res 数组置空再放入</p>
<h3 id="递归法：-3"><a href="#递归法：-3" class="headerlink" title="递归法："></a>递归法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> maxCount;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        res.clear();</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pre)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;val == root-&gt;val)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount)</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法：-3"><a href="#迭代法：-3" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.empty() || cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pre)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val)</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 第一个节点</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == maxCount)</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                maxCount = count;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-二叉搜索树转累加树"><a href="#5-二叉搜索树转累加树" class="headerlink" title="5 - 二叉搜索树转累加树"></a>5 - 二叉搜索树转累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></p>
<p><a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">1038. 把二叉搜索树转换为累加树</a></p>
<p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code>的值之和。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>这里要对中序遍历进行变通，采用逆序的中序遍历，即 右 根 左，这样即可从序列右边向左处理，依次累加</p>
<h3 id="递归法：-4"><a href="#递归法：-4" class="headerlink" title="递归法："></a>递归法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        reverseInOrder(cur, pre);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseInOrder</span><span class="params">(TreeNode*&amp; cur, TreeNode*&amp; pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        reverseInOrder(cur-&gt;right, pre);</span><br><span class="line">        <span class="keyword">if</span> (pre)</span><br><span class="line">            cur-&gt;val += pre-&gt;val;</span><br><span class="line">        pre = cur;</span><br><span class="line">        reverseInOrder(cur-&gt;left, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> parentVal;</span><br><span class="line">        root-&gt;val += dfs(root-&gt;right, parentVal);</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法：-4"><a href="#迭代法：-4" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur || !st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (pre)</span><br><span class="line">                    cur-&gt;val += pre-&gt;val;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode专题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 二叉树的属性</title>
    <url>/2021/07/22/LeetCode%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h1><h2 id="0-题目总览"><a href="#0-题目总览" class="headerlink" title="0 - 题目总览"></a>0 - 题目总览</h2><p><strong>对称和异同：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a>  <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></li>
<li><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一棵树的子树</a></li>
</ul>
<p><strong>深度：</strong></p>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a>    <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a>     <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></p>
</li>
</ul>
<p><strong>节点：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></li>
<li><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></li>
<li><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></li>
</ul>
<p><strong>路径：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></li>
<li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></li>
<li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></li>
</ul>
<h2 id="1-对称和异同"><a href="#1-对称和异同" class="headerlink" title="1 - 对称和异同"></a>1 - 对称和异同</h2><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Symmetric</span><span class="params">(TreeNode* L, TreeNode* R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!L &amp;&amp; !R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!L || !R || L-&gt;val != R-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(L-&gt;left, R-&gt;right) &amp;&amp; Symmetric(L-&gt;right, R-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用辅助栈BFS"><a href="#使用辅助栈BFS" class="headerlink" title="使用辅助栈BFS"></a>使用辅助栈BFS</h4><p>入栈两对（<code>左子树的左孩子和右子树的右孩子是一对</code>，<code>左子树的右孩子和右子树的左孩子是一对</code>），出栈的时候出栈一对，判别是否符合条件，全部遍历完，队列为空，则全部符合，返回<code>true</code>。 </p>
<p>也可以使用辅助队列完成此题，逻辑与用辅助栈同理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root-&gt;left);</span><br><span class="line">        s.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curR = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            TreeNode* curL = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((!curL &amp;&amp; curR) || curL &amp;&amp; !curR)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (curL &amp;&amp; curR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curL-&gt;val != curR-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 左子树的左孩子，右子树的右孩子</span></span><br><span class="line">                s.push(curL-&gt;left);</span><br><span class="line">                s.push(curR-&gt;right);</span><br><span class="line">                <span class="comment">// 左子树的右孩子，右子树的左孩子</span></span><br><span class="line">                s.push(curL-&gt;right);</span><br><span class="line">                s.push(curR-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; q || p &amp;&amp; !q || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(q);</span><br><span class="line">        que.push(p);</span><br><span class="line">        <span class="keyword">while</span> (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* L = que.front(); que.pop();</span><br><span class="line">            TreeNode* R = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (!L &amp;&amp; !R) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!L || !R || L-&gt;val != R-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">            que.push(L-&gt;right);</span><br><span class="line">            que.push(R-&gt;right);</span><br><span class="line">            que.push(L-&gt;left);</span><br><span class="line">            que.push(R-&gt;left);             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="另一颗树的子树"><a href="#另一颗树的子树" class="headerlink" title="另一颗树的子树"></a>另一颗树的子树</h3><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一棵树的子树</a></p>
<h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><p>运用了LeetCode100的判同方法，递归调用，如果两颗树相同，是子树，或者是root的左子树包含subRoot 或者是root的右子树包含subRoot</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; q || p &amp;&amp; !q || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root &amp;&amp; !subRoot) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root &amp;&amp; subRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-深度"><a href="#2-深度" class="headerlink" title="2 - 深度"></a>2 - 深度</h2><h3 id="2-1-二叉树的最大深度"><a href="#2-1-二叉树的最大深度" class="headerlink" title="2-1 二叉树的最大深度"></a>2-1 二叉树的最大深度</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></p>
<h4 id="递归，后续遍历"><a href="#递归，后续遍历" class="headerlink" title="递归，后续遍历"></a>递归，后续遍历</h4><p><strong>树的深度</strong>  等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong>  <code>+1</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h4><p>一次<code>for</code>循环遍历完一层，深度 <code>+1</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-二叉树的最小深度"><a href="#2-2-二叉树的最小深度" class="headerlink" title="2-2 二叉树的最小深度"></a>2-2 二叉树的最小深度</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></p>
<p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<h4 id="递归，后续遍历-1"><a href="#递归，后续遍历-1" class="headerlink" title="递归，后续遍历"></a>递归，后续遍历</h4><p>确定递归的逻辑：</p>
<ul>
<li>当左子树为空，右子树不为空时，最小深度是右子树的最小深度 + 1</li>
<li>当左子树不为空，右子树为空时，最小深度是左子树的最小深度 + 1</li>
<li>当左右子树均不为空时，最小深度为两个子树最小深度的最小值 + 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历-BFS"><a href="#层序遍历-BFS" class="headerlink" title="层序遍历 BFS"></a>层序遍历 BFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">int</span> min_depth = <span class="number">0</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            min_depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();               </span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">return</span> min_depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-节点"><a href="#3-节点" class="headerlink" title="3 - 节点"></a>3 - 节点</h2><h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></p>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含<code>1~ 2^h</code>个节点。</p>
<p><strong>利用完全二叉树的性质：</strong></p>
<p>当 $0 \le i &lt; h$ 时，第 $i$ 层包含 $2^i$ 个节点，最底层的节点最少为 $1$，最多为 $2^h$ .</p>
<p>当最底层包含一个节点时，完全二叉树的节点个数是：</p>
<p>$$\sum_{i=0}^{h-1}2^i+1=2^h$$</p>
<p>当最底层包含$2^h$个节点时，完全二叉树的节点个数是：</p>
<p>$\sum_{i=0}^{h}2^i = 2^{h+1} - 1$</p>
<h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><p><strong>时间 - $O(\log^2{n})$  空间 - $O(\log{n})$</strong></p>
<p>完全二叉树（记根节点深度为1）只有两种情况：</p>
<ul>
<li>情况一：可以直接用 $2^h-1$ 来计算。</li>
<li>情况二：分别递归左右子树，递归到某一深处一定会有左孩子或右孩子为满二叉树，然后看情况1计算。</li>
</ul>
<p>如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210720164822336.png" alt="image-20210720164822336"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *L = root-&gt;left;</span><br><span class="line">        TreeNode *R = root-&gt;right;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="number">0</span>, rightHeight = <span class="number">0</span>; <span class="comment">// 这里初始化为0便于后续指数运算</span></span><br><span class="line">        <span class="keyword">while</span> (L)</span><br><span class="line">        &#123;</span><br><span class="line">            L = L-&gt;left;</span><br><span class="line">            leftHeight++; <span class="comment">// 求左子树深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (R)</span><br><span class="line">        &#123;</span><br><span class="line">            R = R-&gt;right;</span><br><span class="line">            rightHeight++; <span class="comment">// 求右子树深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == rightHeight)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftHeight) - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="非递归：二分查找-位运算"><a href="#非递归：二分查找-位运算" class="headerlink" title="非递归：二分查找 + 位运算"></a>非递归：二分查找 + 位运算</h4><p><strong>时间 - $O(\log^2{n})$  空间 - $O(1)$</strong></p>
<p>根据完全二叉树的性质，最大层树为 $h$ 的完全二叉树，节点个数一定在 $[2^h,2^{h+1}-1]$ 范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。</p>
<p>根据节点个数范围的上下届得到当前判断的节点个数 $k$ ，如果第 $k$ 个节点存在，则节点个数一定 <code>大于或者等于 k</code>，如果第 $k$ 个节点不存在，则节点个数一定 <code>小于 k</code>由此可以将查找的范围缩小一般，直到得到节点个数。</p>
<p>判断第 $k$ 个节点存在的方法：如果第 $k$ 个节点位于第 $h$层，则 $k$ 的二进制表示包含 $h+1$ 位，其中最高位是1，其余各位从高到低表示从根节点到第 $k$ 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。通过位运算得到第 $k$ 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 $k$ 个节点是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            level++;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span> &lt;&lt; level, high = (<span class="number">1</span> &lt;&lt; (level + <span class="number">1</span>)) - <span class="number">1</span>; <span class="comment">// 搜索的左右区间</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是奇数, 取最中间角标, 如果偶数, 取中间靠右那个角标. 这里取靠右角标是因为下面left = mid</span></span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low; <span class="comment">// 向上取整</span></span><br><span class="line">            <span class="keyword">if</span> (exists(root, level, mid))</span><br><span class="line">                low = mid;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 对于k来说，最高位是1，其余个位从高到低表示从根节点到第k个节点的路径，0向左1向右</span></span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>); <span class="comment">// level层，路径最长为level - 1</span></span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; bits &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bits &amp; k) </span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></p>
<h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_leaf_value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            left_leaf_value = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> left_leaf_value + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">                res += node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="找左下角节点的值"><a href="#找左下角节点的值" class="headerlink" title="找左下角节点的值"></a>找左下角节点的值</h3><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></p>
<h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        traversal(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curDepth, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDepth &gt; maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDepth = curDepth;</span><br><span class="line">                value = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) traversal(root-&gt;left, curDepth + <span class="number">1</span>, value);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) traversal(root-&gt;right, curDepth + <span class="number">1</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><p>层序遍历，<code>i == 0</code>时是这一层的第一个节点（即最左边的节点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-平衡二叉树-AVL"><a href="#4-平衡二叉树-AVL" class="headerlink" title="4 - 平衡二叉树 AVL"></a>4 - 平衡二叉树 AVL</h2><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
<h4 id="后序遍历-剪枝-自底向上-O-N-O-N"><a href="#后序遍历-剪枝-自底向上-O-N-O-N" class="headerlink" title="后序遍历 + 剪枝  自底向上  $O(N) - O(N)$"></a>后序遍历 + 剪枝  自底向上  $O(N) - O(N)$</h4><p><strong>如果用后序遍历的方式遍历二叉树的每个节点，那么再遍历到一个节点之前就已经遍历了它的左、右子树，就可以计算深度了</strong></p>
<p>后序遍历<strong>自底向上</strong>返回子树深度，若不是平衡树则剪枝，直接向上返回。</p>
<p>当某节点左、右子树的高度差小于 <code>2</code>，则返回当前子树的深度 <code>max(left, right) + 1</code>，否则返回 <code>-1</code>，即此子树不是平衡树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = recur(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = recur(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="先序遍历-判断深度-（自顶向下）-O-N-log-N-O-N"><a href="#先序遍历-判断深度-（自顶向下）-O-N-log-N-O-N" class="headerlink" title="先序遍历 + 判断深度 （自顶向下）  $O(N\log{N}) - O(N)$"></a>先序遍历 + 判断深度 （自顶向下）  $O(N\log{N}) - O(N)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-路径"><a href="#5-路径" class="headerlink" title="5 - 路径"></a>5 - 路径</h2><h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></p>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。<strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h4 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h4><p><strong>如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某⼀条固定路线，递归函数就⼀定要有返回值！</strong></p>
<p><strong>思路：</strong></p>
<p><strong>Step1：确定递归函数参数以及返回值</strong></p>
<p>传入根节点，记录每一条路径的path，和存放结果集的result：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Step2：确定递归终止条件</strong></p>
<p>终止条件是找到了一个叶子节点，然后开始后续的逻辑处理。显然，终止条件是节点本身不为空，但左右孩子为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur &amp;&amp; cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="comment">//..逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Step3：确定单层递归逻辑</strong></p>
<p>前序遍历，先处理中间节点，放入path中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">path.push_back(cur-&gt;val);</span><br></pre></td></tr></table></figure>

<p>然后是递归和回溯，递归完，要做回溯，因为path 不能⼀直加⼊节点，它还要删节点，然后才能加⼊新的节点。</p>
<p><strong>回溯和递归是⼀⼀对应的，有⼀个递归，就要有⼀个回溯</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">	preOrder(cur-&gt;left, path, result); <span class="comment">// 递归</span></span><br><span class="line">	path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	preOrder(cur-&gt;right, path, result); <span class="comment">// 递归</span></span><br><span class="line">	path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>)  <span class="comment">// 访问到叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s : path)</span><br><span class="line">            &#123;</span><br><span class="line">                sPath.append(to_string(s));</span><br><span class="line">                sPath.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sPath.pop_back();</span><br><span class="line">            sPath.pop_back();</span><br><span class="line">            result.push_back(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(cur-&gt;left, path, result);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(cur-&gt;right, path, result);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        preOrder(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代（非递归）"><a href="#迭代（非递归）" class="headerlink" title="迭代（非递归）"></a>迭代（非递归）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; tree_st; <span class="comment">// 保存树的遍历节点</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; path_st; <span class="comment">// 保存遍历路径的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;    <span class="comment">// 保存最终路径集合</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        tree_st.push(root);</span><br><span class="line">        path_st.push(to_string(root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> (!tree_st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = tree_st.top(); <span class="comment">// 取出节点（中序）</span></span><br><span class="line">            tree_st.pop();</span><br><span class="line">            <span class="built_in">string</span> path = path_st.top();    <span class="comment">// 取出该节点对应的路径</span></span><br><span class="line">            path_st.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) <span class="comment">// 遇到叶子节点，得到一条路径</span></span><br><span class="line">                result.push_back(path);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">            &#123;</span><br><span class="line">                tree_st.push(node-&gt;right);</span><br><span class="line">                path_st.push(path + <span class="string">"-&gt;"</span> + to_string(node-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                tree_st.push(node-&gt;left);</span><br><span class="line">                path_st.push(path + <span class="string">"-&gt;"</span> + to_string(node-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></p>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>判断路径和<code>curSum</code>是否等于<code>targetSum</code>，正常来说需要两个变量，但是可以通过递减的方法简化为一个，设计数器<code>count</code>初始为目标和，每次减去遍历路径节点上的数值，如果最后<code>count == 0</code>，且同时到了叶子节点，说明找到了目标和</p>
<h4 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归 +回溯"></a>递归 +回溯</h4><p><strong>完整写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> traversal(root, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            count -= root-&gt;left-&gt;val; <span class="comment">// 递归,处理节点</span></span><br><span class="line">            <span class="keyword">if</span> (traversal(root-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += root-&gt;left-&gt;val; <span class="comment">// 回溯,撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            count -= root-&gt;right-&gt;val; <span class="comment">// 递归,处理节点</span></span><br><span class="line">            <span class="keyword">if</span> (traversal(root-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += root-&gt;right-&gt;val; <span class="comment">// 回溯,撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>简洁写法：</strong></p>
<p>回溯隐藏在<code>hasPathSum(root-&gt;left, targetSum - root-&gt;val)</code>这⾥， 因为把<code>targetSum - root-&gt;val</code> 直</p>
<p>接作为参数传进去，函数结束，<code>targetSum</code>的数值没有改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> targetSum - root-&gt;val == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><p><strong>栈⾥⼀个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p>
<p><code>C++</code>可以⽤ <code>pair</code> 结构来存放这个栈⾥的元素。定义为：<code>pair&lt;TreeNode*, int&gt; pair&lt;节点指针，路径数值&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 栈中存放 pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        st.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(root, root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> (!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="keyword">int</span>&gt; node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="comment">// 如果该节点是叶⼦节点了，同时该节点的路径数值等于sum，那么就返回true</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node.first-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == node.second)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 右节点，压进去⼀个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;right)</span><br><span class="line">                st.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左节点，压进去⼀个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;left)</span><br><span class="line">                st.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="所有路径总和"><a href="#所有路径总和" class="headerlink" title="所有路径总和"></a>所有路径总和</h3><p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p>
<h4 id="迭代-回溯"><a href="#迭代-回溯" class="headerlink" title="迭代 + 回溯"></a>迭代 + 回溯</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遇到了叶⼦节点切找到了和为sum的路径</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cnt == <span class="number">0</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到叶⼦节点⽽没有找到合适的边，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(cur-&gt;left-&gt;val);</span><br><span class="line">            traversal(cur-&gt;left, cnt - cur-&gt;left-&gt;val); <span class="comment">// 递归 + 回溯</span></span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(cur-&gt;right-&gt;val);</span><br><span class="line">            traversal(cur-&gt;right, cnt - cur-&gt;right-&gt;val);  <span class="comment">// 递归 + 回溯</span></span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        res.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        traversal(root, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode专题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>PyBullet Quickstart Guide 官方文档翻译 1 - Introduction | 2 - Controlling a Robot |</title>
    <url>/2021/05/31/PyBullet1/</url>
    <content><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 - Introduction"></a>1 - Introduction</h1><h2 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h2><ul>
<li>p.connect()  <ul>
<li>与physics server 连接，有DIRECT和GUI两个模式，DIRECT模式创建一个新的物理引擎，并直接与它通信。GUI将创造一个带有图形化GUI前端的物理引擎并与之进行通信</li>
</ul>
</li>
<li>p.disconnect()<ul>
<li>与physics server 断开连接</li>
</ul>
</li>
<li>p.getConnectionInfo()<ul>
<li>参数为physicsClientId，返回一个列表[isConnected,connectionMethod]</li>
</ul>
</li>
<li>p.isConnected()<ul>
<li>如果connected返回True，否则为False，参数是physicsClientId</li>
</ul>
</li>
<li>p.setGravity()<ul>
<li>设置重力，p.setGravity(0,0,-9.8)</li>
</ul>
</li>
<li>p.loadURDF(FileName), p.loadSDF(), p.loadMJCF()<ul>
<li>载入urdf模型</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-2-保存和恢复"><a href="#1-2-保存和恢复" class="headerlink" title="1.2 保存和恢复"></a>1.2 保存和恢复</h2><ul>
<li>p.saveState(), p.saveBullet(), p.restoreState(fileName)  <strong>1.2_saveRestoreState.py</strong><ul>
<li>saveState（内存），saveBullet（磁盘），用restoreState恢复存储的快照</li>
</ul>
</li>
<li>p.removeState()<ul>
<li>从内存中删除以前存储的状态,即saveState()存储的状态</li>
</ul>
</li>
<li>p.saveWorld(fileName)<ul>
<li>使用PyBullet Python file存储一个世界快照</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-3-创建一些物体-snake-py"><a href="#1-3-创建一些物体-snake-py" class="headerlink" title="1.3 创建一些物体 snake.py"></a>1.3 创建一些物体 <strong>snake.py</strong></h2><ul>
<li>p.createCollisionShape(shapeType)<ul>
<li>创建物体，可选参数很多</li>
</ul>
</li>
<li>p.createCollisionShapeArray(),是createCollisionShape的数组版本，使用方法在  <strong>createVisualShapeArray.py</strong></li>
<li>p.removeCollisionShape()</li>
</ul>
<br>

<ul>
<li>p.createVisualShape(shapeType) <strong>addPlanarReflection.py</strong> <strong>createVisualShape.py</strong>  <strong>createVisualShapeArray.py</strong> <strong>createTexturedMeshVisualShape.py</strong></li>
<li>p.createVisualShapeArray()</li>
<li>p.createMultiBody()  <strong>createMultiBodyLinks.py</strong></li>
<li>p.getMeshData(bodyUniqueID)<ul>
<li>返回三角形网格的网格信息(顶点，索引)。</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-4-仿真执行"><a href="#1-4-仿真执行" class="headerlink" title="1.4 仿真执行"></a>1.4 仿真执行</h2><ul>
<li>stepSimulation()<ul>
<li>step simulation将在一个单一的正向动力学仿真步骤中执行所有的动作，如碰撞检测、约束求解和集成。默认的timestep是1/240秒，可以通过setTimeStep或setPhysicsEngineParameter API修改, 没有返回值</li>
</ul>
</li>
<li>setRealTimeSimulation(enableRealTimeSimulation)<ul>
<li>默认情况下，物理服务器不会步进模拟，除非你显式地发送“stepSimulation”命令。这样就可以保持模拟的控制确定性。通过使用setRealTimeSimulation命令，让物理服务器根据它的实时时钟(RTC)自动步进仿真，实时运行仿真是可能的。如果启用了实时模拟，则不需要调用“步进模拟”。</li>
</ul>
</li>
</ul>
<h2 id="1-5-位置与方位"><a href="#1-5-位置与方位" class="headerlink" title="1.5 位置与方位"></a>1.5 位置与方位</h2><ul>
<li>getBasePositionAndOrientation(objectUniqueID)<ul>
<li>笛卡尔坐标系, the base (or root link) of the body的当前位置和方向。方位是[x,y,z,w]格式的四元数。</li>
<li>返回三个浮点数的位置list和四个浮点数的方位list（顺序是[x,y,z,w]）使用 getEulerFromQuaternion可以将四元数转换为欧拉角</li>
</ul>
</li>
<li>resetBasePositionAndOrientation(bodyUniqueId, posObj, ornObj)<ul>
<li>可以重置每个对象的底部（根）的位置和方向。最好只在开始时执行此操作，而不是在运行模拟期间，因为该命令将覆盖所有物理模拟的效果。将线速度和角速度设置为零。可以使用resetBaseVelocity重置为非零的线性和/或角速度。</li>
</ul>
</li>
<li>getQuaternionFromEuler([x,y,z,w]) &amp; getEulerFromQuaternion([yaw,pitch,roll])<ul>
<li>四元组和欧拉角相互转换</li>
</ul>
</li>
<li>getMatrixFromQuaternion([x,y,z,w]) &amp; getAxisAngleFromQuaternion([x,y,z,w])</li>
</ul>
<p><br><br></p>
<ul>
<li>multiplyTransforms, invertTransform<ul>
<li>PyBullet提供了一些辅助函数来进行乘法和反变换。这对于将坐标从一个坐标系转换到另一个坐标系是很有帮助的</li>
</ul>
</li>
<li>getDifferenceQuaternion(quaternionStart,quaternionEnd)<ul>
<li>返回一个[x,y,z,w]，start和end之间</li>
</ul>
</li>
</ul>
<h1 id="2-Controlling-a-Robot"><a href="#2-Controlling-a-Robot" class="headerlink" title="2 - Controlling a Robot"></a>2 - Controlling a Robot</h1><h2 id="2-1-Base，Joints，Links"><a href="#2-1-Base，Joints，Links" class="headerlink" title="2.1 Base，Joints，Links"></a>2.1 Base，Joints，Links</h2><p><img src="img/base_link.png" alt="base_link"></p>
<p>常规link在[0.. getnumnodes()]范围内有link索引，因为base不是常规的“link”，所以使用-1作为base的link索引。采用的惯例是，joint frames相对于the parents center of mass <strong>inertial frame</strong>（惯性坐标系）表示，which is aligned with（对其） the principle axis of inertia</p>
<ul>
<li>getNumJoints(bodyUniqueId)<ul>
<li>返回一个表示关节数的整数</li>
</ul>
</li>
<li>getJointInfo(bodyUniqueId, jointIndex)<ul>
<li>返回一个信息的 list，</li>
</ul>
</li>
</ul>
<h2 id="2-2-控制关节运动模式"><a href="#2-2-控制关节运动模式" class="headerlink" title="2.2 控制关节运动模式"></a>2.2 控制关节运动模式</h2><ul>
<li>setJointMotorControl2() setJointMotorControlArray()<ul>
<li>可以通过设置一个或多个关节马达的控制模式来控制机器人。在stepSimulation过程中，物理引擎将模拟电机以达到给定的目标值，该目标值可以在最大电机力和其他约束条件下达到。</li>
<li>默认情况下，每个转动关节（revolute joint）和移动关节（prismatic joint）都使用一个速度电机来驱动。可以使用最大力0来禁用这些默认电机。这将使你执行扭矩控制。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maxForce = <span class="number">0</span> <span class="comment"># 也可以使用一个小的非零力来模拟关节摩擦</span></span><br><span class="line">mode = p.VELCITY_CONTROL</span><br><span class="line">p.setJointMotorControl2(objUid, jointIndex, controlMode = model, force = maxForce)</span><br><span class="line"><span class="comment"># 如果想让轮子以最大力来保持恒定的速度，可以使用：</span></span><br><span class="line">maxForce = <span class="number">500</span></span><br><span class="line">p.setJointMotorControl2(bodyUniqueId = objUid, </span><br><span class="line">                        jointIndex = <span class="number">0</span>, </span><br><span class="line">                        controlMode = p.VELOCITY_CONTROL, </span><br><span class="line">                        targetVelocity = targetVel, </span><br><span class="line">                        force = maxForce)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>从loadURDF()等返回的唯一Id</td>
</tr>
<tr>
<td>R</td>
<td>jointIndex</td>
<td>int</td>
<td>link索引，范围在[0..getNumJoints(Id)]，注意link索引==joint索引</td>
</tr>
<tr>
<td>R</td>
<td>controlMode</td>
<td>int</td>
<td>POSITION_CONTROL, VELOCITY_CONTROL, TORQUE_CONTROL</td>
</tr>
<tr>
<td>O</td>
<td>targetPosition</td>
<td>float</td>
<td>在POSITION_CONTROL模式中，是joint的目标位置</td>
</tr>
<tr>
<td>O</td>
<td>targetVelocity</td>
<td>float</td>
<td>在POSITION_CONTROL, VELOCITY_CONTROL中joint的期望速度</td>
</tr>
<tr>
<td>O</td>
<td>force</td>
<td>float</td>
<td>在POSITION_CONTROL, VELOCITY_CONTROL中是达到目标值所使用的最大电机力，在TORQUE_CONTROL中，这是施加于每个stepSimulation的力/扭矩</td>
</tr>
<tr>
<td>O</td>
<td>maxVelocity</td>
<td>float</td>
<td>在POSITION_CONTROL中，它将速度限制为最大值</td>
</tr>
</tbody></table>
<br>
一般来说，最好使用VELOCITY_CONTROL或POSITION_CONTROL。由于模拟正确的力依赖于非常精确的URDF/SDF文件参数和系统识别(正确的质量、惯量、质心位置、关节摩擦等)，所以做扭矩控制(力控制)要困难得多

<ul>
<li><p>setJointMotorControlArray()</p>
<ul>
<li>可以为输入传递数组，而不是对每个关节进行单独调用，从而显著减少调用开销,参数和setJointMotorControl2()一样，除了用除了用list of int 代替 int</li>
</ul>
</li>
<li><p>setJointMotorControlMultiDofArray() <strong>umanoidMotionCapture.py</strong></p>
</li>
</ul>
<h2 id="2-3-获取关节信息"><a href="#2-3-获取关节信息" class="headerlink" title="2.3 获取关节信息"></a>2.3 获取关节信息</h2><p>可以使用getJointState()从关节查询几个状态变量，如关节位置、速度、关节反作用力和关节电机扭矩</p>
<ul>
<li>getJointState() 输入参数：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>jointIndex</td>
<td>int</td>
<td>link索引</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>getJointState() 返回：</li>
</ul>
<table>
<thead>
<tr>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>jointPosition</td>
<td>float</td>
<td>joint的位置</td>
</tr>
<tr>
<td>jointVelocity</td>
<td>float</td>
<td>joint的速度值</td>
</tr>
<tr>
<td>jointReactionForces</td>
<td>list of 6 floats</td>
<td>这些是联合反作用力，如果力矩传感器对这个关节启用，则为[Fx, Fy, Fz, Mx, My, Mz]。没有扭矩传感器，则为[0,0,0,0,0]</td>
</tr>
<tr>
<td>appliedJointMotorTorque</td>
<td>float</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>getJointStates():</p>
<ul>
<li>getJointStates是getJointState的数组版本。不是传入单个jointIndex，而是传入一个jointIndex列表。</li>
</ul>
</li>
<li><p>getJointState(s)MultiDof():</p>
<ul>
<li>对于球形关节，还有getJointStateMultiDof</li>
<li>getJointStatesMultiDof允许查询多个关节状态，包括多关节(球形)</li>
</ul>
</li>
<li><p>resetJointState()</p>
<ul>
<li>可以重置关节的状态。最好在一开始就这样做，而不运行模拟:resetJointState覆盖所有的物理模拟。注意，但目前只支持1自由度的机动关节，即滑动关节或转动关节。</li>
</ul>
</li>
<li><p>resetJointState(s)MultiDof()</p>
<ul>
<li>一次重置多个关节。</li>
</ul>
</li>
<li><p>enableJointForceTorqueSensor()</p>
<ul>
<li>可以在每个关节上启用或禁用一个关节力/扭矩传感器</li>
</ul>
</li>
</ul>
<h2 id="2-4-关节状态"><a href="#2-4-关节状态" class="headerlink" title="2.4 关节状态"></a>2.4 关节状态</h2><ul>
<li>getLinkState(s)<ul>
<li>可以使用getLinkState查询每个link的质心在笛卡尔坐标系的位置和方向。</li>
</ul>
</li>
</ul>
<p>输入参数：</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniquedId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引</td>
</tr>
<tr>
<td>O</td>
<td>computeLinkVelocity</td>
<td>int</td>
<td>如果=1，笛卡尔世界速度会被计算并返回</td>
</tr>
<tr>
<td>O</td>
<td>computeForwardKinematics</td>
<td>int</td>
<td>如果=1,笛卡尔世界的位置和方向会被重新计算，通过正向运动学</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>返回值:</p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>linkWorldPosition</td>
<td>vec3,list of 3 floats</td>
<td>质心的笛卡尔位置</td>
</tr>
<tr>
<td>linkWorldOrientation</td>
<td>vec4,list of 4 floats</td>
<td>质心的笛卡尔方向，四元组形式</td>
</tr>
<tr>
<td>localInertialFramePosition</td>
<td>vec3, list of 3 floats</td>
<td>在URDF link frame中表示的惯性系(质心)的局部位置偏移量</td>
</tr>
<tr>
<td>localInertialFrameOrientation</td>
<td>vec4, list of 4 floats</td>
<td>在URDF link frame中表示的惯性系(质心)的局部方向(四元数)偏移量</td>
</tr>
<tr>
<td>worldLinkFramePosition</td>
<td>vec3,list of floats</td>
<td>URDF link frame的 world 位置</td>
</tr>
<tr>
<td>worldLinkFrameOrientation</td>
<td>vec4,list of 4 floats</td>
<td>URDF link frame的 world 方向</td>
</tr>
<tr>
<td>worldLinkLinearVelocity</td>
<td>vec3,list of 3 floats</td>
<td>笛卡尔世界速度，仅当computeLinkVelocity非零时返回</td>
</tr>
<tr>
<td>worldLinkAngularVelocity</td>
<td>vec3,list of 3 floats</td>
<td>笛卡尔世界速度，仅当computeLinkVelocity非零时返回</td>
</tr>
</tbody></table>
<p>URDF link frame 和 the center of mass frame (both in world space) 的关系是: urdfLinkFrame = comLinkFrame * localInertialFrame.inverse().</p>
<ul>
<li>getLinkStates() <ul>
<li>getLinkStates将返回多个link的信息。代替linkIndex，它将接受linkIndices作为一个int类型的列表，这可以通过减少多次调用getLinkState的调用开销来提高性能</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Example Scripts</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>examples/pybullet/tensorflow/humanoid_running.py</td>
<td>加载一个类人，使用一个训练好的神经网络控制运行使用TensorFlow，由OpenAI训练</td>
</tr>
<tr>
<td>examples/pybullet/gym/pybullet_envs/bullet/minitaur.py and minitaur_gym_env.py</td>
<td>OpenAI GYM和TensorFlow的Minitaur环境</td>
</tr>
<tr>
<td>examples/pybullet/examples/quadruped.py</td>
<td>从URDF文件加载一个四足机器人，步进模拟，基于正弦波控制电机进行简单的跳跃步态。使用p.startStateLogging将状态记录到文件中</td>
</tr>
<tr>
<td>examples/quadruped_playback.py</td>
<td>创建一个四足机器人(Minitaur)，读取日志文件并设置位置作为运动控制目标。</td>
</tr>
<tr>
<td>examples/pybullet/examples/testrender.py</td>
<td>加载URDF文件并渲染图像，获取像素(RGB，深度，分割掩码)并使用MatPlotLib显示图像。</td>
</tr>
<tr>
<td>examples/pybullet/examples/testrender_np.py</td>
<td>与testrender相似。但是使用NumPy数组加速像素传输。还包括简单的基准/计时。</td>
</tr>
<tr>
<td>examples/pybullet/examples/saveWorld.py</td>
<td>将对象的状态(位置、方向)保存到pybullet Python脚本中。这主要用于在VR中设置场景并保存初始状态。不是所有的状态都是序列化的。</td>
</tr>
<tr>
<td>examples/pybullet/examples/inverse_kinematics.py</td>
<td>展示如何使用calculateinverse运动学命令，创建一个Kuka手臂时钟</td>
</tr>
<tr>
<td>xamples/pybullet/examples/rollPitchYaw.py</td>
<td>演示如何使用滑块GUI小部件</td>
</tr>
<tr>
<td>examples/pybullet/examples/constraint.py</td>
<td>以编程方式在link之间创建约束。</td>
</tr>
<tr>
<td>examples/pybullet/examples/vrhand.py</td>
<td>使用VR手套控制一只手，由VR控制器跟踪</td>
</tr>
</tbody></table>
<h2 id="2-5-Base-速度"><a href="#2-5-Base-速度" class="headerlink" title="2.5 Base 速度"></a>2.5 Base 速度</h2><ul>
<li>getBaseVelocity(Id)<ul>
<li>可以使用getBaseVelocity获得物体底部的线速度和角速度</li>
<li>这将返回一个包含两个vector的3值的列表，表示笛卡尔世界空间坐标下的线速度[x,y,z]和角速度[wx,wy,wz]。</li>
</ul>
</li>
<li>resetBaseVelocity(Id)<ul>
<li>使用resetBaseVelocity重置物体的线速度或角速度</li>
</ul>
</li>
</ul>
<h2 id="2-6-给力-applyExternalForce-Torque"><a href="#2-6-给力-applyExternalForce-Torque" class="headerlink" title="2.6 给力 applyExternalForce/Torque"></a>2.6 给力 applyExternalForce/Torque</h2><p>可以使用applyExternalForce和applyExternalTorque向物体施加一个力或扭矩。请注意，此方法仅在使用stepSimulation显式步进模拟时有效，换句话说:setRealTimeSimulation(0)。在每一个模拟步骤之后，外力被清除为零。如果你使用’setRealTimeSimulation(1)， applyExternalForce/Torque将有未定义的行为(either 0, 1 or multiple force/torque applications)。</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引或者是代表base的-1</td>
</tr>
<tr>
<td>R</td>
<td>forceObj</td>
<td>vec3f</td>
<td>要施加的力/扭矩矢量[x,y,z]。坐标系见flags</td>
</tr>
<tr>
<td>R</td>
<td>posObj</td>
<td>vec3f</td>
<td>在link上受力的位置，只有applyExternalForce可用，坐标系见flags</td>
</tr>
<tr>
<td>R</td>
<td>flags</td>
<td>int</td>
<td>指定力/位置的坐标系,WORLD_FRAME表示笛卡尔世界坐标，LINK_FRAME表示局部link坐标坐标系。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="2-7-物体"><a href="#2-7-物体" class="headerlink" title="2.7 物体"></a>2.7 物体</h2><ul>
<li>getNumBodies<ul>
<li>getNumBodies将返回物理服务器中物体的总数量。</li>
<li>如果使用过’getNumBodies’,可以使用getBodyUniqueId查询物体id。</li>
<li>所有的api都已经返回物体唯一id，所以如果要跟踪它们，通常不需要使用getBodyUniqueId。</li>
</ul>
</li>
<li>getBodyInfo<ul>
<li>返回base的名字</li>
</ul>
</li>
<li>syncBodyInfo<ul>
<li>syncBodyInfo会同步物体信息(getBodyInfo)，如果多个客户端连接到一个物理服务器改变world(loadURDF, removeBody等)。</li>
</ul>
</li>
<li>removeBody<ul>
<li>通过Id移除物体</li>
</ul>
</li>
</ul>
<h2 id="2-6-约束-constraint-py"><a href="#2-6-约束-constraint-py" class="headerlink" title="2.6 约束 constraint.py"></a>2.6 约束 <strong>constraint.py</strong></h2><ul>
<li>createConstraint() <ul>
<li>URDF、SDF和MJCF将articulated bodies指定为没有循环的树形结构。createConstraint() 允许你连接bodies的特定links来关闭这些循环。<strong>quadruped.py</strong> </li>
<li>可以在对象之间以及对象与特定世界坐标系之间创建任意约束。<strong>constraint.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>parentBodyUniqueId</td>
<td>int</td>
<td>parent body ID</td>
</tr>
<tr>
<td>R</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>parent link索引或者是-1(base)</td>
</tr>
<tr>
<td>R</td>
<td>childBodyUniqueId</td>
<td>int</td>
<td>child body Id，或者是-1表示no body</td>
</tr>
<tr>
<td>R</td>
<td>childLinkIndex</td>
<td>int</td>
<td>child link索引或者是-1(base)</td>
</tr>
<tr>
<td>R</td>
<td>jointType</td>
<td>int</td>
<td>JOINT_PRISMATIC, JOINT_FIXED, JOINT_POINT2POINT, JOINT_GEAR</td>
</tr>
<tr>
<td>R</td>
<td>jointAxis</td>
<td>vec3f</td>
<td>joint axis, in child link frame</td>
</tr>
<tr>
<td>R</td>
<td>parentFramePosition</td>
<td>vec3f</td>
<td>相对于parent质心frame的joint frame的位置</td>
</tr>
<tr>
<td>R</td>
<td>childFramePosition</td>
<td>vec3f</td>
<td>joint frame相对于给定子质心的frame位置(如果没有指定子质心frame，则为world原点)</td>
</tr>
<tr>
<td>O</td>
<td>parentFrameOrientation</td>
<td>vec4f</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>childFrameOrientation</td>
<td>vec4f</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>createConstraint()将返回一个整数唯一id，可用于更改或删除约束。在 <strong>examples/pybullet/examples/mimicJointConstraint.py</strong> 中可以看到JOINT_GEAR的例子，在 <strong>examples/pybullet/examples/minitaur.py</strong> 中可以看到JOINT_POINT2POINT的例子，在 <strong>examples/pybullet/examples/constraint.py</strong> 中可以看到JOINT_FIXED的例子。</p>
<ul>
<li>changeConstraint()<ul>
<li>可以用来更改现有约束的参数</li>
<li></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>userConstraintUniqueId</td>
<td>int</td>
<td>由createConstraint返回的Id</td>
</tr>
<tr>
<td>O</td>
<td>JointChildPivot</td>
<td>vec3f</td>
<td>更新子pivot</td>
</tr>
<tr>
<td>O</td>
<td>JointChildFrameOrientation</td>
<td>vec4f</td>
<td>更新子frame方位,四元组形式</td>
</tr>
<tr>
<td>O</td>
<td>maxForce</td>
<td>float</td>
<td>约束所能施加的最大力</td>
</tr>
<tr>
<td>O</td>
<td>gearRatio</td>
<td>float</td>
<td>两个齿轮的转速之比</td>
</tr>
<tr>
<td>O</td>
<td>gearAuxLink</td>
<td>int</td>
<td>在某些情况下，例如差速传动，第三个(辅助)link被用作参考姿态。见<strong>examples/pybullet/examples/racecar_differential.py</strong></td>
</tr>
<tr>
<td>O</td>
<td>relativePositionTarget</td>
<td>float</td>
<td>两个齿轮之间的相对位置目标偏移量</td>
</tr>
<tr>
<td>O</td>
<td>erp</td>
<td>float</td>
<td>约束误差减小参数</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>See also <strong>Bullet/examples/pybullet/examples/constraint.py</strong></p>
<ul>
<li>removeConstraint()</li>
</ul>
<p>removeConstraint 会移除一个约束, 返回它的唯一Id，它的输入参数为：</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>userConstraintUniqueId</td>
<td>int</td>
<td>createConstraint返回的id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>getNumConstraints(), getConstraintUniqueId()</p>
<ul>
<li>可以查询 使用“createConstraint”创建的约束的总数。</li>
</ul>
</li>
<li><p>getConstraintUniqueId()</p>
<ul>
<li>getConstraintUniqueId()将在范围[0..getNumConstraints()]，约束的唯一id可能不是连续的，因为可能会删除约束。输入是int serial index。</li>
</ul>
</li>
<li><p>getConstraintInfo/State</p>
<ul>
<li>可以查询约束信息，并给出约束唯一id</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>constraintUniqueId</td>
<td>int</td>
<td>createConstraint得到的唯一Id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>parentBodyUniqueId</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>parentJointIndex</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>childBodyUniqueId</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>childLinkIndex</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>constraintType</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointAxis</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointPivotInParent</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointPivotInChild</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointFrameOrientationParent</td>
<td>vec4f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointFrameOrientationChild</td>
<td>vec4f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>maxAppliedForce</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>gearRatio</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>gearAuxLink</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>relativePositionTarget</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>erp</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
</tbody></table>
<ul>
<li>getConstraintState()<ul>
<li>给出约束唯一id，可以在最近的模拟步骤中查询应用的约束力。输入是一个约束唯一id，输出是一个约束力向量，其维度是受约束影响的自由度(例如，固定约束影响6自由度)。</li>
</ul>
</li>
</ul>
<h2 id="2-7-动力-Dynamics"><a href="#2-7-动力-Dynamics" class="headerlink" title="2.7 动力 Dynamics"></a>2.7 动力 Dynamics</h2><ul>
<li>getDynamicsInfo()<ul>
<li>可以得到关于质量，质心，摩擦和其他属性的base和links。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link(joint)索引或者-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Returned Value</th>
<th>type</th>
<th>descriotion</th>
</tr>
</thead>
<tbody><tr>
<td>mass</td>
<td>double</td>
<td>单位kg</td>
</tr>
<tr>
<td>lateral_friction</td>
<td>double</td>
<td>摩擦系数</td>
</tr>
<tr>
<td>local inertia diagonal</td>
<td>vec3f</td>
<td>Note that links and base are centered around the center of mass and aligned with the principal axes of inertia.</td>
</tr>
<tr>
<td>local inertial pos</td>
<td>vec3</td>
<td>position of inertial frame in local coordinates of the joint frame</td>
</tr>
<tr>
<td>local inertial orn</td>
<td>vec4</td>
<td>orientation of inertial frame in local coordinates of joint frame</td>
</tr>
<tr>
<td>restitution</td>
<td>double</td>
<td>恢复系数（e）是碰撞前后两物体沿接触处法线方向上的分离速度与接近速度之比，只与碰撞物体的材料有关</td>
</tr>
<tr>
<td>rolling friction</td>
<td>double</td>
<td>滚动摩擦系数,与接触法线正交</td>
</tr>
<tr>
<td>spinning friction</td>
<td>double</td>
<td>接触法线周围的旋转摩擦系数</td>
</tr>
<tr>
<td>contact damping</td>
<td>double</td>
<td>接触约束阻尼，如果没有则为-1</td>
</tr>
<tr>
<td>contact stiffness</td>
<td>double</td>
<td>接触约束刚度，如果没有则为-1</td>
</tr>
<tr>
<td>body type</td>
<td>int</td>
<td>1=rigid body, 2 = multi body, 3 = soft body</td>
</tr>
<tr>
<td>collision margin</td>
<td>double</td>
<td>advanced/internal/unsupported info.碰撞边缘的碰撞形状。碰撞边缘取决于形状类型，它是不一致的</td>
</tr>
</tbody></table>
<ul>
<li>changeDynamics()<ul>
<li>changeDynamics()可以改变属性，如质量，摩擦和恢复系数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引或-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>mass</td>
<td>double</td>
<td>改变link的mass</td>
</tr>
<tr>
<td>O</td>
<td>lateralFriction</td>
<td>double</td>
<td>横向(线性)接触摩擦</td>
</tr>
<tr>
<td>O</td>
<td>spinningFriction</td>
<td>double</td>
<td>接触法线周围的扭转摩擦</td>
</tr>
<tr>
<td>O</td>
<td>rollingFriction</td>
<td>double</td>
<td>扭转摩擦与接触法线正交(保持这个值非常接近于零，否则模拟会变得非常不现实。</td>
</tr>
<tr>
<td>O</td>
<td>restitution</td>
<td>double</td>
<td>接触的反弹力，让它略小于1，最好更接近0</td>
</tr>
<tr>
<td>O</td>
<td>linearDamping</td>
<td>double</td>
<td>link的线性阻尼(默认为0.04)</td>
</tr>
<tr>
<td>O</td>
<td>angularDamping</td>
<td>double</td>
<td>link的角阻尼(默认为0.04)</td>
</tr>
<tr>
<td>O</td>
<td>contactStiffness</td>
<td>double</td>
<td>接触约束的刚度，与接触阻尼一起使用</td>
</tr>
<tr>
<td>O</td>
<td>contactDamping</td>
<td>double</td>
<td>此bidy/link的接触约束的阻尼。与接触刚度一起使用。如果该值是在contact部分的URDF文件中指定的，那么它将覆盖该值。</td>
</tr>
<tr>
<td>O</td>
<td>frictionAnchor</td>
<td>int</td>
<td>启用或禁用friction anchor:摩擦漂移校正(默认禁用，除非在URDF接触部分设置)</td>
</tr>
<tr>
<td>O</td>
<td>localInertiaDiagnoal</td>
<td>vec3</td>
<td></td>
</tr>
<tr>
<td>。。。</td>
<td>。。。</td>
<td>。。。</td>
<td>。。。</td>
</tr>
</tbody></table>
<h2 id="2-8-模拟-Simulation"><a href="#2-8-模拟-Simulation" class="headerlink" title="2.8 模拟 Simulation"></a>2.8 模拟 Simulation</h2><ul>
<li>setTimeStep()<ul>
<li>在许多情况下，最好将timeStep保留为默认值，即240Hz。几个参数根据这个值进行了调优。例如，求解器迭代次数和接触、摩擦和非接触关节的误差减少参数(erp)都与时间步长有关。如果您更改了时间步长，您可能需要相应地重新调整这些值，特别是erp值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>timeStep</td>
<td>float</td>
<td>每次调用“stepSimulation”时，timeStep将继续执行“timeStep”</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>setPhysicsEngineParameter()<ul>
<li>通过setPhysicsEngineParameter API可以设置物理引擎参数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
</table>
<ul>
<li>setDefaultContactERP<ul>
<li>设置默认contact 参数，将被纳入setPhysicsEngineParameter API</li>
</ul>
</li>
</ul>
<ul>
<li>getPhysicsEngineParameters<ul>
<li>查询物理引擎参数</li>
</ul>
</li>
</ul>
<ul>
<li>resetSimulation<ul>
<li>从世界中移除所有对象，并将世界重置为初始条件。</li>
</ul>
</li>
</ul>
<h2 id="2-9-日志-logging"><a href="#2-9-日志-logging" class="headerlink" title="2.9 日志 logging"></a>2.9 日志 logging</h2><ul>
<li><p>startStateLogging</p>
<ul>
<li><p>该命令将返回一个非负的int loggingUniqueId，可以与stopStateLogging一起使用。</p>
</li>
<li><p>状态日志可以记录模拟的状态，比如在每个模拟步骤之后(在每次对stepSimulation的调用之后，或者在启用setRealTimesSimulation时在每个模拟步骤之后自动记录)一个或多个对象的状态。可以记录物体的轨迹。也可以选择记录body的共同状态，如基座位置和方向，关节位置(角度)和关节马达力。</p>
</li>
<li><p>所有使用startStateLogging生成的日志文件都可以使用c++或Python脚本读取。见<strong>quadruped_playback.py</strong>和<strong>kuka_with_cube_playback.py</strong>查看Python脚本读取日志文件</p>
</li>
<li><p>对于MP4视频的录制，可以使用记录选项STATE_LOGGING_VIDEO_MP4。</p>
</li>
<li><p>作为一个特例，PyBullet实现了Minitaur机器人的日志记录。PyBullet模拟的日志文件与真实的Minitaur四足动物日志文件相同。见<strong>Bullet/examples/pybullet/examples/logMinitaur.py</strong></p>
</li>
<li><p>重要提示:各种日志记录器包括它们自己的内部时间戳，创建时从0开始。这意味着需要同时启动所有的记录器，以保持同步。在启动记录器时，您需要确保模拟不是在实时模式下运行:在创建记录器之前使用pybullet.setRealTimesSimulation(0)。</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>loggingType</td>
<td>int</td>
<td>STATE_LOGGING_MINITAUR:quadruped.urdf 专用 <br>STATE_LOGGING_GENERIC_ROBOT:这将记录所有对象或所选对象的数据日志(如果提供了objectUniqueIds)<br>STATE_LOGGING_VIDEO_MP4:这将打开一个MP4文件，并开始使用ffmpeg管道将OpenGL 3D visualizer像素流到文件中。它需要安装ffmpeg。你也可以使用avconv (Ubuntu默认)，只需要创建一个符号链接，这样ffmpeg就可以指向avconv。在Windows上，ffmpeg有一些问题，导致撕裂/颜色工件在某些情况下<br>STATE_LOGGING_PROFILE_TIMINGS：这将转储一个JSON格式的计时文件，可以使用谷歌Chrome打开关于://跟踪加载<br>STATE_LOGGING_CONTACT_POINTS<br>STATE_LOGGING_VR_CONTROLLERS.</td>
</tr>
<tr>
<td>R</td>
<td>fileName</td>
<td>string</td>
<td>文件名(绝对或相对路径)用于存储日志文件数据。</td>
</tr>
<tr>
<td>O</td>
<td>objectUniqueIds</td>
<td>list of int</td>
<td>如果为空，记录器可能记录每个对象，否则记录器只记录objectUniqueIds列表中的对象。</td>
</tr>
<tr>
<td>O</td>
<td>maxLogDof</td>
<td>int</td>
<td>要记录的最大关节自由度数(不包括基自由度)。这适用于STATE_LOGGING_GENERIC_ROBOT_DATA。缺省值为12。如果一个机器人超过了dofs的数量，它根本不会被记录。</td>
</tr>
<tr>
<td>O</td>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及bodyUniqueIdA的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及bodyUniqueIdB的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及linkIndexA bodyUniqueIdA的接触点</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录bodyUniqueIdA中涉及linkIndexB的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>deviceTypeFilter</td>
<td>int</td>
<td>deviceTypeFilter允许您选择要记录的VR设备</td>
</tr>
<tr>
<td>O</td>
<td>logFlags</td>
<td>int</td>
<td>STATE_LOG_JOINT_TORQUES,记录由关节电机引起的关节力矩</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>stopStateLogging</p>
<ul>
<li>使用它的loggingUniqueId来停止logging</li>
</ul>
</li>
<li><p>submitProfileTime <strong>profile_Timing.py</strong></p>
<ul>
<li>允许插入开始和停止计时来分析Python代码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器人仿真</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>教程</tag>
        <tag>PyBullet</tag>
        <tag>机器人仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 树的遍历</title>
    <url>/2021/07/19/LeetCode%20-%20%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="0-题目总览"><a href="#0-题目总览" class="headerlink" title="0 - 题目总览"></a>0 - 题目总览</h2><p><strong>二叉树的遍历：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></li>
</ul>
<p><strong>N叉树的遍历：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N 叉树的前序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N 叉树的后序遍历</a></li>
</ul>
<p><strong>层序遍历：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层序遍历 II</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></li>
<li><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. 二叉树的层平均值</a></li>
<li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></li>
<li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></li>
<li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></li>
</ul>
<p><strong>N叉树层序遍历：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N 叉树的层序遍历</a></li>
</ul>
<h2 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="1 - 二叉树的定义"></a>1 - 二叉树的定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    Treenode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-二叉树的递归遍历"><a href="#2-二叉树的递归遍历" class="headerlink" title="2 - 二叉树的递归遍历"></a>2 - 二叉树的递归遍历</h2><h3 id="前序递归遍历：根-左-右"><a href="#前序递归遍历：根-左-右" class="headerlink" title="前序递归遍历：根 左 右"></a>前序递归遍历：根 左 右</h3><p> <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        traversal(root-&gt;left, vec);</span><br><span class="line">        traversal(root-&gt;right, vect);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        traversal(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序递归遍历：左-根-右"><a href="#中序递归遍历：左-根-右" class="headerlink" title="中序递归遍历：左 根 右"></a>中序递归遍历：左 根 右</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(root-&gt;left, vec);</span><br><span class="line">    vec.push_back(root-&gt;val);</span><br><span class="line">    traversal(root-&gt;right, vect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序递归遍历：左-右-根"><a href="#后序递归遍历：左-右-根" class="headerlink" title="后序递归遍历：左 右 根"></a>后序递归遍历：左 右 根</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(root-&gt;left, vec);</span><br><span class="line">    traversal(root-&gt;right, vect);</span><br><span class="line">       vec.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉树的迭代遍历"><a href="#3-二叉树的迭代遍历" class="headerlink" title="3 - 二叉树的迭代遍历"></a>3 - 二叉树的迭代遍历</h2><p>迭代法遍历（非递归遍历）需要借助栈，首先用一个题来熟悉一下栈的使用：</p>
<p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a></p>
<p>​    给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.back() == ch)</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                stk.push_back(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>std::string</code>类本身就提供了类似「入栈」和「出栈」的接口，可以直接当做<code>deque</code>使用</p>
<h3 id="前序迭代遍历：入栈时先右后左"><a href="#前序迭代遍历：入栈时先右后左" class="headerlink" title="前序迭代遍历：入栈时先右后左"></a>前序迭代遍历：入栈时先右后左</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.emplace_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.emplace(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.emplace(node-&gt;left); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中续迭代遍历：先一路向左"><a href="#中续迭代遍历：先一路向左" class="headerlink" title="中续迭代遍历：先一路向左"></a>中续迭代遍历：先一路向左</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span> || !st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后续迭代遍历：辅助指针prev记录上一个遍历的节点"><a href="#后续迭代遍历：辅助指针prev记录上一个遍历的节点" class="headerlink" title="后续迭代遍历：辅助指针prev记录上一个遍历的节点"></a>后续迭代遍历：辅助指针prev记录上一个遍历的节点</h3><p>需要一个<code>prev指针</code>记录遍历过的节点，首先一直往左走，并将所经过节点推入栈中，当 <code>cur == nullptr</code>时，走到最左边，令<code>cur</code> 指向栈顶节点，也就是最左节点，并将它弹出，此时有两种情况：</p>
<ul>
<li>如果此节点的右节点是空的 或者 此节点的右节点已经遍历过，则直接进行 根节点 操作，之后将此节点标记成已访问的节点 prev。</li>
<li>如果此节点的右节点不为空且没被访问过，则把 <code>cur</code> 再次推回栈中，往它的右节点走</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>, *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right == <span class="literal">nullptr</span> || cur-&gt;right == prev)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-N叉树的递归遍历"><a href="#4-N叉树的递归遍历" class="headerlink" title="4 - N叉树的递归遍历"></a>4 - N叉树的递归遍历</h2><h3 id="N叉树的前序遍历："><a href="#N叉树的前序遍历：" class="headerlink" title="N叉树的前序遍历："></a>N叉树的前序遍历：</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N 叉树的前序遍历</a></p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;children[i])</span><br><span class="line">                preorder(root-&gt;children[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul>
<li>将孩子节点入栈时要逆序进入，才能保证出栈是顺序的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node *node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 将孩子节点逆序入栈，保证出栈是顺序的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = node-&gt;children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children[i]) </span><br><span class="line">                    st.push(node-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="N叉树的后续遍历："><a href="#N叉树的后续遍历：" class="headerlink" title="N叉树的后续遍历："></a>N叉树的后续遍历：</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N 叉树的后序遍历</a></p>
<h4 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; root-&gt;children.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;children[i])</span><br><span class="line">                postorder(root-&gt;children[i]);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><p>二叉树与N叉树的唯一区别仅仅在于孩子结点的数量，在二叉树的后序非递归算法中，使用了一个变量 <code>prev</code>来记录上一个遍历的结点，这个变量的作用是用于区分栈顶结点的右子树是否已经遍历过，回忆二叉树的前序和中序遍历，栈中存放的结点是 <code>未访问的</code> 和 <code>访问过左子树的</code> 结点，而后序遍历栈中<code>同时存放了访问过左子树和访问过右子树的结点</code>，所以<code>需要一个标志即 prev 来区分这两种结点</code>。</p>
<p>现在，从二叉树拓展到N叉树，孩子结点的数量不再是只有两个，栈中可能会同时存在<code>访问过一个孩子结点的</code>、<code>访问过两个孩子结点的</code>、<code>访问过三个孩子结点的</code>…… 的结点，这个时候仅仅一个标志已经无法区分这些不同访问层次的结点，所以相对应的对于每一个结点，都要设置一个标志来记录该结点有多少个孩子结点已经遍历过了。</p>
<p>由二叉树的后序非递归得到N叉树的后序非递归算法：</p>
<ul>
<li>对于访问二叉树的左孩子结点，改为访问N叉树的第一个孩子结点</li>
<li>对于访问二叉树的右孩子结点，取得标志(即已访问过的孩子数)然后访问下一个孩子结点</li>
<li>对于判断是否访问过右孩子结点，根据标志判断孩子结点是否全部访问过</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;Node*, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">auto</span> cur = pair(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || cur.first != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.first != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                <span class="keyword">if</span> (cur.first-&gt;children.size() &gt; <span class="number">0</span>)</span><br><span class="line">                    cur = pair(cur.first-&gt;children[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur.first = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.first-&gt;children.size() == <span class="number">0</span> || cur.second == cur.first-&gt;children.size())</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(cur.first-&gt;val);</span><br><span class="line">                cur.first = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++cur.second;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                <span class="keyword">if</span> (cur.second &lt; cur.first-&gt;children.size())</span><br><span class="line">                    cur = pair(cur.first-&gt;children[cur.second], <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur.first = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5 - 层序遍历"></a>5 - 层序遍历</h2><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层序遍历 II</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) res.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. 二叉树的层平均值</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(sum * <span class="number">1.0</span> / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size(), maxValue = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                maxValue = max(maxValue, node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(maxValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            Node *pre = <span class="literal">nullptr</span>, *cur = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    cur = pre;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cur = q.front();</span><br><span class="line">                    pre-&gt;next = cur;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            Node *pre = <span class="literal">nullptr</span>, *cur = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    cur = pre;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cur = q.front();</span><br><span class="line">                    pre-&gt;next = cur;</span><br><span class="line">                    pre = cur; <span class="comment">// pre = pre-&gt;next</span></span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N 叉树的层序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.size(); j++)</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[j])</span><br><span class="line">                        q.push(node-&gt;children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode专题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>PyBullet Quickstart Guide 官方文档翻译 3 - Deformables and Cloth | 4 - Synthetic Camera Rendering | 5 - Collision Detection Queries | 6 - Inverse Dynamics, Kinematics</title>
    <url>/2021/05/31/PyBullet2/</url>
    <content><![CDATA[<h1 id="3-Deformables-and-Cloth-using-FEM-PBD"><a href="#3-Deformables-and-Cloth-using-FEM-PBD" class="headerlink" title="3. Deformables and Cloth (using FEM, PBD)"></a>3. Deformables and Cloth (using FEM, PBD)</h1><p>Finite Element Method (FEM) 有限元法<br><br>position based dynamics（PBD）基于位置的模拟<br><br>可以通过如下方式重置世界来启用基于有限元法(FEM)的模拟：<br><strong>deformable_torus.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pybullet.resetSimulation(p.RESET_USE_DEFORMABLE_WORLD)</span><br></pre></td></tr></table></figure>

<ul>
<li>loadSoftBody/loadURDF<ul>
<li>从VTK或OBJ文件加载一个可变形的对象。</li>
</ul>
</li>
</ul>
<h1 id="4-Synthetic-Camera-Rendering"><a href="#4-Synthetic-Camera-Rendering" class="headerlink" title="4. Synthetic Camera Rendering"></a>4. Synthetic Camera Rendering</h1><p>PyBullet有一个内置的OpenGL GPU可视化工具和一个基于TinyRenderer的内置CPU渲染器。这使得从任意相机位置渲染图像变得非常容易。在Linux上，你也可以在没有X11上下文的情况下启用硬件加速的OpenGL渲染。<br><br><strong>eglRenderTest.py</strong><br><br>合成相机由两个4 × 4矩阵指定:视图矩阵和投影矩阵。由于这些不是很直观，有一些辅助方法来计算视图和投影矩阵从可理解的参数。<br><a href="http://ksimek.github.io/2013/08/13/intrinsic/" target="_blank" rel="noopener">http://ksimek.github.io/2013/08/13/intrinsic/</a></p>
<ul>
<li>computeView/ProjectionMatrix</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Inupt parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraEyePosition</td>
<td>vec3f</td>
<td>eye position在笛卡尔坐标系中</td>
</tr>
<tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>vec3f</td>
<td>目标(焦点)点的位置，以笛卡尔世界坐标表示</td>
</tr>
<tr>
<td>R</td>
<td>cameraUpVector</td>
<td>vec3f</td>
<td>在笛卡尔坐标系下，相机的up vector</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4视图矩阵，存储为包含16个浮点数的列表。<br></p>
<ul>
<li>computeViewMatrixFromYawPitchRoll</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>list of 3 f</td>
<td>目标焦点在笛卡尔世界坐标</td>
</tr>
<tr>
<td>R</td>
<td>distance</td>
<td>float</td>
<td>从eye到焦点的距离</td>
</tr>
<tr>
<td>R</td>
<td>yaw</td>
<td>float</td>
<td>yaw angle in degrees left/right around up-axis.</td>
</tr>
<tr>
<td>R</td>
<td>pitch</td>
<td>float</td>
<td>pitch in degrees up/down.</td>
</tr>
<tr>
<td>R</td>
<td>roll</td>
<td>float</td>
<td>roll in degrees around forward vector</td>
</tr>
<tr>
<td>R</td>
<td>upAxisIndex</td>
<td>int</td>
<td>Y轴是1,Z轴是2。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4视图矩阵，存储为包含16个浮点数的列表。</p>
<ul>
<li>computeProjectionMatrix</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>left</td>
<td>float</td>
<td>左屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>right</td>
<td>float</td>
<td>右屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>bottom</td>
<td>float</td>
<td>下方屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>top</td>
<td>float</td>
<td>上方屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>near</td>
<td>float</td>
<td>近平面的距离</td>
</tr>
<tr>
<td>R</td>
<td>far</td>
<td>float</td>
<td>远平面的距离</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4投影矩阵，存储为一个包含16个浮点数的列表。</p>
<ul>
<li>computeProjectionMatrixFOV<ul>
<li>这个命令还将使用不同的参数返回一个4x4投影矩阵。你可以查看OpenGL文档了解这些参数的含义</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>fov</td>
<td>float</td>
<td>视野</td>
</tr>
<tr>
<td>R</td>
<td>aspect</td>
<td>float</td>
<td>纵横比；屏幕高宽比</td>
</tr>
<tr>
<td>R</td>
<td>nearVal</td>
<td>float</td>
<td>近平面的距离</td>
</tr>
<tr>
<td>R</td>
<td>farVal</td>
<td>flaot</td>
<td>远平面的距离</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<ul>
<li>getCameraImage<ul>
<li>getCameraImage API将返回一个RGB图像，一个深度缓冲区和一个分割掩码缓冲区，其中包含每个像素的可见对象的body unique id。请注意，PyBullet可以使用numpy选项进行编译:使用numpy将提高从C到Python复制摄像机像素的性能。注意:旧的renderImage API已经过时了，被getCameraImage所取代。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>width</td>
<td>int</td>
<td>以像素为单位的水平图像分辨率</td>
</tr>
<tr>
<td>R</td>
<td>height</td>
<td>int</td>
<td>以像素为单位的垂直图像分辨率</td>
</tr>
<tr>
<td>O</td>
<td>viewMatrix</td>
<td>16 floats</td>
<td>4x4视图矩阵，参见computeViewMatrix*</td>
</tr>
<tr>
<td>O</td>
<td>projectionMatrix</td>
<td>16 floats</td>
<td>4x4投影矩阵，参见computeProjection*</td>
</tr>
<tr>
<td>O</td>
<td>lightDirection</td>
<td>vec3f</td>
<td>lightDirection指定光源的世界位置，方向是从光源位置到世界框架的原点。</td>
</tr>
<tr>
<td>O</td>
<td>lightColor</td>
<td>vec3f</td>
<td>方向光颜色在[红，绿，蓝]范围0..1、仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightDistance</td>
<td>float</td>
<td>光沿归一化光方向的距离，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>shadow</td>
<td>int</td>
<td>1表示阴影，0表示没有阴影，只适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightAmbientCoeff</td>
<td>float</td>
<td>光环境系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightDiffuseCoeff</td>
<td>float</td>
<td>光漫反射系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightSpecularCoeff</td>
<td>float</td>
<td>光反射系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>renderer</td>
<td>int</td>
<td>ER_BULLET_HARDWARE_OPENGL或ER_TINY_RENDERER。注意，直接模式没有OpenGL，所以它需要ER_TINY_RENDERER。</td>
</tr>
<tr>
<td>O</td>
<td>flags</td>
<td>int</td>
<td>ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX，参见下面的segmentationMaskBuffer的描述和示例代码。使用ER_NO_SEGMENTATION_MASK来避免计算分割掩码。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>int</td>
<td>宽度图像分辨率(以像素为单位)(水平)</td>
</tr>
<tr>
<td>height</td>
<td>int</td>
<td>高度图像分辨率(以像素为单位)(垂直)</td>
</tr>
<tr>
<td>rgbPixel</td>
<td>list of [char RED,char GREEN,char BLUE, char ALPHA] [0..width*height]</td>
<td>R,G,B格式的像素颜色列表，范围[0..]每一种颜色</td>
</tr>
<tr>
<td>depthPixels</td>
<td>list of float [0..width*height]</td>
<td>depth buffer. Bullet uses OpenGL to render, and the convention is non-linear z-buffer.See <a href="https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer" target="_blank" rel="noopener">https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer</a> <br> far=1000. 取决于投影矩阵，这是默认的<br> near=0.01 取决于投影矩阵<br> depth = far<em>near/(far-(far-near)\</em>depthImg) depthImg是从getCameraImage函数得到的depth。demo见 <strong>pointCloudFromCameraImage.py</strong></td>
</tr>
<tr>
<td>segmentationMaskBuffer</td>
<td>list of int [0..width*height]</td>
<td>对于每个像素，可见对象的唯一id如果使用ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX, segmentationMaskBuffer将对象唯一id和链接索引结合如下:<br> value = objectUniqueId + (linkIndex+1)&lt;&lt;24 Demo见 <strong>segmask_linkindex.py</strong> <br>所以对于一个没有joints/links的自由浮动我要吐，分割掩码等于它本身的唯一id，因为它的link索引是-1。</td>
</tr>
</tbody></table>
<ul>
<li><p>isNumpyEnabled</p>
<ul>
<li>对于大图像，将像素从C/C++复制到Python可能会非常慢，除非使用NumPy编译PyBullet。可以使用PyBullet.isNumpyEnabled()检查是否启用了NumPy。如果系统上可用，则pip install pybullet启用了NumPy。目前，只有getCameraImage使用numpy加速。</li>
</ul>
</li>
<li><p>getVisualShapeData</p>
<ul>
<li>可以使用getVisualShapeData访问视觉形状信息。可以使用此方法将自己的呈现方法与PyBullet模拟连接起来，并在每个模拟步骤之后手动同步世界转换。也可以使用getMeshData来接收顶点位置的数据，特别是对于可变形的对象。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>O</td>
<td>flags</td>
<td>int</td>
<td>VISUAL_SHAPE_DATA_TEXTURE_UNIQUE_IDS也将提供textureUniqueId</td>
</tr>
<tr>
<td>O</td>
<td>pyhsicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Output parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>objectUniqueId</td>
<td>int</td>
<td>Id,和输入参数相同</td>
</tr>
<tr>
<td>linkIndex</td>
<td>int</td>
<td>link索引或-1(base)</td>
</tr>
<tr>
<td>visualGeometryType</td>
<td>int</td>
<td>视觉几何类型(TBD)</td>
</tr>
<tr>
<td>dimentsions</td>
<td>vec3f</td>
<td>几何的尺寸(大小，局部比例尺)</td>
</tr>
<tr>
<td>meshAssetFileName</td>
<td>string,list of chars</td>
<td>triangle mesh的路径，如果有的话。通常是相对于URDF、SDF或MJCF文件位置，但也可以是绝对位置</td>
</tr>
<tr>
<td>localVisualFrame position</td>
<td>vec3f</td>
<td>局部visual frame相对于link/joint的位置</td>
</tr>
<tr>
<td>localVisualFrame orientation</td>
<td>vec4f</td>
<td>局部visual frame相对于link/joint的方向</td>
</tr>
<tr>
<td>rgbaColor</td>
<td>vec4f</td>
<td>URDF颜色(如果有指定)为红色/绿色/蓝色/alpha</td>
</tr>
<tr>
<td>textureUniqueId</td>
<td>int</td>
<td>(此字段仅在使用VISUAL_SHAPE_DATA_TEXTURE_UNIQUE_IDS标志时存在)纹理形状的唯一id，无时为-1</td>
</tr>
</tbody></table>
<p>物理模拟使用质心作为笛卡尔世界变换的参考，在getBasePositionAndOrientation和getLinkState中。如果实现自己的渲染，需要将局部视觉转换转换到世界空间，利用质心世界变换和(反向)localInertialFrame。可以使用getLinkState API访问localInertialFrame。</p>
<ul>
<li>changeVisualShape, loadTexture<ul>
<li>可以使用changeVisualShape来改变Shape的纹理、RGBA颜色和其他属性。</li>
</ul>
</li>
</ul>
<p>||Input Parameters|type|descriptions|<br>|R|objectUniqueId|int|Id|<br>|R|linkIndex|int|link索引|<br>|O|shapeIndex|int|对于内部使用的实验，建议忽略shapeIndex或将其保留为-1。其目的是让可以选择要修改的特定shape的索引，因为URDF（和SDF等）每个link可以有多个visual shape。此shapeIndex与getVisualShapeData返回的列表顺序匹配。|<br>|O|textureUniqueId|int|纹理的唯一id，由loadTexture方法返回|<br>|O|rgbaColor|vec4f|颜色组件为红色，绿色，蓝色和ALPHA，每个范围[0..1]。Alpha必须是0(不可见)或1(可见)。注意，TinyRenderer不支持透明，但是GUI/EGL OpenGL3渲染器支持。|<br>|O|specularColor|vec3|高光颜色成分，红、绿、蓝，可以从0到大的数(&gt;100)。|<br>|R|physicsClientId|int|物理客户端id由’connect’返回|</p>
<ul>
<li>loadTexture<ul>
<li>从文件中加载一个纹理，如果加载成功，返回一个非负的纹理唯一id。这个唯一的id可以与changeVisualShape一起使用。</li>
</ul>
</li>
</ul>
<h1 id="5-Collision-Detection-Queries-碰撞检测查询"><a href="#5-Collision-Detection-Queries-碰撞检测查询" class="headerlink" title="5. Collision Detection Queries 碰撞检测查询"></a>5. Collision Detection Queries 碰撞检测查询</h1><p>可以查询上次“stepSimulation”过程中存在的接触点信息。要获得接触点，你可以使用’getContactPoints’ API。请注意，’getContactPoints’将不会重新计算任何接触点信息。</p>
<ul>
<li>getOverlappingObjects<ul>
<li>此查询将返回与给定轴对齐边框重叠的轴对齐边框对象的所有唯一id。注意，该查询是保守的，可能返回没有实际AABB重叠的附加对象。这是因为加速结构有一些启发式，扩大了一点aabb(额外的边缘和挤压沿速度矢量)。</li>
<li>getOverlappingObjects将返回对象惟一id的列表。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>aabbMin</td>
<td>vec3f</td>
<td>aabb最小坐标</td>
</tr>
<tr>
<td>R</td>
<td>aabbMax</td>
<td>vec3f</td>
<td>aabb最大坐标</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>getAABB<ul>
<li>可以查询轴对齐的边界框(在世界空间中)，给定对象唯一id和link索引(可选)。(当不传递link索引，或使用-1，得到的是AABB的base)。</li>
<li>返回的结构是世界空间坐标下的vec3、aabbMin (x,y,z)和aabbMax (x,y,z)的列表。</li>
<li>AABB盒，一个3D的AABB就是一个简单的六面体，每一边都平行于一个坐标平面，矩形边界框不一定都是立方体，它的长、宽、高可以彼此不同。</li>
<li>坐标轴平行（Axially-aligned）不仅指盒体与世界坐标轴平行，同时也指盒体的每个面都和一条坐标轴垂直，这样一个基本信息就能减少转换盒体时操作的次数。</li>
<li><strong>getAABB.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Paramets</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id as returened by creation methods</td>
</tr>
<tr>
<td>O</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引，范围在[0…getNumJoints(..)]</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<ul>
<li>getContactPoints<ul>
<li>getContactPoints API返回在最近的stepSimulation调用中计算的接触点。请注意，如果在stepSimulation之后更改模拟的状态，“getContactPoints”不会被更新，而且可能是无效的。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Paramets</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>O</td>
<td>bodyA</td>
<td>int</td>
<td>只报告涉及A体的接触点</td>
</tr>
<tr>
<td>O</td>
<td>bodyB</td>
<td>int</td>
<td>只报告涉及B体的接触点。重要:如果你提供B体，你需要有一个有效的a体。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>只报告bodyA的linkIndexA接触点</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>只报告涉及bodyB的linkIndexB的接触点</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br><br>getContactPoints将返回一个接触点列表。每个接触点有以下字段:<br><br><br></p>
<table>
<thead>
<tr>
<th>Returned Values</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>contactFlag</td>
<td>int</td>
<td>reserved</td>
</tr>
<tr>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>物体A的Id</td>
</tr>
<tr>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>物体B的Id</td>
</tr>
<tr>
<td>linkIndexA</td>
<td>int</td>
<td>物体A的link索引，-1(base)</td>
</tr>
<tr>
<td>linkIndexB</td>
<td>int</td>
<td>物体B的link索引，-1(base)</td>
</tr>
<tr>
<td>positionOnA</td>
<td>vec3f</td>
<td>在笛卡尔世界坐标下，A上的接触位置</td>
</tr>
<tr>
<td>positionOnB</td>
<td>vec3f</td>
<td>在笛卡尔世界坐标下，B上的接触位置</td>
</tr>
<tr>
<td>contactNormalOnB</td>
<td>vec3f</td>
<td>B上的接触法线，指向A</td>
</tr>
<tr>
<td>contactDistance</td>
<td>float</td>
<td>接触距离，正的用于分离，负的用于渗透</td>
</tr>
<tr>
<td>nornalForce</td>
<td>float</td>
<td>在最后的“stepSimulation”中施加的法向力</td>
</tr>
<tr>
<td>lateralFriction1</td>
<td>float</td>
<td>lateralFrictionDir1方向上的横向摩擦力</td>
</tr>
<tr>
<td>lateralFrictionDir1</td>
<td>vec3f</td>
<td>第一横向摩擦方向</td>
</tr>
<tr>
<td>lateralFriction2</td>
<td>float</td>
<td>lateralFrictionDir2方向上的横向摩擦力</td>
</tr>
</tbody></table>
<p>|<br>|lateralFrictionDir2|float|lateralFrictionDir2方向上的横向摩擦力|<br><br><br></p>
<ul>
<li>getClosestPoints<ul>
<li>它也可以计算最近的点，独立于stepSimulation。这也可以让你用任意的分离距离计算物体的最近点。在这个查询中将没有正常的力报告。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyA</td>
<td>int</td>
<td>第一个物体A的Id</td>
</tr>
<tr>
<td>R</td>
<td>bodyB</td>
<td>int</td>
<td>第二个物体B的Id</td>
</tr>
<tr>
<td>R</td>
<td>distance</td>
<td>float</td>
<td>如果物体之间的距离超过这个最大距离，则不能返回任何点。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>物体A的link索引, -1(base)</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>物体B的link索引, -1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>getClosePoints以与getContactPoints相同的格式返回最近点的列表(但normalForce在这种情况下总是为零)</p>
<ul>
<li>rayTest<ul>
<li>可以执行一个光线投射来找到第一个被击中的物体的交叉信息。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>rayFromPosition</td>
<td>vec3f</td>
<td>从世界坐标的光线开始</td>
</tr>
<tr>
<td>R</td>
<td>rayToPosition</td>
<td>vec3f</td>
<td>射线在世界坐标的末端</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>linkIndex</td>
<td>int</td>
<td>命中对象的link索引，if none/parent，则为-1</td>
</tr>
<tr>
<td>hit fraction</td>
<td>float</td>
<td>沿射线范围[0,1]内沿射线的hit fraction。</td>
</tr>
<tr>
<td>hit position</td>
<td>vec3f</td>
<td>笛卡尔世界坐标系下的hit position</td>
</tr>
<tr>
<td>hit normal</td>
<td>vec3f</td>
<td>笛卡尔世界坐标系下的hit position</td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>rayTestBatch<ul>
<li>这与rayTest类似，但允许提供一个射线数组，以更快地执行。rayFromPositions的大小需要等于rayToPositions的大小。可以每条射线都有一个射线结果，即使没有交集:你需要使用objectUniqueId字段来检查射线是否击中了任何东西:如果objectUniqueId是-1，就没有击中。在这种情况下，“hit fraction”是1。每批射线的最大数量是pybullet.MAX_RAY_INTERSECTION_BATCH_SIZE。</li>
<li>输出是每条输入射线的一条射线相交结果，信息与上面的rayTest查询相同。见 <strong>batchRayTest.py</strong> Demo<br>

</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>rayFromPositions</td>
<td>list of vec3,list of list of 3f</td>
<td>每个射线的起始点的列表，在世界坐标中</td>
</tr>
<tr>
<td>R</td>
<td>rayToPositions</td>
<td>list of vec3,list of list of 3f</td>
<td>每个射线的终点的列表，在世界坐标中</td>
</tr>
<tr>
<td>O</td>
<td>parentObjectUniquedId</td>
<td>int</td>
<td>ray from/to is in local space of a parent object</td>
</tr>
<tr>
<td>O</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>ray from/to is in local space of a parent object</td>
</tr>
<tr>
<td>O</td>
<td>numThreads</td>
<td>int</td>
<td>使用多个线程来计算射线测试(0 =使用所有可用的线程，正数=正好这个线程数，默认=-1 =单线程)</td>
</tr>
<tr>
<td>O</td>
<td>reportHitNumber</td>
<td>int</td>
<td>可以报告第n次hit，而不是第一次hit</td>
</tr>
<tr>
<td>O</td>
<td>collisionFilterMask</td>
<td>int</td>
<td>只有当collisionFilterMask和body collision filter组的按位和之间的值是非零时，才测试命中。请参阅setCollisionFilterGroupMask来了解如何修改主体过滤器的掩码/组。</td>
</tr>
<tr>
<td>O</td>
<td>fractionEpsilon</td>
<td>float</td>
<td>仅在使用reportHitNumber时有用:如果分数与这个fractionEpsilon中的现有命中率相似，则忽略重复命中率。例如，一束射线可能击中一个物体的许多共面三角形，你可能只对其中一个感兴趣。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>getCollisionShapeData<ul>
<li>可以使用此查询查询现有body base和links的碰撞几何类型和其他碰撞形状信息。它的工作原理与getVisualShapeData非常相似。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引,-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>object unique id</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>linkIndex</td>
<td>int</td>
<td>link索引,-1(base)</td>
</tr>
<tr>
<td>geometry type</td>
<td>int</td>
<td>geometry type: GEOM_BOX, GEOM_SPHERE, GEOM_CAPSULE, GEOM_MESH, GEOM_PLANE</td>
</tr>
<tr>
<td>dimensions</td>
<td>vec3</td>
<td>取决于几何类型: <br>for GEOM_BOX: extents,<br> for GEOM_SPHERE dimensions[0] = radius,<br> for GEOM_CAPSULE and GEOM_CYLINDER, dimensions[0] = height (length), dimensions[1] = radius. <br>For GEOM_MESH, dimensions is the scaling factor.</td>
</tr>
<tr>
<td>filename</td>
<td>string</td>
<td>仅用于GEOM_MESH:collision mesh asset的文件名(和路径)</td>
</tr>
<tr>
<td>local frame pos</td>
<td>vec3</td>
<td>碰撞坐标系相对于质心/惯性坐标系的局部位置。</td>
</tr>
<tr>
<td>local frame orn</td>
<td>vec4</td>
<td>碰撞坐标系相对于惯性坐标系的局部方向。</td>
</tr>
</tbody></table>
<ul>
<li><p>Enable/Disable Collisions</p>
<ul>
<li>默认情况下，在不同动态移动的物体之间启用碰撞检测。同一body和links之间的自碰撞可以使用loadURDF中的  <strong>URDF_USE_SELF_COLLISION</strong>标志来启用(参见loadURDF命令获取更多信息)。</li>
<li>可以使用setCollisionFilterGroupMask API来启用和禁用对象组之间的碰撞检测。</li>
</ul>
</li>
<li><p>V-HACD</p>
<ul>
<li>PyBullet包含了一个由Khaled Mamou实现的体积分层近似分解(Volumetric Hierarchical Approximate Decomposition, vhacd)。这可以导入一个concave Wavefront .obj文件，并导出一个新的包含凸分解部分的Wavefront obj文件。这可以在PyBullet中使用，以有效地处理凹面移动几何图形</li>
<li>concave 凹的，凹面的</li>
<li>wavefront  波前；波阵面</li>
<li>对于静态的(非移动的)凹三角形网格环境，你可以在URDF文件中使用标签(<link concave ="yes" name="baseLink">)或使用带有标记的createCollisionShape,标记为p.GEOM_FORCE_CONCAVE_TRIMESH。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>fileNameIn</td>
<td>string</td>
<td>source (concave) Wavefront obj文件名</td>
</tr>
<tr>
<td>R</td>
<td>fileNameOut</td>
<td>string</td>
<td>目标(凸分解)Wavefront obj文件名</td>
</tr>
<tr>
<td>R</td>
<td>fileNameLog</td>
<td>string</td>
<td>日志文件名</td>
</tr>
<tr>
<td>O</td>
<td>concavity</td>
<td>double</td>
<td>最大允许凹度(default=0.0025, range=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>alpha</td>
<td>double</td>
<td>控制沿对称平面剪切的偏向(默认值=0.05，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>beta</td>
<td>double</td>
<td>控制沿旋转轴剪切的偏向(默认值=0.05，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>gamma</td>
<td>double</td>
<td>控制合并阶段允许的最大凹面(默认值=0.00125，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>minVolumePerCH</td>
<td>double</td>
<td>控制对生成的convex-hulls的自适应采样(默认值=0.0001，范围=0.0-0.01)</td>
</tr>
<tr>
<td>O</td>
<td>resolution</td>
<td>int</td>
<td>在体素化阶段生成的最大体素值(默认值=100,000，范围=10,000-16,000,000)</td>
</tr>
</tbody></table>
<p>|O|maxNumVerticesPerCH|int|控制每个convex-hull的最大三角形数(默认为64，范围为4-1024)<br>|O|depth|int|最大剪切段数。在每个分割阶段，凹度高于用户定义阈值的部分将根据最佳裁剪平面进行裁剪(默认为20，范围为1-32)|<br>|O|planeDownsampling|int|控制搜索\“最佳\”剪切平面的间隔尺寸(默认为4，范围为1-16)|<br>|O|convechullDownsamping|int|在剪切平面选择阶段控制convex-hull生成过程的精度(默认值=4，范围=1-16)|<br>|O|pca|int|在应用凸分解之前启用/禁用网格的规格化(默认值=0，范围={0,1})|<br>|O|mode|int|0:基于体素的近似凸分解，1:基于四面体的近似凸分解(默认为0,range={0,1})|<br>|O|convexhullApproximation|int|在计算凸壳时启用/禁用近似(默认值=1，范围={0,1})|<br>|O|physicsClientId|int||<br><br><br></p>
<ul>
<li>setCollisionFilterGroupMask<ul>
<li>每个body都是一个group的一部分。如果其他的body与mask匹配，它就会与之碰撞，反之亦然。下面的检查是使用两个body的group和mask进行的。这取决于碰撞过滤器模式</li>
<li>可以对特定link对之间的碰撞检测进行更细粒度的控制。这里使用setCollisionFilterPair API:可以启用或禁用碰撞检测。setCollisionFilterPair将覆盖过滤组/掩码和其他逻辑。<br>

</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>配置的Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexA</td>
<td>int</td>
<td>需要配置的body的linl索引</td>
</tr>
<tr>
<td>R</td>
<td>collisionFilterGroup</td>
<td>int</td>
<td>过滤器的bitwise group，参见下面的解释</td>
</tr>
<tr>
<td>R</td>
<td>collisionFilterMask</td>
<td>int</td>
<td>过滤器的bitwise mask，参见下面的解释</td>
</tr>
<tr>
<td>O</td>
<td>pyhsicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>setCollisionFilterPair</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>A的Id，被过滤后的</td>
</tr>
<tr>
<td>R</td>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>B的Id，被过滤后的，A==B 意味着自碰撞</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexA</td>
<td>int</td>
<td>linkIndex of body A</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexB</td>
<td>int</td>
<td>linkIndex of body B</td>
</tr>
<tr>
<td>R</td>
<td>enableCollision</td>
<td>int</td>
<td>1表示启用碰撞，0表示禁用碰撞</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<h1 id="6-Inverse-Dynamics-Kinematics"><a href="#6-Inverse-Dynamics-Kinematics" class="headerlink" title="6. Inverse Dynamics, Kinematics"></a>6. Inverse Dynamics, Kinematics</h1><h2 id="6-1-calculateInverseDynamics-2"><a href="#6-1-calculateInverseDynamics-2" class="headerlink" title="6.1 calculateInverseDynamics(2)"></a>6.1 calculateInverseDynamics(2)</h2><p>  calculateInverseDynamics将计算达到给定关节加速度所需的力，从指定的关节位置和速度开始。逆动力学计算使用递推牛顿欧拉算法(RNEA)。<br><br><br><br>  calculateInverseDynamics返回每个自由度的联合力列表。<br>注意，当涉及到多自由度(球形)关节时，calculateInverseDynamics使用不同的代码路径，会稍微慢一些。还要注意的是，calculateInverseDynamics忽略了joint/link阻尼，而正向动力学(在stepSimulation中)包含了这些阻尼项。所以如果想比较逆动力学和正动力学，确保将这些阻尼项设为零，使用带有关节阻尼和线性阻尼和角阻尼的连杆阻尼的变化动力学。</p>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>list of float</td>
<td>每个自由度(DoF)的关节位置(角)。注意，固定关节的自由度为0。base在所有情况下(浮动基座和固定基座)都会被跳过/忽略</td>
</tr>
<tr>
<td>R</td>
<td>objVelocities</td>
<td>list of float</td>
<td>每个自由度的关节速度</td>
</tr>
<tr>
<td>R</td>
<td>objAccelerations</td>
<td>list of float</td>
<td>每个自由度的期望关节加速度</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="6-2-calculateJacobian-MassMatrix"><a href="#6-2-calculateJacobian-MassMatrix" class="headerlink" title="6.2 calculateJacobian, MassMatrix"></a>6.2 calculateJacobian, MassMatrix</h2><ul>
<li>calculateJacobian<ul>
<li>calculateJacobian将计算link上一个点的平移和旋转雅可比矩阵，例如x_dot = J * q_dot。根据root link是固定的还是浮动的，返回的雅可比矩阵略有不同。如果是浮动的，雅可比矩阵将包括对应root link自由度的列;如果固定，雅可比矩阵就只有和joint相关的列。这个函数调用获得了运动学状态的完整描述，这是因为calculateInverseDynamics实际上是首先被调用的，并从中提取出所需的雅可比矩阵;因此，如果需要，通过关节速度和加速度的零向量是合理的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>雅可比矩阵的link索引</td>
</tr>
<tr>
<td>R</td>
<td>localPosition</td>
<td>list of float</td>
<td>给定link上的点，在其质心周围的link局部坐标中计算雅可比矩阵。</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>list of float</td>
<td>joint positions(angles)</td>
</tr>
<tr>
<td>R</td>
<td>objVelocities</td>
<td>list of float</td>
<td>joint velocities</td>
</tr>
<tr>
<td>R</td>
<td>objAccelerations</td>
<td>list of float</td>
<td>期望的joint加速度</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th></th>
<th>CalculateJacobian Returns</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>linear Jacobian</td>
<td>mat3x((dof),(dof),dof))</td>
<td>the translational jacobian, x_dot = J_t * q_dot.</td>
</tr>
<tr>
<td>R</td>
<td>angular Jacobian</td>
<td>mat3x((dof),(dof),dof))</td>
<td>the rotational jacobian, r_dot = J_r * q_dot.</td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>calculateMassMatrix<ul>
<li>calculateMassMatrix将计算一个articulated body给定其joint位置的系统惯性。采用复合刚体算法(CBRA)计算质量矩阵。</li>
<li>Composite Rigid Body Algorithm, CBRA</li>
<li>结果是尺寸为dofCount * dofCount的质量方阵，存储为dofCount行列表，每一行是dofCount质量矩阵元素列表。</li>
<li>注意，当涉及到多自由度(球形)关节时，calculateMassMatrix将使用不同的代码路径，这有点慢。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>array of float</td>
<td>jointPositions for each link</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="6-3-calculateInverseKinematics-2"><a href="#6-3-calculateInverseKinematics-2" class="headerlink" title="6.3 calculateInverseKinematics(2)"></a>6.3 calculateInverseKinematics(2)</h2><ul>
<li><p>Inverse Kinematics</p>
<ul>
<li>你可以计算使末端执行器达到笛卡尔世界空间中给定目标位置的joint angles。在内部，Bullet使用了Samuel Buss逆运动学库的改进版本。针对单末端执行器目标，目前只公开了带或不带零空间控制的阻尼最小二乘方法。</li>
<li>还可以指定末端执行器的目标方向。此外，还可以使用null-space来指定joint limits和rest poses。这个可选的null-space支持需要所有4个列(lowerLimits, upperLimits, jointRanges, restPoses),否则将使用常规的IK。</li>
<li><strong>inverse_kinematics.py</strong></li>
</ul>
</li>
<li><p>calculateInverseKinematics</p>
<ul>
<li>返回每个自由度的关节位置列表，因此这个列表的长度就是关节的自由度(跳过基本关节和固定关节)。</li>
<li>默认情况下，IK将refine解决方案，直到目标执行器与实际执行器之间的距离低于residual阈值(1e-4)或达到最大迭代次数。</li>
<li><strong>inverse_kinematics.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>endEffectorLinkIndex</td>
<td>int</td>
<td>末端执行器的link index</td>
</tr>
<tr>
<td>R</td>
<td>targetPosition</td>
<td>vec3f</td>
<td>末端执行器的目标位置(它的是link坐标,不是质心坐标!)默认情况下，这是在笛卡尔世界空间中，除非你提供了currentPosition joint angles)</td>
</tr>
<tr>
<td>O</td>
<td>targetOrientation</td>
<td>vec3,list of 4 floats</td>
<td>笛卡尔世界空间中的目标方向，四元数[x,y,w,z]。如果未指定，将使用纯位置IK。</td>
</tr>
<tr>
<td>O</td>
<td>lowerLimits</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.只提供有它们的关节的限制(跳过固定关节)，所以长度是自由度的数目.注意，lowerLimits, upperLimits, jointRanges很容易在IK解决方案中引起冲突和不稳定。首先，尝试使用一个广泛的范围和限制，with just the rest pose.</td>
</tr>
<tr>
<td>O</td>
<td>upperLimits</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.lowerLimit and upperLimit 指定 joint limits</td>
</tr>
<tr>
<td>O</td>
<td>jointRanges</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.</td>
</tr>
<tr>
<td>O</td>
<td>restPoses</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.Favor an IK solution closer to a given rest pose</td>
</tr>
<tr>
<td>O</td>
<td>jointDamping</td>
<td>list of floats [0..nDof]</td>
<td>jointDamping允许使用joint阻尼因子来调整IK解决方案</td>
</tr>
<tr>
<td>O</td>
<td>solver</td>
<td>int</td>
<td>p.IK_DLS或p.IK_SDLS，阻尼最小二乘或选择性阻尼最小二乘，如Samuel Buss的论文“逆运动学的选择性阻尼最小二乘”所述。</td>
</tr>
<tr>
<td>O</td>
<td>currentPosition</td>
<td>list of floats [0..nDof]</td>
<td>list of joint  positions.默认情况下，PyBullet使用body的joint位置。如果提供了，the targetPosition and targetOrientation is in local space!</td>
</tr>
<tr>
<td>O</td>
<td>maxNumIterations</td>
<td>int</td>
<td>Refine the IK solution(细化IK解)，直到目标与实际末端执行器位置之间的距离低于这个阈值，或者达到最大迭代次数。默认为20次迭代</td>
</tr>
<tr>
<td>O</td>
<td>residualThreshold</td>
<td>double</td>
<td>Refine the IK solution(细化IK解)，直到目标与实际末端执行器位置之间的距离低于这个阈值，或者达到最大迭代次数。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>calculateInverseKinematics2<ul>
<li>类似于calculateInverseKinematics，但它接受一组末端执行器索引及其目标位置(此刻没有方向)。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>endEffectorLinkIndics</td>
<td>list of int</td>
<td>end effector link index</td>
</tr>
<tr>
<td>R</td>
<td>targetPositions</td>
<td>list of vec3</td>
<td>末端执行器的目标位置(它的link坐标，而不是质心坐标!)默认情况下，这是在笛卡尔世界空间中，除非你提供了currentPosition joint angles。</td>
</tr>
<tr>
<td>…</td>
<td>For other arguments,see calculateInverseSknematics</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><br><br></p>
]]></content>
      <categories>
        <category>机器人仿真</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>教程</tag>
        <tag>PyBullet</tag>
        <tag>机器人仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 1.ROS概览</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%201.ROS%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="一、ROS-概览"><a href="#一、ROS-概览" class="headerlink" title="一、ROS 概览"></a>一、ROS 概览</h1><h2 id="1-1-ROS是什么？"><a href="#1-1-ROS是什么？" class="headerlink" title="1. 1 ROS是什么？"></a>1. 1 ROS是什么？</h2><p>ROS = 通信机制+开发工具+应用功能+生态系统</p>
<h2 id="1-2-ROS的通信机制"><a href="#1-2-ROS的通信机制" class="headerlink" title="1.2 ROS的通信机制"></a>1.2 ROS的通信机制</h2><h3 id="（1）核心概念"><a href="#（1）核心概念" class="headerlink" title="（1）核心概念"></a>（1）核心概念</h3><ul>
<li>节点 Node —— 软件模块</li>
<li>节点管理器 ROS Master —— 控制中心，提供参数管理</li>
<li>话题 Topic —— 异步通讯机制，传输消息 （Message）</li>
<li>服务 Service —— 同步通信机制，传输请求 / 应答数据</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122150638.png" alt=""></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122151047.png" alt=""></p>
<h3 id="（2）话题通信模型"><a href="#（2）话题通信模型" class="headerlink" title="（2）话题通信模型"></a>（2）话题通信模型</h3><ul>
<li>Talker注册</li>
<li>Listener注册</li>
<li>ROS Master进行信息匹配</li>
<li>Listener发送连接请求</li>
<li>Talker确认连接请求</li>
<li>建立网络连接</li>
<li>Talker向Listener发布数据</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122152256.png" alt="image-20201122152256520"></p>
<h3 id="（3）服务通信模型"><a href="#（3）服务通信模型" class="headerlink" title="（3）服务通信模型"></a>（3）服务通信模型</h3><ul>
<li>Talker注册</li>
<li>Listener注册</li>
<li>ROS Master进行信息匹配</li>
<li>建立网络连接</li>
<li>Talker向Listener发布服务应答数据</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122152530.png" alt="image-20201122152530468"></p>
<h3 id="4-动作"><a href="#4-动作" class="headerlink" title="(4) 动作"></a>(4) 动作</h3><h4 id="什么是动作-Action？"><a href="#什么是动作-Action？" class="headerlink" title="什么是动作 Action？"></a>什么是动作 Action？</h4><ul>
<li>一种问答通信机制</li>
<li>带有连续反馈</li>
<li>可以在任务过程中止运行</li>
<li>基于ROS的消息机制实现</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122153222.png" alt="image-20201122153222680"></p>
<h4 id="Action的接口"><a href="#Action的接口" class="headerlink" title="Action的接口"></a>Action的接口</h4><ul>
<li>goal：发布任务目标</li>
<li>cancel：请求取消任务</li>
<li>status：通知客户端当前的状态</li>
<li>feedback：周期反馈任务运行的监控数据</li>
<li>result：向客户端发送任务的执行结果，只发布一次。</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122153233.png" alt="image-20201122153233168" style="zoom: 50%;" />

<p><br><br></p>
<h2 id="1-3-ROS的开发工具"><a href="#1-3-ROS的开发工具" class="headerlink" title="1.3 ROS的开发工具"></a>1.3 ROS的开发工具</h2><h3 id="（1）命令行-amp-编译器"><a href="#（1）命令行-amp-编译器" class="headerlink" title="（1）命令行&amp;编译器"></a>（1）命令行&amp;编译器</h3><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201122153704.png" alt="image-20201122153704540"></p>
<h3 id="（2）Launch启动文件"><a href="#（2）Launch启动文件" class="headerlink" title="（2）Launch启动文件"></a>（2）Launch启动文件</h3><p>通过XML文件实现多节点的配置和启动（可自动启动ROS Master）</p>
<h3 id="（3）TF坐标变换库"><a href="#（3）TF坐标变换库" class="headerlink" title="（3）TF坐标变换库"></a>（3）TF坐标变换库</h3><h3 id="（4）Qt工具箱"><a href="#（4）Qt工具箱" class="headerlink" title="（4）Qt工具箱"></a>（4）Qt工具箱</h3><h3 id="（5）Rviz"><a href="#（5）Rviz" class="headerlink" title="（5）Rviz"></a>（5）Rviz</h3><p>三维可视化工具，可以很好的兼容基于ROS软件框架的机器人平台</p>
<h3 id="（6）Gazebo"><a href="#（6）Gazebo" class="headerlink" title="（6）Gazebo"></a>（6）Gazebo</h3><p>Gazebo是一款功能强大的三维物理仿真平台</p>
<h2 id="1-4-ROS的应用功能"><a href="#1-4-ROS的应用功能" class="headerlink" title="1.4 ROS的应用功能"></a>1.4 ROS的应用功能</h2><ul>
<li>导航框架</li>
<li>SLAM</li>
<li>MoveIt！</li>
<li>SMACH任务级状态机</li>
</ul>
<h2 id="1-5-ROS-生态系统"><a href="#1-5-ROS-生态系统" class="headerlink" title="1.5 ROS 生态系统"></a>1.5 ROS 生态系统</h2><ul>
<li>发行版 Distribution</li>
<li>软件源 Repository</li>
<li>ROS wiki</li>
<li>邮件列表</li>
<li>ROS Answers</li>
<li>博客 <a href="http://www.ros.org/news" target="_blank" rel="noopener">www.ros.org/news</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>PyBullet Quickstart Guide 官方文档翻译 7 - Reinforcement Learning Gym Envs | 8 - Virtual Reality | 9 - Debug GUI, Lines, Text, Parameters</title>
    <url>/2021/05/31/PyBullet3/</url>
    <content><![CDATA[<h1 id="7-Reinforcement-Learning-Gym-Envs"><a href="#7-Reinforcement-Learning-Gym-Envs" class="headerlink" title="7. Reinforcement Learning Gym Envs"></a>7. Reinforcement Learning Gym Envs</h1><p>在“pip install pybullet”期间安装了一套RL Gym环境。这包括PyBullet版本的OpenAI Gym Env，如ant, hopper, humanoid和walker。还有一些环境适用于模拟和真实的机器人，如Ghost<br>Robotics Minitaur quadruped，麻省理工赛车和库卡机器人手臂抓取环境。<br><br><br>pybullet, pybullet_envs, pybullet_data的源代码和示例: <a href="https://github.com/bulletphysics/bullet3/tree/master/examples/pybullet/gym" target="_blank" rel="noopener">https://github.com/bulletphysics/bullet3/tree/master/examples/pybullet/gym</a>.<br><br><br><br>可以使用RL训练算法来训练环境，例如DQN、PPO、TRPO和<br>DDPG。以下是一些经过训练的例子:<br><strong>python -m pybullet_envs.examples.enjoy_TF_HumanoidBulletEnv_v0_2017may</strong><br><strong>python -m pybullet_envs.examples.kukaGymEnvTest</strong></p>
<h2 id="7-1-Environments-and-Data"><a href="#7-1-Environments-and-Data" class="headerlink" title="7.1 Environments and Data"></a>7.1 Environments and Data</h2><h2 id="7-2-Stable-Baselines-amp-ARS-Es-…"><a href="#7-2-Stable-Baselines-amp-ARS-Es-…" class="headerlink" title="7.2 Stable Baselines &amp; ARS,Es,…"></a>7.2 Stable Baselines &amp; ARS,Es,…</h2><h1 id="8-Virtual-Reality"><a href="#8-Virtual-Reality" class="headerlink" title="8. Virtual Reality"></a>8. Virtual Reality</h1><h1 id="9-Debug-GUI-Lines-Text-Parameters"><a href="#9-Debug-GUI-Lines-Text-Parameters" class="headerlink" title="9. Debug GUI, Lines, Text, Parameters"></a>9. Debug GUI, Lines, Text, Parameters</h1><p>PyBullet有一些功能，可以更容易地调试、可视化和调优模拟。<br>这个功能只有在有一些3D可视化窗口时才有用，例如GUI模式或连接到单独的物理服务器(例如“物理服务器”模式的浏览器或独立的OpenGL GUI物理服务器)。</p>
<h2 id="9-1-addUserDebugLine-Text-Parameter"><a href="#9-1-addUserDebugLine-Text-Parameter" class="headerlink" title="9.1 addUserDebugLine, Text, Parameter"></a>9.1 addUserDebugLine, Text, Parameter</h2><ul>
<li>addUserDebugline  <ul>
<li>可以添加由3d起始点(从)和结束点(到)指定的3d线条，以及颜色<br>(红、绿、蓝)，线宽和持续时间(以秒为单位)。</li>
<li>addUserDebugLine将返回一个非负的唯一id，它允许使用removeUserDebugItem删除这个line。(当使用’replaceItemUniqueId’参数时，它将返回replaceItemUniqueId)。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>lineFromXYZ</td>
<td>vec3f</td>
<td>直线在笛卡尔世界坐标中的起始点</td>
</tr>
<tr>
<td>R</td>
<td>lineToXYZ</td>
<td>vec3f</td>
<td>直线在笛卡尔世界坐标中的终点</td>
</tr>
<tr>
<td>O</td>
<td>lineColorRGB</td>
<td>vec3f</td>
<td>RGB颜色[红、绿、蓝]范围内各分量</td>
</tr>
<tr>
<td>(0…1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>lineWidth</td>
<td>float</td>
<td>线宽(受OpenGL实现限制)</td>
</tr>
<tr>
<td>O</td>
<td>lifeTime</td>
<td>float</td>
<td>使用0为永久线路，或正时间秒</td>
</tr>
<tr>
<td>(之后会自动删除一行)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>parentObjectUniqueId</td>
<td>int</td>
<td>即将到来的PyBullet 1.0.8新增功能:在parent object/link局部坐标中绘制直线。</td>
</tr>
<tr>
<td>O</td>
<td>replaceItemUniqueId</td>
<td>int</td>
<td>替换现有的line(以提高性能和避免移除/添加的闪烁)参见<strong>f10_racecar.py</strong>示例。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>addUserDebugText<ul>
<li>可以使用颜色和大小在特定位置添加一些3d文本</li>
<li>addUserDebugText将返回一个非负的唯一id，它允许你使用removeUserDebugItem删除行</li>
<li>See also <strong>pybullet/examples/debugDrawItems.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>text</td>
<td>text</td>
<td>表示为字符串(字符数组)的文本</td>
</tr>
<tr>
<td>R</td>
<td>textPosition</td>
<td>vec3f</td>
<td>文本在笛卡尔世界坐标中的三维位置[x, y, z]</td>
</tr>
<tr>
<td>O</td>
<td>textColorRGB</td>
<td>vec3f</td>
<td>RGB颜色[红、绿、蓝]范围内各分量(0 . . 1)</td>
</tr>
<tr>
<td>O</td>
<td>textSize</td>
<td>float</td>
<td>Text大小</td>
</tr>
<tr>
<td>O</td>
<td>lifeTime</td>
<td>float</td>
<td>为永久文本使用0，或以秒为单位的正时间(之后文本将自动删除)</td>
</tr>
<tr>
<td>O</td>
<td>textOrientation</td>
<td>vec4f</td>
<td>默认情况下，调试文本将始终面向摄像头，自动旋转。通过指定文本方向(四元数)，定向将固定在世界空间或局部空间(当parent指定时)。注意，不同的实现/着色器用于面向摄像机的文本，具有不同的外观:面向摄像机的文本使用位图字体，指定方向的文本使用TrueType字体。</td>
</tr>
<tr>
<td>O</td>
<td>parentObjectUniquedId</td>
<td>int</td>
<td>即将到来的PyBullet 1.0.8新增功能:在parent object/link的局部坐标中绘制直线。</td>
</tr>
<tr>
<td>O</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>即将到来的PyBullet 1.0.8新增功能:在parent object/link的局部坐标中绘制直线。</td>
</tr>
<tr>
<td>O</td>
<td>replaceItemUniqueId</td>
<td>int</td>
<td>替换现有的文本项(以避免移除/添加的闪烁)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>addUserDebugParameter<ul>
<li>：addUserDebugParameter允许你添加自定义滑块和按钮来调整参数。它将返回一个唯一的id。这使用readUserDebugParameter读取参数的值。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>paramName</td>
<td>string</td>
<td>参数名</td>
</tr>
<tr>
<td>R</td>
<td>rangeMin</td>
<td>float</td>
<td>最小值。如果最小值&gt;最大值将出现一个按钮而不是滑块</td>
</tr>
<tr>
<td>R</td>
<td>rangeMax</td>
<td>float</td>
<td>最大值</td>
</tr>
<tr>
<td>R</td>
<td>startValue</td>
<td>float</td>
<td>开始值</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>readUserDebugParameter<ul>
<li>对于滑块，返回值是该参数的最新读取值。对于按钮，每按一次按钮，按钮的getUserDebugParameter的值增加1。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>itemUniqueId</td>
<td>int</td>
<td>由’addUserDebugParameter’返回的唯一id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.addUserDebugParameter(<span class="string">"button"</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">p.addUserDebugParameter(<span class="string">"my_slider"</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><p>removeAllUserParameters</p>
<ul>
<li>这将删除所有滑块和按钮</li>
<li>| O | physicsClient | int | … |</li>
</ul>
</li>
<li><p>removeUserDebugItem/All</p>
<ul>
<li>函数添加user debug lines ，如果成功，文本将返回一个非负的唯一id。可以使用removeUserDebugItem这个惟一id删除调试项</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>itemUniquedId</td>
<td>int</td>
<td>要删除的调试项的唯一id(line, text etc)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>removeAllUserDebugItems</p>
<ul>
<li>删除所有debug items (text, lines etc)</li>
</ul>
</li>
<li><p>setDebugObjectColor</p>
<ul>
<li>内置的OpenGL可视化工具有一个线框调试渲染特性:按“w”键切换。<br>线框有一些默认颜色。可以使用setDebugObjectColor覆盖特定对象的颜色和link</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link 索引</td>
</tr>
<tr>
<td>O</td>
<td>objectDebugColorRGB</td>
<td>vec3f</td>
<td>调试颜色为[红，绿，蓝]。如果不提供，自定义颜色将被删除。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClient</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<h2 id="9-2-addUserData"><a href="#9-2-addUserData" class="headerlink" title="9.2 addUserData"></a>9.2 addUserData</h2><ul>
<li><p>addUserData</p>
<ul>
<li>简而言之，添加、删除和查询用户数据，此时文本字符串，附加到主体的任何链接上。请参阅userData.py示例了解如何使用它。它将返回一个userDataId。注意，您还可以在urdf文件中添加用户数据。</li>
</ul>
</li>
<li><p>getUserData</p>
<ul>
<li>getUserData将根据addUserData返回的userDataId接收用户数据。</li>
<li><strong>userData.py</strong></li>
</ul>
</li>
<li><p>syncUserData</p>
<ul>
<li>syncUserData将在多个客户端更改用户数据(addUserData等)的情况下同步用户数据(getUserData)。</li>
</ul>
</li>
<li><p>removeUserData</p>
<ul>
<li>给定userDataId, removeUserData将删除先前添加的用户数据。</li>
</ul>
</li>
<li><p>getUserDataId and getNumUserData</p>
<ul>
<li>getNumUserData将根据bodyUniqueId返回用户数据条目的数量。</li>
</ul>
</li>
<li><p>getUserDataInfo</p>
<ul>
<li>getUserDataInfo检索用户数据的键和标识符为(userDataId, key, bodyUniqueId, linkIndex, visualShapeIndex)</li>
</ul>
</li>
</ul>
<h2 id="9-3-configureDebugVisualizer"><a href="#9-3-configureDebugVisualizer" class="headerlink" title="9.3 configureDebugVisualizer"></a>9.3 configureDebugVisualizer</h2><ul>
<li>configureDebugVisualizer<ul>
<li>可以配置一些内置OpenGL可视化工具的设置，例如启用或禁用线框图、阴影和GUI渲染。这是非常有用的，因为一些笔记本电脑或桌面gui与我们的OpenGL 3可视化工具有性能问题</li>
<li>pybullet.configureDebugVisualizer(pybullet.COV_ENABLE_WIREFRAME,1)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>flag</td>
<td>int</td>
<td>要启用或禁用的功能:such as <br>COV_ENABLE_WIREFRAME,<br>COV_ENABLE_SHADOWS,<br>COV_ENABLE_GUI,COV_ENABLE_VR_PICKING,<br> COV_ENABLE_VR_TELEPORTING,<br>COV_ENABLE_RENDERING,<br> COV_ENABLE_TINY_RENDERER,<br>COV_ENABLE_VR_RENDER_CONTROLLERS,<br>COV_ENABLE_KEYBOARD_SHORTCUTS,<br>COV_ENABLE_MOUSE_PICKING,<br>COV_ENABLE_Y_AXIS_UP (Z is default world up axis),<br>COV_ENABLE_RGB_BUFFER_PREVIEW,<br>COV_ENABLE_DEPTH_BUFFER_PREVIEW,<br>COV_ENABLE_SEGMENTATION_MARK_PREVIEW</td>
</tr>
<tr>
<td>R</td>
<td>enable</td>
<td>int</td>
<td>0 or 1</td>
</tr>
<tr>
<td>O</td>
<td>lightPosition</td>
<td>vec3</td>
<td>visualizer的灯光位置</td>
</tr>
<tr>
<td>O</td>
<td>shadowMapResolution</td>
<td>int</td>
<td>阴影贴图纹理的大小，对于许多gpu来说通常是power of 2。默认是4096。现代gpu可以处理16384或32768或更高</td>
</tr>
<tr>
<td>O</td>
<td>shadowMapWorldSize</td>
<td>int</td>
<td>阴影地图在世界空间的大小(单位为米，默认为10)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="9-4-get-resetDebugVisualizerCamera"><a href="#9-4-get-resetDebugVisualizerCamera" class="headerlink" title="9.4 get/resetDebugVisualizerCamera"></a>9.4 get/resetDebugVisualizerCamera</h2><ul>
<li><p>get/resetDebugVisualizerCamera</p>
<ul>
<li>Warning:getDebugVisualizerCamera的返回参数与resetDebugVisualizerCamera的返回参数顺序不同。将在未来的API修订版(主要的新版本)中修复</li>
</ul>
</li>
<li><p>resetDebugVisualizerCamera</p>
<ul>
<li>可以重置3D OpenGL调试visualizer摄像机距离(眼睛和摄像机目标位置之间)，摄像机偏航和俯仰和摄像机目标位置。</li>
<li>pybullet.resetDebugVisualizerCamera( cameraDistance=3, cameraYaw=30,<br>cameraPitch=52, cameraTargetPosition=[0,0,0])</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraDistance</td>
<td>float</td>
<td>从eye到camera目标位置的距离</td>
</tr>
<tr>
<td>R</td>
<td>cameraYaw</td>
<td>float</td>
<td>相机yaw(偏移)角度(以角度表示)左右</td>
</tr>
<tr>
<td>R</td>
<td>cameraPitch</td>
<td>float</td>
<td>摄像机Pitch(俯仰)角度(以度表示)向上/向下</td>
</tr>
<tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>vec3f</td>
<td>cameraTargetPosition是相机的焦点</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>getDebugVisualizerCamera<ul>
<li>可以得到相机的宽度和高度(以像素为单位)，它的视图和投影矩阵使用这个命令。输入参数是可选的physicsClientId,输出信息见下表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>int</td>
<td>相机图像的像素宽度</td>
</tr>
<tr>
<td>height</td>
<td>int</td>
<td>相机图像的像素高度</td>
</tr>
<tr>
<td>viewMatrix</td>
<td>float16,list of 16 floats</td>
<td>相机的view matrix</td>
</tr>
<tr>
<td>projectionMatrix</td>
<td>float16,list of 16 floats</td>
<td>相机投影矩阵</td>
</tr>
<tr>
<td>cameraUp</td>
<td>float3,list of 3 floats</td>
<td>相机的上轴，在笛卡尔世界空间坐标中</td>
</tr>
<tr>
<td>cameraForward</td>
<td>float3,list of 3 floats</td>
<td>相机的前轴，在笛卡尔世界空间坐标</td>
</tr>
<tr>
<td>horizontal</td>
<td>float3,list of 3 floats</td>
<td>TBD。这是一个水平矢量，可以用来生成射线(例如，用于鼠标选择或创建一个简单的射线跟踪器)</td>
</tr>
<tr>
<td>vertical</td>
<td>float3,list of 3 floats</td>
<td>：TBD。这是一个垂直矢量，可以用来生成射线(例如，鼠标选择或创建一个简单的射线追踪器)。</td>
</tr>
<tr>
<td>yaw</td>
<td>float</td>
<td>相机的偏移角，在笛卡尔局部空间坐标中</td>
</tr>
<tr>
<td>pitch</td>
<td>float</td>
<td>相机俯仰角，在笛卡尔局部空间坐标中</td>
</tr>
<tr>
<td>dist</td>
<td>float</td>
<td>相机与相机目标之间的距离</td>
</tr>
<tr>
<td>target</td>
<td>float3,list of 3 floats</td>
<td>相机的目标，在笛卡尔世界空间坐标</td>
</tr>
</tbody></table>
<p><br><br></p>
<h2 id="9-5-getKeyboardEvents-getMouseEvents"><a href="#9-5-getKeyboardEvents-getMouseEvents" class="headerlink" title="9.5 getKeyboardEvents, getMouseEvents"></a>9.5 getKeyboardEvents, getMouseEvents</h2><ul>
<li>getKeyboardEvents<ul>
<li>调用getKeyboardEvents可以接收自上次调用以来发生的所有键盘事件,每个事件有一个键码和状态，状态是位标志KEY_IS_DOWN, KEY_WAS_TRIGGERED 和 KEY_WAS_RELEASED的组合，如果键盘是from up to down状态，会接收到KEY_IS_DOWN和KEY_WAS_TRIGGERED状态，如果键盘已经被按下，然后松开，会接收到KEY_IS_DOWN和KEY_WAS_RELEASED状态</li>
<li>定义了一些特殊的键：B3G_F1 … B3G_F12, B3G_LEFT_ARROW,B3G_RIGHT_ARROW, B3G_UP_ARROW, B3G_DOWN_ARROW, B3G_PAGE_UP,B3G_PAGE_DOWN, B3G_PAGE_END, B3G_HOME, B3G_DELETE, B3G_INSERT,B3G_ALT, B3G_SHIFT, B3G_CONTROL, B3G_RETURN.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>…</td>
</tr>
</tbody></table>
<p><br><br><br><strong>输出是一个keycode ‘key’和键盘状态’value’的字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qKey = ord(<span class="string">'q'</span>)</span><br><span class="line">keys = p.getKeyboardEvents()</span><br><span class="line"><span class="keyword">if</span> qKey <span class="keyword">in</span> keys <span class="keyword">and</span> keys[qKey]&amp;p.KEY_WAS_TRIGGERED:</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>getMouseEvents<ul>
<li>与getKeyboardEvents类似，可以获得自上次调用getMouseEvents以来发生的鼠标事件。所有鼠标移动事件合并到一个最新位置的单个鼠标移动事件中。此外，给定按钮的所有鼠标按钮事件将被合并。如果一个按钮向下和向上，状态将是’KEY_WAS_TRIGGERED ‘。对于鼠标按钮状态，我们重用KEY_WAS_TRIGGERED /KEY_IS_DOWN /KEY_WAS_RELEASED。</li>
<li>输入参数只有 | O | physicsClient | int | … |</li>
<li>See <strong>createVisualShape.py</strong> for an example of mouse events, to select/color objects.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>eventType</td>
<td>int</td>
<td>MOUSE_MOVE_EVENT=1, MOUSE_BUTTON_EVENT=2</td>
</tr>
<tr>
<td>mousePosX</td>
<td>float</td>
<td>鼠标指针的x坐标</td>
</tr>
<tr>
<td>mousePosY</td>
<td>float</td>
<td>鼠标指针的y坐标</td>
</tr>
<tr>
<td>buttonIndex</td>
<td>int</td>
<td>鼠标左键/中键/右键索引</td>
</tr>
<tr>
<td>buttonState</td>
<td>int</td>
<td>：flag KEY_WAS_TRIGGERED / KEY_IS_DOWN / KEY_WAS_RELEASED</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器人仿真</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>教程</tag>
        <tag>PyBullet</tag>
        <tag>机器人仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 2.ROS机器人建模</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%202.ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h1 id="二、ROS机器人建模"><a href="#二、ROS机器人建模" class="headerlink" title="二、ROS机器人建模"></a>二、ROS机器人建模</h1><h2 id="2-1-URDF建模原理"><a href="#2-1-URDF建模原理" class="headerlink" title="2.1 URDF建模原理"></a>2.1 URDF建模原理</h2><ul>
<li>URDF：一种使用XML格式描述的机器人模型文件<ul>
<li>Links：坐标系与几何关系</li>
<li>Joints：Links之间的连接关系</li>
</ul>
</li>
<li>类似于D-H参数</li>
<li>可以描述完整的工作空间，不局限于机器人</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201123091535.png" alt="image-20201123091535476" style="zoom: 80%;" />

<h3 id="lt-link-gt-标签"><a href="#lt-link-gt-标签" class="headerlink" title="&lt;link&gt;标签"></a>&lt;link&gt;标签</h3><ul>
<li>描述机器人某个刚体部分的外观和物理属性</li>
<li>描述连杆尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix），碰撞参数（collision properties）等</li>
<li>每个Link会成为一个坐标系, xyz单位是米, rpy单位是弧度</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span> = <span class="string">"link_4"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">mesh</span> <span class="attr">filename</span>=<span class="string">"link_4.stl"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">"0.5"</span> <span class="attr">radius</span>=<span class="string">"0.1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 -0.05"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201123092304.png" alt="image-20201123092304901" style="zoom:80%;" />

<h3 id="lt-joint-gt-标签"><a href="#lt-joint-gt-标签" class="headerlink" title="&lt;joint&gt;标签"></a>&lt;joint&gt;标签</h3><ul>
<li>描述两个link之间的关系，分六种类型</li>
</ul>
<table>
<thead>
<tr>
<th>关节类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>continuous</td>
<td align="left">旋转关节，可以围绕单轴无线旋转，常用。</td>
</tr>
<tr>
<td>revolute</td>
<td align="left">旋转关节，类似于continuous，但是又旋转的角度极限，常用。</td>
</tr>
<tr>
<td>prismatic</td>
<td align="left">滑动关机，沿某一轴线移动的关节，带有位置极限，常用。</td>
</tr>
<tr>
<td>planar</td>
<td align="left">平面关节，允许在平面正交方向上平移或者旋转，不常用。</td>
</tr>
<tr>
<td>floating</td>
<td align="left">浮动关节，允许进行平移、旋转运动，不常用。</td>
</tr>
<tr>
<td>fixed</td>
<td align="left">固定关节，不允许运动的特殊关节，比如把相机固定在机器人上。</td>
</tr>
</tbody></table>
<ul>
<li>包括关节运动的位置和速度限制</li>
<li>描述机器人关节的运动学和动力学属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"joint_2"</span> <span class="attr">type</span>=<span class="string">"revolute"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">"link_1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">"link_2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0.2 0.2 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">limit</span> <span class="attr">lower</span>=<span class="string">"-3.14"</span> <span class="attr">upper</span>=<span class="string">"3.14"</span> <span class="attr">velocity</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- origin表示两个坐标的位置关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- axis表示围绕哪个轴做旋转，0 0 1 表示选中z轴 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- velocity的单位是 弧度每秒 或 米每秒 --&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201123093706.png" alt="image-20201123093706498" style="zoom:80%;" />

<h3 id="lt-robot-gt-标签"><a href="#lt-robot-gt-标签" class="headerlink" title="&lt;robot&gt;标签"></a>&lt;robot&gt;标签</h3><ul>
<li><p>完整机器人模型的最顶层标签</p>
</li>
<li><p>&lt;link&gt; 和 &lt;joint&gt;标签都必须包含在&lt;robot&gt;标签内</p>
</li>
<li><p>一个完整的机器人模型，由一系列&lt;link&gt; 和 &lt;joint&gt;组成</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">"&lt;name of the robot&gt;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="URDF-建模存在一些问题："><a href="#URDF-建模存在一些问题：" class="headerlink" title="URDF 建模存在一些问题："></a>URDF 建模存在一些问题：</h3><ul>
<li><p>模型冗长，重复内容多</p>
</li>
<li><p>参数修改麻烦，不利于二次开发</p>
</li>
<li><p>没用参数计算的功能</p>
<p>….</p>
</li>
</ul>
<h2 id="2-2-URDF模型的进化版本-——-xacro模型文件"><a href="#2-2-URDF模型的进化版本-——-xacro模型文件" class="headerlink" title="2.2 URDF模型的进化版本 —— xacro模型文件"></a>2.2 URDF模型的进化版本 —— xacro模型文件</h2><ul>
<li>精简模型代码</li>
<li>提供可编程接口</li>
</ul>
<h3 id="使用常量定义"><a href="#使用常量定义" class="headerlink" title="使用常量定义"></a>使用常量定义</h3><ul>
<li><p>常量定义 <code>&lt;xacro:property name=&quot;M_PI&quot; value=&quot;3.14159&quot;/&gt;</code></p>
</li>
<li><p>常量使用 <code>&lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;${M_PI/2} 0 0&quot;/&gt;</code></p>
</li>
</ul>
<h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><p>两个轮子间的距离可以通过底盘的尺寸计算</p>
<p><code>origin xyz=&quot;0 ${(motor_length+wheel_length)/2} 0&quot; rpy=&quot;0 0 0&quot;/&gt;</code></p>
<h3 id="使用宏定义声明重复使用的代码模块"><a href="#使用宏定义声明重复使用的代码模块" class="headerlink" title="使用宏定义声明重复使用的代码模块"></a>使用宏定义声明重复使用的代码模块</h3><ul>
<li>宏定义</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">params</span>=<span class="string">"A B C"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>宏调用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">A</span>=<span class="string">"A_value"</span> <span class="attr">B</span>=<span class="string">"B_value"</span> <span class="attr">C</span>=<span class="string">"C_value"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p><code>&lt;xacro:include filename=&quot;$(find mbot_description)/urdf/xacro/mbot_base.xacro&quot;/&gt;</code></p>
<h2 id="2-3-机械臂URDF建模"><a href="#2-3-机械臂URDF建模" class="headerlink" title="2.3 机械臂URDF建模"></a>2.3 机械臂URDF建模</h2><h2 id="2-4-三维模型导出URDF"><a href="#2-4-三维模型导出URDF" class="headerlink" title="2.4 三维模型导出URDF"></a>2.4 三维模型导出URDF</h2>]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 3.MoveIt！入门</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%203.MoveIt!%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="三、MoveIt！入门"><a href="#三、MoveIt！入门" class="headerlink" title="三、MoveIt！入门"></a>三、MoveIt！入门</h1><h2 id="3-1-MoveIt！简介"><a href="#3-1-MoveIt！简介" class="headerlink" title="3.1 MoveIt！简介"></a>3.1 MoveIt！简介</h2><p><a href="http://moveit.ros.org" target="_blank" rel="noopener">MoveIt官方教程</a></p>
<h3 id="MoveIt-三大核心功能"><a href="#MoveIt-三大核心功能" class="headerlink" title="MoveIt! 三大核心功能"></a>MoveIt! 三大核心功能</h3><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201126161937.png" alt="image-20201126161937539" style="zoom:80%;" />

<ul>
<li>运动学：KDL、Trac-IK、IKFast ……</li>
<li>路径规划：OMPL、CHOMP、SBPL ……</li>
<li>碰撞检测：FCL、PCD ……</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201126162124.png" alt="image-20201126162124713"></p>
<h3 id="MoveIt-核心节点-——-move-group"><a href="#MoveIt-核心节点-——-move-group" class="headerlink" title="MoveIt! 核心节点 —— move_group"></a>MoveIt! 核心节点 —— move_group</h3><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201126162506.png" alt="image-20201126162506043"></p>
<ul>
<li>用户接口（User Interface）<ul>
<li>C++：使用move_group_interface包提供的API</li>
<li>Python：使用moveit_commander包提供的API</li>
<li>GUI：使用MoveIt！的rviz插件</li>
</ul>
</li>
<li>ROS参数服务器<ul>
<li>URDF：robot_description参数，获取机器人URDF模型的描述信息</li>
<li>SRDF：robot_description_semantic参数，获取机器人模型的配置信息</li>
<li>config：机器人的其他配置信息，例如关节限位、运动学插件、运动规插件等</li>
</ul>
</li>
<li>机器人<ul>
<li>Topic和Action通信</li>
</ul>
</li>
</ul>
<h3 id="使用MoveIt！"><a href="#使用MoveIt！" class="headerlink" title="使用MoveIt！"></a>使用MoveIt！</h3><ul>
<li><p>组装：创建机器人URDF模型</p>
</li>
<li><p>配置：使用MoveIt！Setup Assistant工具生成配置文件</p>
</li>
<li><p>驱动：添加机器人控制器插件（controller）</p>
</li>
<li><p>控制：MoveIt！控制机器人运动（算法仿真、物理仿真）</p>
</li>
</ul>
<br>

<br>

<h2 id="3-2-MoveIt！可视化配置"><a href="#3-2-MoveIt！可视化配置" class="headerlink" title="3.2 MoveIt！可视化配置"></a>3.2 MoveIt！可视化配置</h2><br>

<h3 id="MoveIt！安装命令："><a href="#MoveIt！安装命令：" class="headerlink" title="MoveIt！安装命令："></a>MoveIt！安装命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ros-kinetic-moveit</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="moveit-setup-assistant"><a href="#moveit-setup-assistant" class="headerlink" title="moveit_setup_assistant"></a>moveit_setup_assistant</h3><h4 id="（1）启动Setup-Assistant"><a href="#（1）启动Setup-Assistant" class="headerlink" title="（1）启动Setup Assistant"></a>（1）启动Setup Assistant</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rosrun moveit_setup_assistant moveit_setup_assistant</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127134502.png" alt="image-20201127134455554" style="zoom:80%;" />

<h4 id="（2）Start"><a href="#（2）Start" class="headerlink" title="（2）Start"></a>（2）Start</h4><ul>
<li>Create New MoveIt Configuration Package 创建新的功能包</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127134902.png" alt="image-20201127134902864" style="zoom:80%;" />

<ul>
<li>点击Browse选择xacro或urdf文件后，点击Load Files，可以在右方加载出机械臂模型。</li>
</ul>
<h4 id="（3）-Self-Collisions-自碰撞检测"><a href="#（3）-Self-Collisions-自碰撞检测" class="headerlink" title="（3） Self-Collisions 自碰撞检测"></a>（3） Self-Collisions 自碰撞检测</h4><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127145058.png" alt="image-20201127145058316" style="zoom:80%;" />

<ul>
<li>检测两个link在运动中是否会发生碰撞，点击Generate Collision Martrix生成碰撞矩阵，采样点选择默认的10000即可（官方推荐）</li>
</ul>
<h4 id="（4）Virtual-Joints-虚拟关节"><a href="#（4）Virtual-Joints-虚拟关节" class="headerlink" title="（4）Virtual Joints 虚拟关节"></a>（4）Virtual Joints 虚拟关节</h4><ul>
<li>虚拟关节主要用来描述机器人在world坐标系下的位置。如果机器人是移动的，则虚拟关节可以与移动基座关联，但这里设计的机械臂是固定不动的，所以无需设置虚拟关节。</li>
</ul>
<h4 id="（5）Planning-Groups-创建规划组"><a href="#（5）Planning-Groups-创建规划组" class="headerlink" title="（5）Planning Groups 创建规划组"></a>（5）Planning Groups 创建规划组</h4><ul>
<li>将机器人的多个组成部分（link，joint）集成到一个组中，运动规划器会针对一组link或joint完成规划任务。配置过程中，还可以选择运动学解析器。</li>
<li>点击Add Group<ul>
<li>Group Name，运动组命名。</li>
<li>Kinematic Solver，运动学求解器。负责求解正向运动学(Forward Kinematics)和逆运动学(IK)的。 一般选用KDL， The Kinematics and Dynamics Library。这是一个运动学与动力学的库，可以很好的解决6自由度以上的单链机械结构的正逆运动学问题。</li>
<li>Kin. Search Resolution：关节空间的采样密度。</li>
<li>Kin. Search Timeout(sec)：运动学求解时间。</li>
<li>Kin.Solver Attempts：求解失败尝试次数，一般来说以上三项使用默认值即可。</li>
<li>OMPL Planning：运动规划算法，选用RRT(Rapidly-exploring Random Trees)，这是一种基于采样的运动规划算法。</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127153824.png" alt="image-20201127153824322" style="zoom:80%;" />

<ul>
<li>点击 Add Kin. Chian ，添加运动学求解链。<ul>
<li>选择 base_link 座位Base Link</li>
<li>选择 tool0 座位 Tip Link</li>
<li>Save</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127155711.png" alt="image-20201127155711331" style="zoom:80%;" />

<h4 id="（6）Robot-Poses-机器人位姿"><a href="#（6）Robot-Poses-机器人位姿" class="headerlink" title="（6）Robot Poses 机器人位姿"></a>（6）Robot Poses 机器人位姿</h4><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127162348.png" alt="image-20201127162348386" style="zoom:80%;" />

<ul>
<li>设置一些自定义的位姿，比如机器人的初始位姿、指定位姿。点击Add Pose添加。</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127162554.png" alt="image-20201127162554450" style="zoom:80%;" />

<ul>
<li>设置home位姿，便于在仿真环境中让机械臂恢复到初始home位姿。设置完成点击Save即可。</li>
</ul>
<h4 id="（7）End-Effectors-配置终端夹爪"><a href="#（7）End-Effectors-配置终端夹爪" class="headerlink" title="（7）End Effectors 配置终端夹爪"></a>（7）End Effectors 配置终端夹爪</h4><ul>
<li>点击 Add End Effector</li>
</ul>
<h4 id="（8）Passive-Joints-消极关节"><a href="#（8）Passive-Joints-消极关节" class="headerlink" title="（8）Passive Joints 消极关节"></a>（8）Passive Joints 消极关节</h4><p>机器人上的某些关节可能在规划、控制过程中使用不到，可以先声明出来。</p>
<h4 id="（9）ROS-Control"><a href="#（9）ROS-Control" class="headerlink" title="（9）ROS Control"></a>（9）ROS Control</h4><p>给机器人各个关节设置Controller，每个关节如何通过Controller完成闭环控制，可以通过文件配置，此处略过</p>
<h4 id="（10）Simulate"><a href="#（10）Simulate" class="headerlink" title="（10）Simulate"></a>（10）Simulate</h4><p>后续手动添加，此处略过</p>
<h4 id="（11）3D-Perception-3D视觉"><a href="#（11）3D-Perception-3D视觉" class="headerlink" title="（11）3D Perception 3D视觉"></a>（11）3D Perception 3D视觉</h4><h4 id="（12）Author-Information-作者信息"><a href="#（12）Author-Information-作者信息" class="headerlink" title="（12）Author Information 作者信息"></a>（12）Author Information 作者信息</h4><h4 id="（13）Configuration-Files-配置文件"><a href="#（13）Configuration-Files-配置文件" class="headerlink" title="（13）Configuration Files 配置文件"></a>（13）Configuration Files 配置文件</h4><ul>
<li><p>自动生成配置功能包中的所有文件，点击Browser选择功能包目录保存</p>
</li>
<li><p>命名格式：机器人名字_moveit_config</p>
</li>
<li><p>点击Generate Package，OK。</p>
</li>
<li><p>Exit Setup Assistant</p>
</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127172150.png" alt="image-20201127172150596"></p>
<h4 id="（14）查看生成的配置文件"><a href="#（14）查看生成的配置文件" class="headerlink" title="（14）查看生成的配置文件"></a>（14）查看生成的配置文件</h4><p>在*_moveit_config 文件夹下会生成如图文件</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127202636.png" alt="image-20201127202636342" style="zoom: 80%;" />

<p><strong>config文件夹下：</strong></p>
<ul>
<li>kinematics.yaml 保存了运动学求解器的相关设置，如 kdl</li>
<li>joint_limits.yaml 保存了每个关节的限位，此文件后续会经常修改，此文件的修改会覆盖urdf中的配置，所以以此文件的配置为准</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127202730.png" alt="image-20201127202730954" style="zoom:80%;" />

<p><strong>launch文件夹下：</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127203047.png" alt="image-20201127203047647" style="zoom: 67%;" />

<p>可以运行其中的demo.launch验证是否配置成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127203500.png" alt="image-20201127203500838" style="zoom:80%;" />

<p>添加RobotModel插件</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201127203556.png" alt="image-20201127203556602" style="zoom:80%;" />]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 4.MoveIt！仿真</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%204.MoveIt!%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h1 id="四、MoveIt！仿真"><a href="#四、MoveIt！仿真" class="headerlink" title="四、MoveIt！仿真"></a>四、MoveIt！仿真</h1><h2 id="4-1-ROS中的控制器插件"><a href="#4-1-ROS中的控制器插件" class="headerlink" title="4.1 ROS中的控制器插件"></a>4.1 ROS中的控制器插件</h2><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201128172311.png" alt="image-20201128172311181" style="zoom: 50%;" />

<h3 id="ros-control-（上图感叹号部分）是什么？"><a href="#ros-control-（上图感叹号部分）是什么？" class="headerlink" title="ros_control （上图感叹号部分）是什么？"></a>ros_control （上图感叹号部分）是什么？</h3><ul>
<li>ROS为开发者提供的机器人控制中间件。</li>
<li>包含一系列控制器接口、传动装置接口、硬件接口、控制器工具箱等等。</li>
<li>可以帮助机器人应用功能包快速落地，提高开发效率。</li>
</ul>
<h2 id="4-2-完善机器人模型"><a href="#4-2-完善机器人模型" class="headerlink" title="4.2 完善机器人模型"></a>4.2 完善机器人模型</h2><br>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"paused"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"use_sim_time"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"headless"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"debug"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- We resume the logic in empty_world.launch --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find gazebo_ros)/launch/empty_world.launch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"debug"</span> <span class="attr">value</span>=<span class="string">"$(arg debug)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"gui"</span> <span class="attr">value</span>=<span class="string">"$(arg gui)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"paused"</span> <span class="attr">value</span>=<span class="string">"$(arg paused)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"use_sim_time"</span> <span class="attr">value</span>=<span class="string">"$(arg use_sim_time)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"headless"</span> <span class="attr">value</span>=<span class="string">"$(arg headless)"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Load the URDF into the ROS Parameter Server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro --inorder '$(find probot_description)/urdf/probot_anno.xacro'"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"urdf_spawner"</span> <span class="attr">pkg</span>=<span class="string">"gazebo_ros"</span> <span class="attr">type</span>=<span class="string">"spawn_model"</span> <span class="attr">respawn</span>=<span class="string">"false"</span> <span class="attr">output</span>=<span class="string">"screen"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">args</span>=<span class="string">"-urdf -model probot_anno -param robot_description"</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="（1）为link添加惯性参数和碰撞属性"><a href="#（1）为link添加惯性参数和碰撞属性" class="headerlink" title="（1）为link添加惯性参数和碰撞属性"></a>（1）为link添加惯性参数和碰撞属性</h3><h3 id="（2）为joint添加传动装置"><a href="#（2）为joint添加传动装置" class="headerlink" title="（2）为joint添加传动装置"></a>（2）为joint添加传动装置</h3><h3 id="（3）添加gazebo控制器插件"><a href="#（3）添加gazebo控制器插件" class="headerlink" title="（3）添加gazebo控制器插件"></a>（3）添加gazebo控制器插件</h3><h2 id="4-3-构建MoveIt！-Gazebo-仿真"><a href="#4-3-构建MoveIt！-Gazebo-仿真" class="headerlink" title="4.3 构建MoveIt！+ Gazebo 仿真"></a>4.3 构建MoveIt！+ Gazebo 仿真</h2><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201128192232.png" alt="image-20201128192232714"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201128193748.png" alt="image-20201128193748192"></p>
<h3 id="Gazebo-端"><a href="#Gazebo-端" class="headerlink" title="Gazebo 端"></a>Gazebo 端</h3><h4 id="Joint-Trajectory-Controller-配置Gazebo-关节轨迹控制器接口："><a href="#Joint-Trajectory-Controller-配置Gazebo-关节轨迹控制器接口：" class="headerlink" title="Joint Trajectory Controller 配置Gazebo 关节轨迹控制器接口："></a>Joint Trajectory Controller 配置Gazebo 关节轨迹控制器接口：</h4><p>（1） 参数配置：probot_gazebo/config/probot_anno_trajectory_control.yaml</p>
<ul>
<li>joints要和机器人模型关节名称匹配</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">probot_anno:</span></span><br><span class="line">  <span class="attr">arm_joint_controller:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">"position_controllers/JointTrajectoryController"</span></span><br><span class="line">    <span class="attr">joints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_5</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_6</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gains:</span></span><br><span class="line">      <span class="attr">joint_1:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">joint_2:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">joint_3:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">joint_4:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">joint_5:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">joint_6:</span>   <span class="string">&#123;p:</span> <span class="number">1000.0</span><span class="string">,</span> <span class="attr">i:</span> <span class="number">0.0</span><span class="string">,</span> <span class="attr">d:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">i_clamp:</span> <span class="number">0.0</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>（2）控制器启动：probot_gazebo/launch/probot_anno/probot_anno_trajectory_controller.launch</p>
<ul>
<li>加载上述配置文件，</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">"$(find probot_gazebo)/config/probot_anno_trajectory_control.yaml"</span> <span class="attr">command</span>=<span class="string">"load"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"arm_controller_spawner"</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">respawn</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span> <span class="attr">ns</span>=<span class="string">"/probot_anno"</span> <span class="attr">args</span>=<span class="string">"arm_joint_controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Joint State Controller 配置Gazebo 关节状态控制器接口：</p>
<p>（1）参数配置：probot_gazebo/config/probot_anno_gazebo_joint_states.yaml</p>
<ul>
<li>发布频率为50Hz，即一秒钟50次</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">probot_anno:</span></span><br><span class="line">  <span class="comment"># Publish all joint states -----------------------------------</span></span><br><span class="line">  <span class="attr">joint_state_controller:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">joint_state_controller/JointStateController</span></span><br><span class="line">    <span class="attr">publish_rate:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>（2）控制器启动：probot_gazebo/launch/probot_anno/probot_anno_gazebo_states.launch</p>
<ul>
<li><p>spawner</p>
</li>
<li><p>robot_state_publisher通过各个关节的位置，发布成tf</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将关节控制器的配置参数加载到参数服务器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">"$(find probot_gazebo)/config/probot_anno_gazebo_joint_states.yaml"</span> <span class="attr">command</span>=<span class="string">"load"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"joint_controller_spawner"</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">respawn</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">output</span>=<span class="string">"screen"</span> <span class="attr">ns</span>=<span class="string">"/probot_anno"</span> <span class="attr">args</span>=<span class="string">"joint_state_controller"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 运行robot_state_publisher节点，发布tf  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">pkg</span>=<span class="string">"robot_state_publisher"</span> <span class="attr">type</span>=<span class="string">"robot_state_publisher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">respawn</span>=<span class="string">"false"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"/joint_states"</span> <span class="attr">to</span>=<span class="string">"/probot_anno/joint_states"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MoveIt！端："><a href="#MoveIt！端：" class="headerlink" title="MoveIt！端："></a>MoveIt！端：</h3><p>Follow Joint Trajectory 控制器接口：</p>
<p>（1）参数配置：probot_anno_moveit_config/config/controllers_gazebo.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">controller_manager_ns:</span> <span class="string">controller_manager</span></span><br><span class="line"><span class="attr">controller_list:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">probot_anno/arm_joint_controller</span></span><br><span class="line">    <span class="attr">action_ns:</span> <span class="string">follow_joint_trajectory</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">FollowJointTrajectory</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">joints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_5</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">joint_6</span></span><br></pre></td></tr></table></figure>

<p>（2）控制器启动：probot_anno_moveit_config/launch/probot_anno_moveit_controller_manager.launch</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- loads moveit_controller_manager on the parameter server which is taken as argument </span></span><br><span class="line"><span class="comment">    if no argument is passed, moveit_simple_controller_manager will be set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"moveit_controller_manager"</span> <span class="attr">default</span>=<span class="string">"moveit_simple_controller_manager/MoveItSimpleControllerManager"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"moveit_controller_manager"</span> <span class="attr">value</span>=<span class="string">"$(arg moveit_controller_manager)"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- loads ros_controllers to the param server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">"$(find probot_anno_moveit_config)/config/ros_controllers.yaml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）最顶层lanch文件  probot_gazebo/launch/probot_anno/probot_anno_bringup_moveit.launch</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- Launch Gazebo  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find probot_gazebo)/launch/probot_anno/probot_anno_gazebo_world.launch"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ros_control arm launch file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find probot_gazebo)/launch/probot_anno/probot_anno_gazebo_states.launch"</span> /&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ros_control trajectory control dof arm launch file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find probot_gazebo)/launch/probot_anno/probot_anno_trajectory_controller.launch"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- moveit launch file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find probot_anno_moveit_config)/launch/moveit_planning_execution.launch"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="查看话题"><a href="#查看话题" class="headerlink" title="查看话题"></a>查看话题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rostopic list</span></span><br><span class="line">/attached_collision_object</span><br><span class="line">/clock</span><br><span class="line">/collision_object</span><br><span class="line">/execute_trajectory/cancel</span><br><span class="line">/execute_trajectory/feedback</span><br><span class="line">/execute_trajectory/goal</span><br><span class="line">/execute_trajectory/result</span><br><span class="line">/execute_trajectory/status</span><br><span class="line">/gazebo/link_states</span><br><span class="line">/gazebo/model_states</span><br><span class="line">/gazebo/parameter_descriptions</span><br><span class="line">/gazebo/parameter_updates</span><br><span class="line">/gazebo/set_link_state</span><br><span class="line">/gazebo/set_model_state</span><br><span class="line">/gazebo_gui/parameter_descriptions</span><br><span class="line">/gazebo_gui/parameter_updates</span><br><span class="line">/joint_states</span><br><span class="line">/move_group/cancel</span><br><span class="line">/move_group/display_contacts</span><br><span class="line">/move_group/display_planned_path</span><br><span class="line">/move_group/feedback</span><br><span class="line">/move_group/goal</span><br><span class="line">/move_group/monitored_planning_scene</span><br><span class="line">/move_group/ompl/parameter_descriptions</span><br><span class="line">/move_group/ompl/parameter_updates</span><br><span class="line">/move_group/plan_execution/parameter_descriptions</span><br><span class="line">/move_group/plan_execution/parameter_updates</span><br><span class="line">/move_group/planning_scene_monitor/parameter_descriptions</span><br><span class="line">/move_group/planning_scene_monitor/parameter_updates</span><br><span class="line">/move_group/result</span><br><span class="line">/move_group/sense_for_plan/parameter_descriptions</span><br><span class="line">/move_group/sense_for_plan/parameter_updates</span><br><span class="line">/move_group/status</span><br><span class="line">/move_group/trajectory_execution/parameter_descriptions</span><br><span class="line">/move_group/trajectory_execution/parameter_updates</span><br><span class="line">/pickup/cancel</span><br><span class="line">/pickup/feedback</span><br><span class="line">/pickup/goal</span><br><span class="line">/pickup/result</span><br><span class="line">/pickup/status</span><br><span class="line">/place/cancel</span><br><span class="line">/place/feedback</span><br><span class="line">/place/goal</span><br><span class="line">/place/result</span><br><span class="line">/place/status</span><br><span class="line">/planning_scene</span><br><span class="line">/planning_scene_world</span><br><span class="line">/probot_anno/arm_joint_controller/command</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/cancel</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/feedback</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/goal</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/result</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/status</span><br><span class="line">/probot_anno/arm_joint_controller/state</span><br><span class="line">/probot_anno/joint_states</span><br><span class="line">/recognized_object_array</span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">/rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic/feedback</span><br><span class="line">/rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic/update</span><br><span class="line">/rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic/update_full</span><br><span class="line">/rviz_zz_23863_4329036234228615542/motionplanning_planning_scene_monitor/parameter_descriptions</span><br><span class="line">/rviz_zz_23863_4329036234228615542/motionplanning_planning_scene_monitor/parameter_updates</span><br><span class="line">/tf</span><br><span class="line">/tf_static</span><br><span class="line">/trajectory_execution_event</span><br></pre></td></tr></table></figure>

<p>其中以下话题是action中的底层话题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/probot_anno/arm_joint_controller/command</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/cancel</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/feedback</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/goal</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/result</span><br><span class="line">/probot_anno/arm_joint_controller/follow_joint_trajectory/status</span><br><span class="line">/probot_anno/arm_joint_controller/state</span><br></pre></td></tr></table></figure>

<p>查看 /probot_anno/arm_joint_controller/follow_joint_trajectory/goal,输入完命令后移动机械臂，即可产生如下数据</p>
<ul>
<li>points为路径点，每个点前面有 横线 - 做区分，具体到每个点，包含：<ul>
<li>positions 位置</li>
<li>velocities 速度</li>
<li>accelerations 加速度</li>
<li>effort 力</li>
<li>time_from_start 具体的时间戳</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rostopic <span class="built_in">echo</span> /probot_anno/arm_joint_controller/follow_joint_trajectory/goal </span></span><br><span class="line">WARNING: no messages received and simulated time is active.</span><br><span class="line">Is /clock being published?</span><br><span class="line">header: </span><br><span class="line">  seq: 2</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 389</span><br><span class="line">    nsecs: 400000000</span><br><span class="line">  frame_id: ''</span><br><span class="line">goal_id: </span><br><span class="line">  stamp: </span><br><span class="line">    secs: 389</span><br><span class="line">    nsecs: 400000000</span><br><span class="line">  id: "/move_group-3-389.400000000"</span><br><span class="line">goal: </span><br><span class="line">  trajectory: </span><br><span class="line">    header: </span><br><span class="line">      seq: 0</span><br><span class="line">      stamp: </span><br><span class="line">        secs: 0</span><br><span class="line">        nsecs:         0</span><br><span class="line">      frame_id: "/base_footprint"</span><br><span class="line">    joint_names: [joint_1, joint_2, joint_3, joint_4, joint_5, joint_6]</span><br><span class="line">    points: </span><br><span class="line">      - </span><br><span class="line">        positions: [-0.38825146074406547, -0.6524099587144567, 0.23720395399686023, -0.00010076182596829852, 0.41527452247959395, -0.4205500648974132]</span><br><span class="line">        velocities: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">        accelerations: [0.18853085881196788, 0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs:         0</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.3833404759085481, -0.6500887017485557, 0.21245823433821254, -9.728456004470945e-05, 0.4376934801403612, -0.4156516645929134]</span><br><span class="line">        velocities: [0.03704071971723571, 0.017507899442853546, -0.18664265860651663, 2.6227006755639408e-05, 0.1690932378897403, 0.036945801874519915]</span><br><span class="line">        accelerations: [0.19304937300694633, 0.09124793027546448, -0.9727469794160399, 0.0001366903032305051, 0.8812826479486298, 0.19255467878492755]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 228248573</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.37842949107303064, -0.6477674447826548, 0.18771251467956485, -9.380729412112035e-05, 0.4601124378011285, -0.41075326428841363]</span><br><span class="line">        velocities: [0.06071112935119913, 0.028696104067553754, -0.3059143201215745, 4.2987048086311585e-05, 0.2771501611282206, 0.060555555445755645]</span><br><span class="line">        accelerations: [0.19777238056535099, 0.09348033671984872, -0.99654550962956, 0.00014003447019289163, 0.9028434774013626, 0.19726558350916512]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 321674600</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.37351850623751326, -0.6454461878167538, 0.16296679502091718, -9.033002819753128e-05, 0.4825313954618957, -0.40585486398391385]</span><br><span class="line">        velocities: [0.07471294534238421, 0.0353142904381858, -0.37646738123550494, 5.2901156813015434e-05, 0.34106934035475733, 0.07452149140604183]</span><br><span class="line">        accelerations: [0.17709037510708867, 0.08370464999978182, -0.8923319707590027, 0.00012539039467235737, 0.8084288090124003, 0.17663657624736975]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 392996344</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.3686075214019959, -0.6431249308508529, 0.1382210753622695, -8.68527622739422e-05, 0.504950353122663, -0.40095646367941407]</span><br><span class="line">        velocities: [0.08390947881602044, 0.03966118176503915, -0.4228073408957519, 5.941284307026924e-05, 0.38305209971498744, 0.08369445851475696]</span><br><span class="line">        accelerations: [0.11396632213572863, 0.05386803828481429, -0.5742592886260354, 8.06948548350701e-05, 0.5202634983181627, 0.11367428036325394]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 453950028</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.36369653656647843, -0.6408036738849519, 0.1134753557036218, -8.33754963503531e-05, 0.5273693107834302, -0.3960580633749143]</span><br><span class="line">        velocities: [0.08195650182511957, 0.038738075382875936, -0.41296658130571906, 5.803002056776447e-05, 0.37413663572193956, 0.08174648608003815]</span><br><span class="line">        accelerations: [-0.17593760660747473, -0.08315977519377366, 0.8865233423313901, -0.00012457416681668537, -0.8031663476015668, -0.17548676174809327]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 510236493</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.35878555173096105, -0.6384824169190509, 0.08872963604497414, -7.989823042676403e-05, 0.5497882684441975, -0.3911596630704145]</span><br><span class="line">        velocities: [0.0700862772951628, 0.033127420432835286, -0.35315429144094, 4.9625203887238066e-05, 0.3199483068889408, 0.06990667932040419]</span><br><span class="line">        accelerations: [-0.1860688585003218, -0.08794847640483491, 0.9375732086064174, -0.00013174768865604176, -0.849416155907665, -0.18559205203489088]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 574295741</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.35387456689544367, -0.6361611599531499, 0.06398391638632642, -7.642096450317495e-05, 0.5722072261049648, -0.3862612627659147]</span><br><span class="line">        velocities: [0.05807286460800233, 0.02744908526823965, -0.29262049782176214, 4.1119001575034046e-05, 0.26510631502471416, 0.05792405132707824]</span><br><span class="line">        accelerations: [-0.12744797836768276, -0.06024036267359057, 0.6421913423432557, -9.024065987807033e-05, -0.5818081152096802, -0.1271213894877366]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 651622654</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.3489635820599262, -0.633839902987249, 0.039238196727678754, -7.294369857958587e-05, 0.594626183765732, -0.38136286246141493]</span><br><span class="line">        velocities: [0.03728809803654459, 0.017624826834434084, -0.18788916103816172, 2.6402165146222526e-05, 0.1702225356278774, 0.03719254628021744]</span><br><span class="line">        accelerations: [-0.19358393084868963, -0.09150059774551014, 0.9754405366018473, -0.0001370688016029357, -0.883722938444857, -0.1930878668077922]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 744922922</span><br><span class="line">      - </span><br><span class="line">        positions: [-0.34405259722440884, -0.631518646021348, 0.014492477069031054, -6.946643265599678e-05, 0.6170451414264992, -0.37646446215691515]</span><br><span class="line">        velocities: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">        accelerations: [-0.19603285285189084, -0.09265812061501942, 0.9877802890928218, -0.00013880278232502834, -0.8949024229155365, -0.19553051338235275]</span><br><span class="line">        effort: []</span><br><span class="line">        time_from_start: </span><br><span class="line">          secs: 0</span><br><span class="line">          nsecs: 968761461</span><br><span class="line">  path_tolerance: []</span><br><span class="line">  goal_tolerance: []</span><br><span class="line">  goal_time_tolerance: </span><br><span class="line">    secs: 0</span><br><span class="line">    nsecs:         0</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 5.MoveIt! 编程</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%205.Moveit!%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="五、MoveIt-编程"><a href="#五、MoveIt-编程" class="headerlink" title="五、MoveIt! 编程"></a>五、MoveIt! 编程</h1><h2 id="5-1-MoveIt-的编程接口"><a href="#5-1-MoveIt-的编程接口" class="headerlink" title="5.1 MoveIt! 的编程接口"></a>5.1 MoveIt! 的编程接口</h2><p><strong>“move_group” Python Interface：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># "move_group" Python Interface</span></span><br><span class="line">group = moveit_commander.MoveGroupCommander(<span class="string">"left_arm"</span>)</span><br><span class="line"></span><br><span class="line">pose_target = geometry_msgs.msg.Pose()</span><br><span class="line">pose_target.orientation.w = <span class="number">1.0</span></span><br><span class="line">pose_target.position.x =  <span class="number">0.7</span></span><br><span class="line">pose_target.position.y = <span class="number">-0.05</span></span><br><span class="line">pose_target.position.z = <span class="number">1.1</span></span><br><span class="line">group.set_pose_target(pose_target)</span><br><span class="line"></span><br><span class="line">plan1 = group.plan()</span><br></pre></td></tr></table></figure>

<p><strong>“move_group” C++ Interface:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">moveit::<span class="function">planning_interface::MoveGroup <span class="title">group</span><span class="params">(<span class="string">"right_arm"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">geometry_msgs::Pose target_pose;</span><br><span class="line">target_pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">target_pose.<span class="built_in">position</span>.x = <span class="number">0.28</span>;</span><br><span class="line">target_pose.<span class="built_in">position</span>.y = <span class="number">-0.7</span>;</span><br><span class="line">target_pose.<span class="built_in">position</span>.z = <span class="number">1.0</span>;</span><br><span class="line">group.setPoseTarget(target_pose);</span><br><span class="line"></span><br><span class="line">moveit::planning_interface::MoveGroup::Plan my_plan;</span><br><span class="line"><span class="keyword">bool</span> success = group.plan(my_plan);</span><br></pre></td></tr></table></figure>

<h3 id="ROS编程流程"><a href="#ROS编程流程" class="headerlink" title="ROS编程流程"></a>ROS编程流程</h3><ul>
<li><p>（1）连接控制需要的规划组</p>
<ul>
<li>要控制谁？</li>
</ul>
</li>
<li><p>（2）设置目标位姿（关节空间或笛卡尔空间）</p>
<ul>
<li>要到达什么位置？终点的位姿？</li>
</ul>
</li>
<li><p>（3）设置运动约束（可选）</p>
<ul>
<li>针对场景做运动约束</li>
</ul>
</li>
<li><p>（4）使用MoveIt！规划一条到达目标的轨迹</p>
<ul>
<li>怎么走？</li>
</ul>
</li>
<li><p>（5）修改轨迹（如速度等参数）（可选）</p>
</li>
<li><p>（6）执行规划出的轨迹</p>
<ul>
<li>Execute</li>
</ul>
</li>
</ul>
<h2 id="5-2-关节空间运动"><a href="#5-2-关节空间运动" class="headerlink" title="5.2 关节空间运动"></a>5.2 关节空间运动</h2><p><strong>点到点运动：不需要在笛卡尔空间规划末端运动轨迹，机器人各个关节运动不需要联动。</strong></p>
<h3 id="正向运动学规划例程："><a href="#正向运动学规划例程：" class="headerlink" title="正向运动学规划例程："></a>正向运动学规划例程：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_fk_demo.py</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># moveit_fk_demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy, sys</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveItFkDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 0.初始化move_group API和ROS节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化move_group的API</span></span><br><span class="line">        moveit_commander.roscpp_initialize(sys.argv)</span><br><span class="line">        <span class="comment"># 初始化ROS节点</span></span><br><span class="line">        rospy.init_node(<span class="string">'moveit_fk_demo'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">		<span class="comment"># 1. 连接控制需要的规划组，设置参数约束</span></span><br><span class="line">        <span class="comment"># 初始化需要使用move group控制的机械臂中的arm group</span></span><br><span class="line">        arm = moveit_commander.MoveGroupCommander(<span class="string">'manipulator'</span>)        </span><br><span class="line">        <span class="comment"># 设置机械臂运动的允许误差值，单位是弧度</span></span><br><span class="line">        arm.set_goal_joint_tolerance(<span class="number">0.001</span>)</span><br><span class="line">        <span class="comment"># 设置允许的最大速度和加速度，0.5是一个比例，乘以允许的最大速度和加速度</span></span><br><span class="line">        arm.set_max_acceleration_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line">        arm.set_max_velocity_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 设置初始位姿和目标位姿</span></span><br><span class="line">        <span class="comment"># 控制机械臂先回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go() <span class="comment"># plan + execute</span></span><br><span class="line">        rospy.sleep(<span class="number">1</span>) <span class="comment"># 休眠一秒        </span></span><br><span class="line">        <span class="comment"># 设置机械臂的目标位置，使用六轴的位置数据进行描述（单位：弧度）</span></span><br><span class="line">        joint_positions = [<span class="number">0.391410</span>, <span class="number">-0.676384</span>, <span class="number">-0.376217</span>, <span class="number">0.0</span>, <span class="number">1.052834</span>, <span class="number">0.454125</span>]</span><br><span class="line">        arm.set_joint_value_target(joint_positions)     </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 执行规划出的轨迹，并回到原处</span></span><br><span class="line">        <span class="comment"># 控制机械臂完成运动</span></span><br><span class="line">        arm.go()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 控制机械臂先回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关闭并退出moveit</span></span><br><span class="line">        moveit_commander.roscpp_shutdown()</span><br><span class="line">        moveit_commander.os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        MoveItFkDemo()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>关键API的实现步骤</strong></p>
<ul>
<li>创建规划组的控制对象；</li>
<li>设置关节空间运动的目标位姿；</li>
<li>完成规划并控制机械臂完成运动</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arm = moveit_commander.MoveGroupCommander(<span class="string">'manipulator'</span>)</span><br><span class="line"></span><br><span class="line">joint_positions = [<span class="number">0.391410</span>, <span class="number">-0.676384</span>, <span class="number">-0.376217</span>, <span class="number">0.0</span>, <span class="number">1.052834</span>, <span class="number">0.454125</span>]</span><br><span class="line">arm.set_joint_value_target(joint_positions)</span><br><span class="line"></span><br><span class="line">arm.go()</span><br></pre></td></tr></table></figure>



<h3 id="逆向运动学规划例程："><a href="#逆向运动学规划例程：" class="headerlink" title="逆向运动学规划例程："></a>逆向运动学规划例程：</h3><p>很多情况下很难确定机器人目标位置的六个关节值，更常用的是通过工作空间下的 x y z 和姿态来确定目标位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_ik_demo.py</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># moveit_ik_demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy, sys</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> PoseStamped, Pose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveItIkDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 0. 初始化</span></span><br><span class="line">        <span class="comment"># 初始化move_group的API</span></span><br><span class="line">        moveit_commander.roscpp_initialize(sys.argv) </span><br><span class="line">        <span class="comment"># 初始化ROS节点</span></span><br><span class="line">        rospy.init_node(<span class="string">'moveit_ik_demo'</span>)             </span><br><span class="line">        <span class="comment"># 初始化需要使用move group控制的机械臂中的arm group</span></span><br><span class="line">        arm = moveit_commander.MoveGroupCommander(<span class="string">'manipulator'</span>)      </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 设置参考坐标系和约束参数</span></span><br><span class="line">        <span class="comment"># 获取终端link的名称</span></span><br><span class="line">        end_effector_link = arm.get_end_effector_link()                    </span><br><span class="line">        <span class="comment"># 设置目标位置所使用的参考坐标系</span></span><br><span class="line">        reference_frame = <span class="string">'base_link'</span></span><br><span class="line">        arm.set_pose_reference_frame(reference_frame)</span><br><span class="line">             </span><br><span class="line">        <span class="comment"># 当运动规划失败后，允许重新规划</span></span><br><span class="line">        arm.allow_replanning(<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置位置(单位：米)和姿态（单位：弧度）的允许误差</span></span><br><span class="line">        arm.set_goal_position_tolerance(<span class="number">0.001</span>)</span><br><span class="line">        arm.set_goal_orientation_tolerance(<span class="number">0.01</span>)</span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 设置允许的最大速度和加速度</span></span><br><span class="line">        arm.set_max_acceleration_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line">        arm.set_max_velocity_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 控制机械臂先回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">               </span><br><span class="line">        <span class="comment"># 设置机械臂工作空间中的目标位姿，位置使用x、y、z坐标描述，</span></span><br><span class="line">        <span class="comment"># 姿态使用四元数描述，基于base_link坐标系</span></span><br><span class="line">        target_pose = PoseStamped()</span><br><span class="line">        target_pose.header.frame_id = reference_frame</span><br><span class="line">        target_pose.header.stamp = rospy.Time.now()     </span><br><span class="line">        target_pose.pose.position.x = <span class="number">0.2593</span></span><br><span class="line">        target_pose.pose.position.y = <span class="number">0.0636</span></span><br><span class="line">        target_pose.pose.position.z = <span class="number">0.1787</span></span><br><span class="line">        target_pose.pose.orientation.x = <span class="number">0.70692</span></span><br><span class="line">        target_pose.pose.orientation.y = <span class="number">0.0</span></span><br><span class="line">        target_pose.pose.orientation.z = <span class="number">0.0</span></span><br><span class="line">        target_pose.pose.orientation.w = <span class="number">0.70729</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置机器臂当前的状态作为运动初始状态</span></span><br><span class="line">        arm.set_start_state_to_current_state()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置机械臂终端运动的目标位姿</span></span><br><span class="line">        arm.set_pose_target(target_pose, end_effector_link)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 规划运动路径，即rviz中的机械臂虚影轨迹</span></span><br><span class="line">        traj = arm.plan()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 按照规划的运动路径控制机械臂运动</span></span><br><span class="line">        arm.execute(traj)</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 控制机械臂回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭并退出moveit</span></span><br><span class="line">        moveit_commander.roscpp_shutdown()</span><br><span class="line">        moveit_commander.os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    MoveItIkDemo()</span><br></pre></td></tr></table></figure>

<p><strong>关键API的实现步骤：</strong></p>
<ul>
<li>创建规划组的控制对象；</li>
<li>获取机器人的终端link名称；</li>
<li>设置目标位姿对应的参考坐标系的起始、终止位姿；</li>
<li>完成规划并控制机械臂完成运动。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arm = moveit_commander.MoveGroupCommander(<span class="string">'manipulator'</span>)</span><br><span class="line">end_effortor_link = arm.get_end_effector_link()</span><br><span class="line"></span><br><span class="line">reference_frame = <span class="string">'base_link'</span></span><br><span class="line">arm.set_pose_reference_frame(reference_frame)</span><br><span class="line"></span><br><span class="line">arm.set_pose_target(target_pose, end_effector_link)</span><br><span class="line"></span><br><span class="line">traj = arm.plan()</span><br><span class="line">arm.execute(traj)</span><br></pre></td></tr></table></figure>



<h2 id="5-3-笛卡尔空间运动"><a href="#5-3-笛卡尔空间运动" class="headerlink" title="5.3 笛卡尔空间运动"></a>5.3 笛卡尔空间运动</h2><p><strong>笛卡尔路径约束，路径点之间的路径形状是一条直线</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_cartesian_demo.py _cartesian:=True (走直线)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_cartesian_demo.py _cartesian:=False (自由曲线)</span></span><br></pre></td></tr></table></figure>

<p><strong>显示终端轨迹：</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130095029.png" alt="image-20201130095029187" style="zoom:67%;" />



<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130095002.png" alt="image-20201130095002467" style="zoom:67%;" />



<p><strong>走直线：</strong></p>
<p>两点可以确定一条直线，所以在代码中用 列表 <code>waypoints[]</code> 来储存路点列表</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130095310.png" alt="image-20201130095310643" style="zoom: 67%;" />

<p><strong>自由曲线：</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130095832.png" alt="image-20201130095832715" style="zoom: 80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rospy, sys</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"><span class="keyword">from</span> moveit_commander <span class="keyword">import</span> MoveGroupCommander</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Pose</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveItCartesianDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化move_group的API</span></span><br><span class="line">        moveit_commander.roscpp_initialize(sys.argv)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化ROS节点</span></span><br><span class="line">        rospy.init_node(<span class="string">'moveit_cartesian_demo'</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 是否需要使用笛卡尔空间的运动规划</span></span><br><span class="line">        cartesian = rospy.get_param(<span class="string">'~cartesian'</span>, <span class="literal">True</span>)</span><br><span class="line">                      </span><br><span class="line">        <span class="comment"># 初始化需要使用move group控制的机械臂中的arm group</span></span><br><span class="line">        arm = MoveGroupCommander(<span class="string">'manipulator'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当运动规划失败后，允许重新规划</span></span><br><span class="line">        arm.allow_replanning(<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置目标位置所使用的参考坐标系</span></span><br><span class="line">        arm.set_pose_reference_frame(<span class="string">'base_link'</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 设置位置(单位：米)和姿态（单位：弧度）的允许误差</span></span><br><span class="line">        arm.set_goal_position_tolerance(<span class="number">0.001</span>)</span><br><span class="line">        arm.set_goal_orientation_tolerance(<span class="number">0.001</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置允许的最大速度和加速度</span></span><br><span class="line">        arm.set_max_acceleration_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line">        arm.set_max_velocity_scaling_factor(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取终端link的名称</span></span><br><span class="line">        end_effector_link = arm.get_end_effector_link()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 控制机械臂先回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">                                               </span><br><span class="line">        <span class="comment"># 获取当前位姿数据最为机械臂运动的起始位姿</span></span><br><span class="line">        start_pose = arm.get_current_pose(end_effector_link).pose</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 初始化路点列表</span></span><br><span class="line">        waypoints = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将初始位姿加入路点列表</span></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            waypoints.append(start_pose)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 设置路点数据，并加入路点列表</span></span><br><span class="line">        wpose = deepcopy(start_pose)</span><br><span class="line">        wpose.position.z -= <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            waypoints.append(deepcopy(wpose))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arm.set_pose_target(wpose)</span><br><span class="line">            arm.go()</span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        wpose.position.x += <span class="number">0.15</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            waypoints.append(deepcopy(wpose))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arm.set_pose_target(wpose)</span><br><span class="line">            arm.go()</span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        wpose.position.y += <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            waypoints.append(deepcopy(wpose))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arm.set_pose_target(wpose)</span><br><span class="line">            arm.go()</span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        wpose.position.x -= <span class="number">0.15</span></span><br><span class="line">        wpose.position.y -= <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            waypoints.append(deepcopy(wpose))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arm.set_pose_target(wpose)</span><br><span class="line">            arm.go()</span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cartesian:</span><br><span class="line">            fraction = <span class="number">0.0</span>   <span class="comment">#路径规划覆盖率</span></span><br><span class="line">            maxtries = <span class="number">100</span>   <span class="comment">#最大尝试规划次数</span></span><br><span class="line">            attempts = <span class="number">0</span>     <span class="comment">#已经尝试规划次数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 设置机器臂当前的状态作为运动初始状态</span></span><br><span class="line">            arm.set_start_state_to_current_state()</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 尝试规划一条笛卡尔空间下的路径，依次通过所有路点</span></span><br><span class="line">            <span class="keyword">while</span> fraction &lt; <span class="number">1.0</span> <span class="keyword">and</span> attempts &lt; maxtries:</span><br><span class="line">                <span class="comment"># 返回的fraction是一个比例，成功规划的轨迹的百分比，所以fraction最好等于1，这里设置了求解100次</span></span><br><span class="line">                (plan, fraction) = arm.compute_cartesian_path (</span><br><span class="line">                                        waypoints,   <span class="comment"># waypoint poses，路点列表</span></span><br><span class="line">                                        <span class="number">0.01</span>,        <span class="comment"># eef_step，终端步进值, 每隔1厘米算一次运动学逆解，是否能到达这个点</span></span><br><span class="line">                                        <span class="number">0.0</span>,         <span class="comment"># jump_threshold，跳跃阈值，遇到逆解求不出的点，是否跳过，0.0是默认不跳过，如果是10，则允许跳过10厘米，10厘米内有点求不到都可以跳过</span></span><br><span class="line">                                        <span class="literal">True</span>)        <span class="comment"># avoid_collisions，避障规划</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 尝试次数累加</span></span><br><span class="line">                attempts += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 打印运动规划进程</span></span><br><span class="line">                <span class="keyword">if</span> attempts % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                    rospy.loginfo(<span class="string">"Still trying after "</span> + str(attempts) + <span class="string">" attempts..."</span>)</span><br><span class="line">                        </span><br><span class="line">            <span class="comment"># 如果路径规划成功（覆盖率100%）,则开始控制机械臂运动</span></span><br><span class="line">            <span class="keyword">if</span> fraction == <span class="number">1.0</span>:</span><br><span class="line">                rospy.loginfo(<span class="string">"Path computed successfully. Moving the arm."</span>)</span><br><span class="line">                arm.execute(plan)</span><br><span class="line">                rospy.loginfo(<span class="string">"Path execution complete."</span>)</span><br><span class="line">            <span class="comment"># 如果路径规划失败，则打印失败信息</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rospy.loginfo(<span class="string">"Path planning failed with only "</span> + str(fraction) + <span class="string">" success after "</span> + str(maxtries) + <span class="string">" attempts."</span>)  </span><br><span class="line"></span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 控制机械臂先回到初始化位置</span></span><br><span class="line">            arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">            arm.go()</span><br><span class="line">            rospy.sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 关闭并退出moveit</span></span><br><span class="line">            moveit_commander.roscpp_shutdown()</span><br><span class="line">            moveit_commander.os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        MoveItCartesianDemo()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>关键 API 的实现步骤：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(plan, fraction) = arm.compute_cartesian_path(</span><br><span class="line">					waypoints, <span class="comment"># waypoint poses, 路点列表</span></span><br><span class="line">					<span class="number">0.01</span>,      <span class="comment"># eef_step, 终端步进值</span></span><br><span class="line">					<span class="number">0.0</span>,       <span class="comment"># jump_threshold，最小移动值</span></span><br><span class="line">					<span class="literal">True</span>)      <span class="comment"># avoid_collisions，避障规划</span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>plan：规划出来的运动轨迹</li>
<li>fraction：描述规划成功的轨迹在给定路点列表中的覆盖率 [0~1]。如果fraction小于1，说明给定的路点列表没办法完成规划。</li>
</ul>
<p><strong>ROS中没有直接走圆弧的API，如何在笛卡尔空间下走出圆弧轨迹？</strong></p>
<h2 id="5-4-自主避障运动"><a href="#5-4-自主避障运动" class="headerlink" title="5.4 自主避障运动"></a>5.4 自主避障运动</h2><h3 id="5-4-1-规划场景监听器："><a href="#5-4-1-规划场景监听器：" class="headerlink" title="5.4.1 规划场景监听器："></a>5.4.1 规划场景监听器：</h3><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130102622.png" alt="image-20201130102622853" style="zoom:80%;" />

<p><strong>监听信息：</strong></p>
<ul>
<li>状态信息（State Information）：<ul>
<li>机器人的关节话题 joint_states;</li>
</ul>
</li>
<li>传感器信息（Sensor Information）：<ul>
<li>机器人的传感器数据；</li>
</ul>
</li>
<li>外界环境信息（World geometry information）<ul>
<li>周围环境信息。</li>
</ul>
</li>
</ul>
<p><strong>添加场景物体：</strong></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130104336.png" alt="image-20201130104336092"></p>
<p>点击 <code>Scene Objects</code> -&gt; <code>Import File</code> ，可以选择/home/your_name/.gazebo/models中的模型，</p>
<p>这里选择了 <code>bowl</code> -&gt;<code>meshes</code> -&gt;<code>bowl.dae</code> ，可以拖动Scale的拖动条调整模型的大小。设完成后点击 <code>Publish Scene</code>将模型发布出去，点击<code>Planning</code> 返回路径规划</p>
<p><strong>碰撞：</strong></p>
<ul>
<li>拖动机械臂，当和盘子发生碰撞后会，碰撞部分会变成红色</li>
</ul>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130104727.png" alt="image-20201130104727667" style="zoom: 80%;" />

<p><strong>避障运动：</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130105017.png" alt="image-20201130105017738" style="zoom:80%;" />

<p><strong>当机器人末端抓取物体时，物体和机器人视为一体，也会考虑到物体的避障：</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130113953.png" alt="image-20201130113953680" style="zoom:80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rospy, sys</span><br><span class="line"><span class="keyword">import</span> thread, copy</span><br><span class="line"><span class="keyword">import</span> moveit_commander</span><br><span class="line"><span class="keyword">from</span> moveit_commander <span class="keyword">import</span> RobotCommander, MoveGroupCommander, PlanningSceneInterface</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> PoseStamped, Pose</span><br><span class="line"><span class="keyword">from</span> moveit_msgs.msg <span class="keyword">import</span> CollisionObject, AttachedCollisionObject, PlanningScene</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> radians</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveAttachedObjectDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化move_group的API</span></span><br><span class="line">        moveit_commander.roscpp_initialize(sys.argv)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化ROS节点</span></span><br><span class="line">        rospy.init_node(<span class="string">'moveit_attached_object_demo'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化场景对象,场景监听器！</span></span><br><span class="line">        scene = PlanningSceneInterface()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">                                </span><br><span class="line">        <span class="comment"># 初始化需要使用move group控制的机械臂中的arm group</span></span><br><span class="line">        arm = MoveGroupCommander(<span class="string">'manipulator'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取终端link的名称</span></span><br><span class="line">        end_effector_link = arm.get_end_effector_link()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置位置(单位：米)和姿态（单位：弧度）的允许误差</span></span><br><span class="line">        arm.set_goal_position_tolerance(<span class="number">0.01</span>)</span><br><span class="line">        arm.set_goal_orientation_tolerance(<span class="number">0.05</span>)</span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 当运动规划失败后，允许重新规划</span></span><br><span class="line">        arm.allow_replanning(<span class="literal">True</span>)</span><br><span class="line">        arm.set_planning_time(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 控制机械臂回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 移除场景中之前运行残留的物体</span></span><br><span class="line">        scene.remove_attached_object(end_effector_link, <span class="string">'tool'</span>)</span><br><span class="line">        scene.remove_world_object(<span class="string">'table'</span>) </span><br><span class="line">        scene.remove_world_object(<span class="string">'target'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置桌面的高度</span></span><br><span class="line">        table_ground = <span class="number">0.6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置table和tool的三维尺寸，长宽高</span></span><br><span class="line">        table_size = [<span class="number">0.1</span>, <span class="number">0.7</span>, <span class="number">0.01</span>]</span><br><span class="line">        tool_size = [<span class="number">0.2</span>, <span class="number">0.02</span>, <span class="number">0.02</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置tool的位姿， 要和机器人的终端连接</span></span><br><span class="line">        p = PoseStamped()</span><br><span class="line">        p.header.frame_id = end_effector_link</span><br><span class="line">        </span><br><span class="line">        p.pose.position.x = tool_size[<span class="number">0</span>] / <span class="number">2.0</span> - <span class="number">0.025</span></span><br><span class="line">        p.pose.position.y = <span class="number">-0.015</span></span><br><span class="line">        p.pose.position.z = <span class="number">0.0</span></span><br><span class="line">        p.pose.orientation.x = <span class="number">0</span></span><br><span class="line">        p.pose.orientation.y = <span class="number">0</span></span><br><span class="line">        p.pose.orientation.z = <span class="number">0</span></span><br><span class="line">        p.pose.orientation.w = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将tool附着到机器人的终端</span></span><br><span class="line">        scene.attach_box(end_effector_link, <span class="string">'tool'</span>, p, tool_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将table加入场景当中</span></span><br><span class="line">        table_pose = PoseStamped()</span><br><span class="line">        table_pose.header.frame_id = <span class="string">'base_link'</span></span><br><span class="line">        table_pose.pose.position.x = <span class="number">0.25</span></span><br><span class="line">        table_pose.pose.position.y = <span class="number">0.0</span></span><br><span class="line">        table_pose.pose.position.z = table_ground + table_size[<span class="number">2</span>] / <span class="number">2.0</span></span><br><span class="line">        table_pose.pose.orientation.w = <span class="number">1.0</span></span><br><span class="line">        scene.add_box(<span class="string">'table'</span>, table_pose, table_size)</span><br><span class="line">        </span><br><span class="line">        rospy.sleep(<span class="number">2</span>)  </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新当前的位姿</span></span><br><span class="line">        arm.set_start_state_to_current_state()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置机械臂的目标位置，使用六轴的位置数据进行描述（单位：弧度）</span></span><br><span class="line">        joint_positions = [<span class="number">0.827228546495185</span>, <span class="number">0.29496592875743577</span>, <span class="number">1.1185644936946095</span>, <span class="number">-0.7987583317769674</span>, <span class="number">-0.18950024740190782</span>, <span class="number">0.11752152218233858</span>]</span><br><span class="line">        arm.set_joint_value_target(joint_positions)</span><br><span class="line">                 </span><br><span class="line">        <span class="comment"># 控制机械臂完成运动</span></span><br><span class="line">        arm.go()</span><br><span class="line">        rospy.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 控制机械臂回到初始化位置</span></span><br><span class="line">        arm.set_named_target(<span class="string">'home'</span>)</span><br><span class="line">        arm.go()</span><br><span class="line"></span><br><span class="line">        moveit_commander.roscpp_shutdown()</span><br><span class="line">        moveit_commander.os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    MoveAttachedObjectDemo()</span><br></pre></td></tr></table></figure>

<p><strong>关键API:</strong></p>
<ul>
<li>add_box</li>
<li>attach_box</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》01 - 赋值运算符函数</title>
    <url>/2021/08/11/SwordToOffer%20-%2001%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》01-赋值运算符函数"><a href="#《剑指Offer》01-赋值运算符函数" class="headerlink" title="《剑指Offer》01 - 赋值运算符函数"></a>《剑指Offer》01 - 赋值运算符函数</h1><p><strong>题目：如下为类型 CMyString的声明，请为该类型添加赋值运算符函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_pData;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<p>此题非常考察细节，主要有以下几点：</p>
<ul>
<li>（1）返回值的类型是否为该类型的引用，只有这样才能实现<strong>连续赋值</strong>，即 <code>str1 == str2 == str3</code></li>
<li>（2）是否把传入的参数的类型声明为常量引用，提高效率。</li>
<li>（3）特判，传入的参数和当前的实例是不是同一个实例，是的话直接返回</li>
<li>（4）是否释放实例自身已有的内存</li>
</ul>
<h3 id="经典写法："><a href="#经典写法：" class="headerlink" title="经典写法："></a>经典写法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="更进一步，考虑异常安全性（Exception-Safety）"><a href="#更进一步，考虑异常安全性（Exception-Safety）" class="headerlink" title="更进一步，考虑异常安全性（Exception Safety）"></a>更进一步，考虑异常安全性（Exception Safety）</h3><p>上述程序在语句 <code>delete[] m_pData;</code> 和 <code>m_pData = new char[strlen(str.m_pData)+1];</code> 之间，如果在这个时刻出现内存不足，则 <code>new char</code>抛出异常， <code>m_pData</code>将是一个空指针，容易造成程序崩溃。</p>
<p>解决思路：</p>
<ul>
<li>（1）先 <code>new</code>  再 <code>delete</code>，分配内存失败能确保 <code>CMyString</code> 的实例不会被修改</li>
<li>（2）<strong>更好的办法</strong>：先创建一个临时实例，交换临时实例和原来的实例，代码如下：<ul>
<li>临时变量 <code>str_temp</code>，申请的内存为记为 <strong>内1</strong>，自身的记为 <strong>内2</strong>，交换后自身的变为 <strong>内1</strong>，由于 <code>str_temp</code>是局部变量，它申请的内存出了作用域就自动调用<code>str_temp</code> 的析构函数释放了，所以自身的内存 <strong>内1</strong>就被安全释放了。值就存在了 <strong>内2</strong> 地址上。</li>
<li>在<code>CMyString</code>的构造函数李用<code>new</code>来分配内存。如果内存不足抛出诸如<code>bad_alloc</code>等异常，但此时还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        CMyString str_temp(str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>* p_temp = str_temp.m_pData;</span><br><span class="line">        str_temp.m_pData = m_pData;</span><br><span class="line">        m_pData = p_temp;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题1：赋值运算符函数</span></span><br><span class="line"><span class="comment">// 题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span> *pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString &amp;str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    CMyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span> *pData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传进来的是空字符，申请一个长度的字符数组，因为字符串的结尾需要一个占位符'\0'</span></span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        m_pData[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(pData);</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>]; <span class="comment">// + 1 代表'\0'</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str.m_pData);</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::~CMyString()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.返回引用才允许连续赋值</span></span><br><span class="line"><span class="comment">// 2.把传入的参数的类型声明为常量引用，提高代码效率，</span></span><br><span class="line"><span class="comment">//   同时在赋值运算符内不会改变传入的实例的状态</span></span><br><span class="line"><span class="comment">//   因此要为传入的引用参数加上const关键字</span></span><br><span class="line"><span class="comment">// 3.释放实例自身已有的内存</span></span><br><span class="line"><span class="comment">// 4.判断传入的参数和当前的实例(*this)是不是同一个实例，</span></span><br><span class="line"><span class="comment">//   如果是则不进行赋值操作，直接返回</span></span><br><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, m_pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================测试代码====================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Test1: 把一个CMyString的实例赋值给另外一个实例\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char* text = "Hello World"; warning</span></span><br><span class="line">    <span class="keyword">char</span> *text = (<span class="keyword">char</span> *)<span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(text)</span></span>;</span><br><span class="line">    CMyString str2;</span><br><span class="line">    str2 = str1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"期望输出为：%s."</span>, text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"实际输出为："</span>);</span><br><span class="line">    str2.Print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">".\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Test2: 把一个CMyString的实例赋值给它自己\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *text = (<span class="keyword">char</span> *)<span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(text)</span></span>;</span><br><span class="line">    str1 = str1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"期望输出为：%s."</span>, text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"实际输出为："</span>);</span><br><span class="line">    str1.Print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">".\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Test3: 连续赋值\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *text = (<span class="keyword">char</span> *)<span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(text)</span></span>;</span><br><span class="line">    CMyString str2, str3;</span><br><span class="line">    str3 = str2 = str1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"期望输出为：%s."</span>, text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"实际输出为："</span>);</span><br><span class="line">    str2.Print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"期望输出为：%s."</span>, text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"实际输出为："</span>);</span><br><span class="line">    str3.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1();</span><br><span class="line">    Test2();</span><br><span class="line">    Test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210530194011.png" alt=""></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 6.MoveIt！技巧</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%206.MoveIt!%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="六、MoveIt！技巧"><a href="#六、MoveIt！技巧" class="headerlink" title="六、MoveIt！技巧"></a>六、MoveIt！技巧</h1><h2 id="6-1-圆弧轨迹规划"><a href="#6-1-圆弧轨迹规划" class="headerlink" title="6.1 圆弧轨迹规划"></a>6.1 圆弧轨迹规划</h2><p><strong>如何走出笛卡尔空间下的圆弧轨迹？</strong></p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130160027.png" alt="image-20201130160027553" style="zoom:80%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_circle_demo</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201130210544.png" alt="image-20201130210544284" style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/move_group_interface/move_group_interface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/robot_trajectory/robot_trajectory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ros节点</span></span><br><span class="line">	ros::init(argc, argv, <span class="string">"moveit_cartesian_demo"</span>);</span><br><span class="line">    <span class="comment">// 启动spinner， </span></span><br><span class="line">	<span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	spinner.start();</span><br><span class="line"></span><br><span class="line">    moveit::<span class="function">planning_interface::MoveGroupInterface <span class="title">arm</span><span class="params">(<span class="string">"manipulator"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取终端link的名称</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> end_effector_link = arm.getEndEffectorLink();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置目标位置所使用的参考坐标系</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> reference_frame = <span class="string">"base_link"</span>;</span><br><span class="line">    arm.setPoseReferenceFrame(reference_frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当运动规划失败后，允许重新规划</span></span><br><span class="line">    arm.allowReplanning(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置位置(单位：米)和姿态（单位：弧度）的允许误差</span></span><br><span class="line">    arm.setGoalPositionTolerance(<span class="number">0.001</span>);</span><br><span class="line">    arm.setGoalOrientationTolerance(<span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置允许的最大速度和加速度</span></span><br><span class="line">    arm.setMaxAccelerationScalingFactor(<span class="number">0.8</span>);</span><br><span class="line">    arm.setMaxVelocityScalingFactor(<span class="number">0.8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置机器人终端的目标位置，即圆心</span></span><br><span class="line">    geometry_msgs::Pose target_pose;</span><br><span class="line">    target_pose.orientation.x = <span class="number">-0.482974</span>;</span><br><span class="line">    target_pose.orientation.y = <span class="number">0.517043</span>;</span><br><span class="line">    target_pose.orientation.z = <span class="number">-0.504953</span>;</span><br><span class="line">    target_pose.orientation.w = <span class="number">-0.494393</span>;</span><br><span class="line"></span><br><span class="line">    target_pose.<span class="built_in">position</span>.x = <span class="number">0.331958</span>;</span><br><span class="line">    target_pose.<span class="built_in">position</span>.y = <span class="number">0.0</span>;</span><br><span class="line">    target_pose.<span class="built_in">position</span>.z = <span class="number">0.307887</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运动到圆心位置</span></span><br><span class="line">    arm.setPoseTarget(target_pose);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Pose&gt; waypoints;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将初始位姿加入路点列表</span></span><br><span class="line">	waypoints.push_back(target_pose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> centerA = target_pose.<span class="built_in">position</span>.y;</span><br><span class="line">    <span class="keyword">double</span> centerB = target_pose.<span class="built_in">position</span>.z;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0.1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//628个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> th=<span class="number">0.0</span>; th&lt;<span class="number">6.28</span>; th=th+<span class="number">0.01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        target_pose.<span class="built_in">position</span>.y = centerA + radius * <span class="built_in">cos</span>(th);</span><br><span class="line">        target_pose.<span class="built_in">position</span>.z = centerB + radius * <span class="built_in">sin</span>(th);</span><br><span class="line">        waypoints.push_back(target_pose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 笛卡尔空间下的路径规划</span></span><br><span class="line">	moveit_msgs::RobotTrajectory trajectory;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> jump_threshold = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> eef_step = <span class="number">0.01</span>;</span><br><span class="line">	<span class="keyword">double</span> fraction = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxtries = <span class="number">100</span>;   <span class="comment">//最大尝试规划次数</span></span><br><span class="line">    <span class="keyword">int</span> attempts = <span class="number">0</span>;     <span class="comment">//已经尝试规划次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fraction &lt; <span class="number">1.0</span> &amp;&amp; attempts &lt; maxtries)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 理想下fraction=1</span></span><br><span class="line">        fraction = arm.computeCartesianPath(waypoints, eef_step, jump_threshold, trajectory);</span><br><span class="line">        attempts++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(attempts % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            ROS_INFO(<span class="string">"Still trying after %d attempts..."</span>, attempts);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fraction == <span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        ROS_INFO(<span class="string">"Path computed successfully. Moving the arm."</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 生成机械臂的运动规划数据</span></span><br><span class="line">	    moveit::planning_interface::MoveGroupInterface::Plan plan;</span><br><span class="line">	    plan.trajectory_ = trajectory;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 执行运动</span></span><br><span class="line">	    arm.execute(plan);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"Path planning failed with only %0.6f success after %d attempts."</span>, fraction, maxtries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ros::<span class="built_in">shutdown</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-2-轨迹重定义"><a href="#6-2-轨迹重定义" class="headerlink" title="6.2 轨迹重定义"></a>6.2 轨迹重定义</h2><p>如果对moveit规划的轨迹不满意，如速度、加速度、位置等，可以在plan和execute之间重新对轨迹做修改和定义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_anno_moveit_config demo.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_demo moveit_revise_trajectory_demo</span></span><br></pre></td></tr></table></figure>

<p>对轨迹的速度做重定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/move_group_interface/move_group_interface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/robot_trajectory/robot_trajectory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_trajectory_speed</span><span class="params">(moveit::planning_interface::MoveGroupInterface::Plan &amp;plan, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_joints = plan.trajectory_.joint_trajectory.joint_names.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;plan.trajectory_.joint_trajectory.points.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        plan.trajectory_.joint_trajectory.points[i].time_from_start *= <span class="number">1</span>/scale;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n_joints; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            plan.trajectory_.joint_trajectory.points[i].velocities[j] *= scale;</span><br><span class="line">            plan.trajectory_.joint_trajectory.points[i].accelerations[j] *= scale*scale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，设定各种参数限制</span></span><br><span class="line">    ros::init(argc, argv, <span class="string">"moveit_revise_trajectory_demo"</span>);</span><br><span class="line">    ros::NodeHandle node_handle; </span><br><span class="line">    <span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    spinner.start();</span><br><span class="line"></span><br><span class="line">    moveit::<span class="function">planning_interface::MoveGroupInterface <span class="title">arm</span><span class="params">(<span class="string">"manipulator"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    arm.setGoalJointTolerance(<span class="number">0.001</span>);</span><br><span class="line"></span><br><span class="line">    arm.setMaxAccelerationScalingFactor(<span class="number">1</span>);</span><br><span class="line">    arm.setMaxVelocityScalingFactor(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关节空间设置旋转角度得到目标姿态</span></span><br><span class="line">    <span class="keyword">double</span> targetPose[<span class="number">6</span>] = &#123;<span class="number">0.391410</span>, <span class="number">-0.676384</span>, <span class="number">-0.376217</span>, <span class="number">0.0</span>, <span class="number">1.052834</span>, <span class="number">0.454125</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">joint_group_positions</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    joint_group_positions[<span class="number">0</span>] = targetPose[<span class="number">0</span>];</span><br><span class="line">    joint_group_positions[<span class="number">1</span>] = targetPose[<span class="number">1</span>];</span><br><span class="line">    joint_group_positions[<span class="number">2</span>] = targetPose[<span class="number">2</span>];</span><br><span class="line">    joint_group_positions[<span class="number">3</span>] = targetPose[<span class="number">3</span>];</span><br><span class="line">    joint_group_positions[<span class="number">4</span>] = targetPose[<span class="number">4</span>];</span><br><span class="line">    joint_group_positions[<span class="number">5</span>] = targetPose[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    arm.setJointValueTarget(joint_group_positions);</span><br><span class="line">    <span class="comment">// 第一次运行，以默认速度</span></span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标姿态不变</span></span><br><span class="line">    arm.setJointValueTarget(joint_group_positions);</span><br><span class="line">    <span class="comment">// 创建一个plan变量，保存规划的轨迹</span></span><br><span class="line">    moveit::planning_interface::MoveGroupInterface::Plan plan;</span><br><span class="line">    <span class="comment">// 调用MoveGroup规划组完成plan的过程，如果成功，plan里就保存home到目标姿态的轨迹</span></span><br><span class="line">    moveit::planning_interface::MoveItErrorCode success = arm.plan(plan);</span><br><span class="line"></span><br><span class="line">    ROS_INFO(<span class="string">"Plan (pose goal) %s"</span>,success?<span class="string">""</span>:<span class="string">"FAILED"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用自己编写的函数修改速度为原来的1/4</span></span><br><span class="line">    scale_trajectory_speed(plan, <span class="number">0.25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让机械臂按照规划的轨迹开始运动。</span></span><br><span class="line">    <span class="keyword">if</span>(success)</span><br><span class="line">      arm.execute(plan);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">shutdown</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-3-多轨迹连续运动"><a href="#6-3-多轨迹连续运动" class="headerlink" title="6.3 多轨迹连续运动"></a>6.3 多轨迹连续运动</h2><p>如何让多个轨迹的运动速度均匀，而不是一卡一卡的</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201201143023.png" alt="image-20201201143022974" style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/move_group_interface/move_group_interface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/robot_trajectory/robot_trajectory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit/trajectory_processing/iterative_time_parameterization.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;moveit_msgs/OrientationConstraint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::init(argc, argv, <span class="string">"moveit_revise_trajectory_demo"</span>);</span><br><span class="line">    ros::NodeHandle node_handle; </span><br><span class="line">    <span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    spinner.start();</span><br><span class="line"></span><br><span class="line">    moveit::<span class="function">planning_interface::MoveGroupInterface <span class="title">arm</span><span class="params">(<span class="string">"manipulator"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    arm.setGoalJointTolerance(<span class="number">0.001</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> accScale = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">double</span> velScale = <span class="number">0.8</span>;</span><br><span class="line">    arm.setMaxAccelerationScalingFactor(accScale);</span><br><span class="line">    arm.setMaxVelocityScalingFactor(velScale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取机器人的起始位置，start_state用来保存机器人初始状态，因为运动前要先规划好两条轨迹，两条轨迹的起点是不一样的，所以起始状态要做一个状态的切换.</span></span><br><span class="line">    moveit::<span class="function">core::RobotStatePtr <span class="title">start_state</span><span class="params">(arm.getCurrentState())</span></span>;</span><br><span class="line">    <span class="keyword">const</span> robot_state::JointModelGroup *joint_model_group = start_state-&gt;getJointModelGroup(arm.getName());</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 保存目标姿态</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; joint_group_positions;</span><br><span class="line">    start_state-&gt;copyJointGroupPositions(joint_model_group, joint_group_positions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置第一个目标点</span></span><br><span class="line">    joint_group_positions[<span class="number">0</span>] = <span class="number">-0.6</span>;  <span class="comment">// radians</span></span><br><span class="line">    arm.setJointValueTarget(joint_group_positions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第一条轨迹</span></span><br><span class="line">    moveit::planning_interface::MoveGroupInterface::Plan plan1;</span><br><span class="line">    moveit::planning_interface::MoveItErrorCode success = arm.plan(plan1);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 切换一下起点状态</span></span><br><span class="line">    joint_model_group = start_state-&gt;getJointModelGroup(arm.getName());    </span><br><span class="line">    start_state-&gt;setJointGroupPositions(joint_model_group, joint_group_positions);</span><br><span class="line">    arm.setStartState(*start_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置第二个目标点</span></span><br><span class="line">    joint_group_positions[<span class="number">0</span>] = <span class="number">-1.2</span>;  <span class="comment">// radians</span></span><br><span class="line">    joint_group_positions[<span class="number">1</span>] = <span class="number">-0.5</span>;  <span class="comment">// radians</span></span><br><span class="line">    arm.setJointValueTarget(joint_group_positions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第二条轨迹</span></span><br><span class="line">    moveit::planning_interface::MoveGroupInterface::Plan plan2;</span><br><span class="line">    success = arm.plan(plan2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接两条轨迹，这条新轨迹trajectory只有点是正确的，所有的加速度、速度、时间还都是错的，还需要重新规划</span></span><br><span class="line">    moveit_msgs::RobotTrajectory trajectory;</span><br><span class="line">    trajectory.joint_trajectory.joint_names = plan1.trajectory_.joint_trajectory.joint_names;</span><br><span class="line">    trajectory.joint_trajectory.points = plan1.trajectory_.joint_trajectory.points;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt; plan2.trajectory_.joint_trajectory.points.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        trajectory.joint_trajectory.points.push_back(plan2.trajectory_.joint_trajectory.points[j]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 重新规划需要用到iptp算法，先创建一个jointPlan</span></span><br><span class="line">    moveit::planning_interface::MoveGroupInterface::Plan joinedPlan;</span><br><span class="line">    <span class="function">robot_trajectory::RobotTrajectory <span class="title">rt</span><span class="params">(arm.getCurrentState()-&gt;getRobotModel(), <span class="string">"manipulator"</span>)</span></span>;</span><br><span class="line">    rt.setRobotTrajectoryMsg(*arm.getCurrentState(), trajectory);</span><br><span class="line">    trajectory_processing::IterativeParabolicTimeParameterization iptp;</span><br><span class="line">    iptp.computeTimeStamps(rt, velScale, accScale);</span><br><span class="line"></span><br><span class="line">    rt.getRobotTrajectoryMsg(trajectory);</span><br><span class="line">    joinedPlan.trajectory_ = trajectory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arm.execute(joinedPlan))</span><br><span class="line">    &#123;</span><br><span class="line">        ROS_ERROR(<span class="string">"Failed to execute plan"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ROS_INFO(<span class="string">"Finished"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制机械臂先回到初始化位置</span></span><br><span class="line">    arm.setNamedTarget(<span class="string">"home"</span>);</span><br><span class="line">    arm.<span class="built_in">move</span>();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">shutdown</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-4-更换运动学插件"><a href="#6-4-更换运动学插件" class="headerlink" title="6.4 更换运动学插件"></a>6.4 更换运动学插件</h2><h3 id="KDL-MoveIt！默认使用的运动学求解器"><a href="#KDL-MoveIt！默认使用的运动学求解器" class="headerlink" title="KDL MoveIt！默认使用的运动学求解器"></a>KDL MoveIt！默认使用的运动学求解器</h3><ul>
<li>数值解</li>
<li>优点：可求解封闭情况下逆运动学</li>
<li>缺点：速度慢、失败率高</li>
</ul>
<p><a href="http://wiki.ros.org/kdl/" target="_blank" rel="noopener">kdl参考</a></p>
<h3 id="TRAC-IK"><a href="#TRAC-IK" class="headerlink" title="TRAC - IK"></a>TRAC - IK</h3><p><a href="http://docs.ros.org/kinetic/api/moveit_tutorials/html/doc/trac_ik/trac_ik_tutorial.html" target="_blank" rel="noopener">TRAC - IK参考链接</a></p>
<ul>
<li>数值解</li>
<li>速度效率比kdl都要好</li>
</ul>
<p><strong>安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ros-kinetic-trac-ik-kinematics-plugin</span></span><br></pre></td></tr></table></figure>

<p><strong>配置：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rosed <span class="string">"<span class="variable">$MYROBOT_NAME</span>"</span>_moveit_config/config/kinematics.yaml</span></span><br><span class="line"></span><br><span class="line">arm:</span><br><span class="line">  kinematics_solve: trac_ik_kinematics_plugin/TRAC_IKKinematicsPlugin</span><br><span class="line">  kinematics_solve_attempts: 3</span><br><span class="line">  kinematics solver search resolution: 0.005</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201201153638.png" alt="image-20201201153638685"></p>
<p><strong>测试：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo "$MYROBOT_NAME"_moveit_config demo.launch</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201201153729.png" alt="image-20201201153729952"></p>
<h3 id="IKFast"><a href="#IKFast" class="headerlink" title="IKFast"></a>IKFast</h3><p><a href="http://openrave.org/docs/0.8.2/openravepy/ikfast/" target="_blank" rel="noopener">IKFast参考链接</a></p>
<ul>
<li>IKFast，由Rosen Diankov编写的OpenRAVE运动规划软件提供；</li>
<li>可以求解任意复杂运动链的运动学方程（<strong>解析解</strong>），并产生特定语言的文件（如C++）后供使用</li>
<li>比较稳定、速度快，在最新的处理器上能以5微秒的速度完成运算。</li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 7.ROS机器视觉</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%207.ROS%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/</url>
    <content><![CDATA[<h1 id="七、ROS机器视觉"><a href="#七、ROS机器视觉" class="headerlink" title="七、ROS机器视觉"></a>七、ROS机器视觉</h1><h2 id="7-1-ROS图像接口"><a href="#7-1-ROS图像接口" class="headerlink" title="7.1 ROS图像接口"></a>7.1 ROS图像接口</h2><p><strong>摄像头驱动安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ros-kinetic-usb-cam</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_vision usb_cam.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rqt_image_view</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201201162609.png" alt="image-20201201162609077" style="zoom: 80%;" />

<p><strong>ROS定义的图像话题：</strong></p>
<p><strong>sensor_msgs/Image</strong></p>
<ul>
<li>Header：消息头，包含消息序列，时间戳和绑定坐标系</li>
<li>height：图像的纵向分辨率</li>
<li>width：图像的横向分辨率</li>
<li>encoding：图像编码格式，包含RGB、YUV等常用格式，不涉及图像压缩编码</li>
<li>is_bigendian：图像数据的大小端存储模式</li>
<li><strong>step</strong>：一行图像数据的字节数量，作为数据的步长参数，如果是RGB图像，width=480，step则 = 3 * 480 = 1360字节，便于寻址</li>
<li><strong>data</strong>：存储图像数据的数组，大小为 step * height 个字节</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rosmsg show sensor_msgs/Image</span></span><br><span class="line"></span><br><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">uint32 height</span><br><span class="line">uint32 width</span><br><span class="line">string encoding</span><br><span class="line">uint8 is_bigendian</span><br><span class="line">uint32 step</span><br><span class="line">uint8[] data</span><br></pre></td></tr></table></figure>

<p><strong>压缩图像消息  sensor_msgs/CompressedImage：</strong></p>
<ul>
<li>format：图像的压缩编码格式（jpeg、png、bmp）</li>
<li>data：存储图像数据数组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rosmsg show sensor_msgs/CompressedImage</span></span><br><span class="line"></span><br><span class="line">std_msgs/Header header</span><br><span class="line">  uint32 seq</span><br><span class="line">  time stamp</span><br><span class="line">  string frame_id</span><br><span class="line">string format</span><br><span class="line">uint8[] data</span><br></pre></td></tr></table></figure>



<h2 id="7-2-摄像头内参标定"><a href="#7-2-摄像头内参标定" class="headerlink" title="7.2 摄像头内参标定"></a>7.2 摄像头内参标定</h2><h3 id="7-2-1-摄像头为什么要标定？"><a href="#7-2-1-摄像头为什么要标定？" class="headerlink" title="7.2.1 摄像头为什么要标定？"></a>7.2.1 摄像头为什么要标定？</h3><p>摄像头这种精密仪器对光学器件要求较高，由于摄像头内部与外部的一些原因，生成的物体图像往往会发生畸变，为避免数据源造成的误差，需要针对摄像头参数进行标定。</p>
<p>安装标定功能包： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ros-kinetic-camera-calibration</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.108 image:=/camera/color/image_raw camera:=/camera/color --no-service-check</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201207154833.png" alt="image-20201207154826554"></p>
<ul>
<li>X : 左右移动</li>
<li>Y：上下移动</li>
<li>Size：前后移动</li>
<li>Skew：扭转</li>
</ul>
<p>等待 <strong>CALIBRATE</strong> 按钮变蓝，点击即可，等待计算完成后，点击 <strong>SAVE</strong> ,终端打印出保存路径</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201207155311.png" alt="image-20201207155311509"></p>
<p>解压此文件后，选中 <strong>ost.yaml</strong> 文件，即标定结果，复制粘贴到功能包目录下即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image_width:</span> <span class="number">640</span></span><br><span class="line"><span class="attr">image_height:</span> <span class="number">480</span></span><br><span class="line"><span class="attr">camera_name:</span> <span class="string">narrow_stereo</span></span><br><span class="line"><span class="attr">camera_matrix:</span></span><br><span class="line">  <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">[627.878924,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">342.443106</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">625.646792</span><span class="string">,</span> <span class="number">250.452535</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">1.000000</span><span class="string">]</span></span><br><span class="line"><span class="attr">distortion_model:</span> <span class="string">plumb_bob</span></span><br><span class="line"><span class="attr">distortion_coefficients:</span></span><br><span class="line">  <span class="attr">rows:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">cols:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">[0.172732,</span> <span class="number">-0.085637</span><span class="string">,</span> <span class="number">0.010766</span><span class="string">,</span> <span class="number">0.022194</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">]</span></span><br><span class="line"><span class="attr">rectification_matrix:</span></span><br><span class="line">  <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">[1.000000,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">1.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">1.000000</span><span class="string">]</span></span><br><span class="line"><span class="attr">projection_matrix:</span></span><br><span class="line">  <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">cols:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">[660.365295,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">352.083569</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">666.242432</span><span class="string">,</span> <span class="number">253.895221</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">,</span> <span class="number">1.000000</span><span class="string">,</span> <span class="number">0.000000</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>probot_vision/launch/usb_cam_with_calibration.launch</strong> 中替换标定文件即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"usb_cam"</span> <span class="attr">pkg</span>=<span class="string">"usb_cam"</span> <span class="attr">type</span>=<span class="string">"usb_cam_node"</span> <span class="attr">output</span>=<span class="string">"screen"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"video_device"</span> <span class="attr">value</span>=<span class="string">"/dev/video0"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"image_width"</span> <span class="attr">value</span>=<span class="string">"1280"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"image_height"</span> <span class="attr">value</span>=<span class="string">"720"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"pixel_format"</span> <span class="attr">value</span>=<span class="string">"yuyv"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"camera_frame_id"</span> <span class="attr">value</span>=<span class="string">"usb_cam"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"io_method"</span> <span class="attr">value</span>=<span class="string">"mmap"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">       	<span class="comment">&lt;!-- 标定文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"camera_info_url"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"file://$(find probot_vision)/camera_calibration.yaml"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标定文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="7-3-ROS-OpenCV物体识别"><a href="#7-3-ROS-OpenCV物体识别" class="headerlink" title="7.3 ROS + OpenCV物体识别"></a>7.3 ROS + OpenCV物体识别</h2><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201207163532.png" alt="image-20201207163532882"></p>
<p>安装OpenCV</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ros-kinetic-vision-opencv libopencv-dev python-opencv</span></span><br></pre></td></tr></table></figure>



<p><strong>image_converter.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/image_encodings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> OPENCV_WINDOW = <span class="string">"Image window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageConverter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  image_transport::ImageTransport it_;</span><br><span class="line">  image_transport::Subscriber image_sub_;</span><br><span class="line">  image_transport::Publisher image_pub_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  ImageConverter()</span><br><span class="line">    : it_(nh_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Subscrive to input video feed and publish output video feed</span></span><br><span class="line">    <span class="comment">// 创建一个订阅者，订阅处理前的图像</span></span><br><span class="line">    image_sub_ = it_.subscribe(<span class="string">"/usb_cam/image_raw"</span>, <span class="number">1</span>, &amp;ImageConverter::imageCb, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建一个发布者，发布处理完的图像</span></span><br><span class="line">    image_pub_ = it_.advertise(<span class="string">"/image_converter/output_video"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::namedWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ImageConverter()</span><br><span class="line">  &#123;</span><br><span class="line">    cv::destroyWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入到spin过程，spin会不断在队列中找图像消息，一旦有消息进来，就会进入imageCb里（call back）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">imageCb</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 关键API，cv_bridge::toCvCopy可以把图像消息msg变到opencv中，sensor_msgs::image_encodings::BGR8为编码格式，返回的指针指向这个opencv图像的地址</span></span><br><span class="line">      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_ERROR(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//OpenCV代码</span></span><br><span class="line">    <span class="keyword">if</span> (cv_ptr-&gt;<span class="built_in">image</span>.rows &gt; <span class="number">60</span> &amp;&amp; cv_ptr-&gt;<span class="built_in">image</span>.cols &gt; <span class="number">60</span>)</span><br><span class="line">      <span class="comment">// 在图像左上角画一个圈</span></span><br><span class="line">      cv::<span class="built_in">circle</span>(cv_ptr-&gt;<span class="built_in">image</span>, cv::Point(<span class="number">50</span>, <span class="number">50</span>), <span class="number">30</span>, CV_RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update GUI Window</span></span><br><span class="line">    cv::imshow(OPENCV_WINDOW, cv_ptr-&gt;<span class="built_in">image</span>);</span><br><span class="line">    cv::waitKey(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output modified video stream</span></span><br><span class="line">    <span class="comment">// 把OpenCV的图像变成ROS的图像发布出去</span></span><br><span class="line">    image_pub_.publish(cv_ptr-&gt;toImageMsg());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"image_converter"</span>);</span><br><span class="line">  ImageConverter ic;</span><br><span class="line">  ros::spin(); <span class="comment">// 调用spin进入死循环，在循环里不断订阅图像消息并处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>核心代码梳理：</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201207214446.png" alt="image-20201207214446150"></p>
<p><a href="http://wiki.ros.org/cv_bridge/Tutorials" target="_blank" rel="noopener">cv_bridge / Tutorials </a></p>
<h4 id="ROS-OpenCV-物体识别例程"><a href="#ROS-OpenCV-物体识别例程" class="headerlink" title="ROS + OpenCV 物体识别例程"></a>ROS + OpenCV 物体识别例程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_gazebo probot_anno_with_gripper_gazebo_world.launch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun probot_vision visonManger</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rqt_image_view</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201210152342.png" alt="image-20201210152335046"></p>
<p>识别原理是基于颜色的阈值，主要是理解程序的流程：</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201210152529.png" alt="image-20201210152529359"></p>
<p><strong>vision_manager.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"probot_vision/vision_manager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 视觉管理器，完成数据的订阅和发布，数据的处理</span></span><br><span class="line">VisionManager::VisionManager(ros::NodeHandle n_, <span class="keyword">float</span> length, <span class="keyword">float</span> breadth) : it_(n_)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;table_length = length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;table_breadth = breadth;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Subscribe to input video feed and publish object location</span></span><br><span class="line">    <span class="comment">// 订阅摄像头所发布的图像，收到图像后调用imageCb回调函数</span></span><br><span class="line">  	image_sub_  = it_.subscribe(<span class="string">"/probot_anno/camera/image_raw"</span>, <span class="number">1</span>, &amp;VisionManager::imageCb, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 两个识别结果，通过话题发布出去</span></span><br><span class="line">	image1_pub_ = it_.advertise(<span class="string">"/table_detect"</span>, <span class="number">1</span>);</span><br><span class="line">	image2_pub_ = it_.advertise(<span class="string">"/object_detect"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisionManager::get2DLocation</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;msg, <span class="keyword">float</span> &amp;x, <span class="keyword">float</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Rect tablePos;</span><br><span class="line">    <span class="comment">// 识别table</span></span><br><span class="line">	detectTable(msg, tablePos);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 识别object，通过convertToMM把识别到的像素位置转换为以米为单位的实际单位</span></span><br><span class="line">	detect2DObject(msg, x, y, tablePos);</span><br><span class="line">	convertToMM(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisionManager::detectTable</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;msg, cv::Rect &amp;tablePos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Extract Table from the image and assign values to pixel_per_mm fields</span></span><br><span class="line">	cv::Mat BGR[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      cv_ptr_ = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_ERROR(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	cv::Mat &amp;<span class="built_in">image</span> = cv_ptr_-&gt;<span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">	split(<span class="built_in">image</span>, BGR);</span><br><span class="line">	cv::Mat gray_image_red = BGR[<span class="number">2</span>];</span><br><span class="line">	cv::Mat gray_image_green = BGR[<span class="number">1</span>];</span><br><span class="line">	cv::Mat denoiseImage;</span><br><span class="line">	cv::medianBlur(gray_image_red, denoiseImage, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Threshold the Image</span></span><br><span class="line">	cv::Mat binaryImage = denoiseImage;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryImage.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryImage.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> editValue = binaryImage.at&lt;uchar&gt;(i, j);</span><br><span class="line">			<span class="keyword">int</span> editValue2 = gray_image_green.at&lt;uchar&gt;(i, j);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((editValue &gt;= <span class="number">0</span>) &amp;&amp; (editValue &lt; <span class="number">20</span>) &amp;&amp; (editValue2 &gt;= <span class="number">0</span>) &amp;&amp; (editValue2 &lt; <span class="number">20</span>))</span><br><span class="line">			&#123; <span class="comment">// check whether value is within range.</span></span><br><span class="line">				binaryImage.at&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				binaryImage.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dilate(binaryImage, binaryImage, cv::Mat());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the centroid of the of the blob</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; nonZeroPoints;</span><br><span class="line">	cv::findNonZero(binaryImage, nonZeroPoints);</span><br><span class="line">	cv::Rect bbox = cv::boundingRect(nonZeroPoints);</span><br><span class="line">	cv::Point pt;</span><br><span class="line">	pt.x = bbox.x + bbox.<span class="built_in">width</span> / <span class="number">2</span>;</span><br><span class="line">	pt.y = bbox.y + bbox.<span class="built_in">height</span> / <span class="number">2</span>;</span><br><span class="line">	cv::<span class="built_in">circle</span>(<span class="built_in">image</span>, pt, <span class="number">4</span>, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update pixels_per_mm fields</span></span><br><span class="line">	pixels_permm_y = bbox.<span class="built_in">height</span> / table_length;</span><br><span class="line">	pixels_permm_x = bbox.<span class="built_in">width</span>  / table_breadth;</span><br><span class="line"></span><br><span class="line">    tablePos = bbox;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test the conversion values</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pixels in y"</span> &lt;&lt; pixels_permm_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pixels in x"</span> &lt;&lt; pixels_permm_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Draw Contours - For Debugging</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt;&gt; contours;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	cv::findContours(binaryImage, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Scalar color = cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		cv::drawContours(<span class="built_in">image</span>, contours, i, color, <span class="number">3</span>, <span class="number">8</span>, hierarchy, <span class="number">0</span>, cv::Point());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output modified video stream</span></span><br><span class="line"> 	image1_pub_.publish(cv_ptr_-&gt;toImageMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisionManager::detect2DObject</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;msg, <span class="keyword">float</span> &amp;pixel_x, <span class="keyword">float</span> &amp;pixel_y, cv::Rect &amp;tablePos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Implement Color Thresholding and contour findings to get the location of object to be grasped in 2D</span></span><br><span class="line">	cv::Mat gray_image_green;</span><br><span class="line">	cv::Mat BGR[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      cv_ptr_ = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_ERROR(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	cv::Mat &amp;<span class="built_in">image</span> = cv_ptr_-&gt;<span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">	cv::split(<span class="built_in">image</span>, BGR);</span><br><span class="line"></span><br><span class="line">	gray_image_green = BGR[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Denoise the Image</span></span><br><span class="line">	cv::Mat denoiseImage;</span><br><span class="line">	cv::medianBlur(gray_image_green, denoiseImage, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Threshold the Image</span></span><br><span class="line">	cv::Mat binaryImage = denoiseImage;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryImage.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryImage.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((j&lt;tablePos.x+<span class="number">3</span>) || j&gt;(tablePos.x+tablePos.<span class="built_in">width</span><span class="number">-3</span>) || (i&lt;tablePos.y+<span class="number">3</span>) || i&gt;(tablePos.y + tablePos.<span class="built_in">height</span><span class="number">-3</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				binaryImage.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> editValue = binaryImage.at&lt;uchar&gt;(i, j);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((editValue &gt; <span class="number">100</span>) &amp;&amp; (editValue &lt;= <span class="number">255</span>))</span><br><span class="line">				&#123; <span class="comment">// check whether value is within range.</span></span><br><span class="line">					binaryImage.at&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					binaryImage.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dilate(binaryImage, binaryImage, cv::Mat());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the centroid of the of the blob</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; nonZeroPoints;</span><br><span class="line">	cv::findNonZero(binaryImage, nonZeroPoints);</span><br><span class="line">	cv::Rect bbox = cv::boundingRect(nonZeroPoints);</span><br><span class="line">	cv::Point pt;</span><br><span class="line">	pixel_x = bbox.x + bbox.<span class="built_in">width</span> / <span class="number">2</span>;</span><br><span class="line">	pixel_y = bbox.y + bbox.<span class="built_in">height</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test the conversion values</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pixel_x"</span> &lt;&lt; pixel_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pixel_y"</span> &lt;&lt; pixel_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For Drawing</span></span><br><span class="line">	pt.x = bbox.x + bbox.<span class="built_in">width</span> / <span class="number">2</span>;</span><br><span class="line">	pt.y = bbox.y + bbox.<span class="built_in">height</span> / <span class="number">2</span>;</span><br><span class="line">	cv::<span class="built_in">circle</span>(<span class="built_in">image</span>, pt, <span class="number">4</span>, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Draw Contours</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt;&gt; contours;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	cv::findContours(binaryImage, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cv::Scalar color = cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		cv::drawContours(<span class="built_in">image</span>, contours, i, color, <span class="number">3</span>, <span class="number">8</span>, hierarchy, <span class="number">0</span>, cv::Point());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output modified video stream</span></span><br><span class="line"> 	image2_pub_.publish(cv_ptr_-&gt;toImageMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisionManager::convertToMM</span><span class="params">(<span class="keyword">float</span> &amp;x, <span class="keyword">float</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	img_centre_x_ = <span class="number">640</span> / <span class="number">2</span>;</span><br><span class="line">	img_centre_y_ = <span class="number">480</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Convert from pixel to world co-ordinates in the camera frame</span></span><br><span class="line">	x = (x - img_centre_x_) / pixels_permm_x;</span><br><span class="line">	y = (y - img_centre_y_) / pixels_permm_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisionManager::imageCb</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 发布一个log，表示开始做图像的识别</span></span><br><span class="line">    ROS_INFO_STREAM(<span class="string">"Processing the Image to locate the Object..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS_INFO("Image Message Received");</span></span><br><span class="line">    <span class="keyword">float</span> obj_x, obj_y; <span class="comment">// 物体识别后的坐标，单位是米</span></span><br><span class="line">    get2DLocation(msg, obj_x, obj_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Temporary Debugging</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" X-Co-ordinate in Camera Frame :"</span> &lt;&lt; obj_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" Y-Co-ordinate in Camera Frame :"</span> &lt;&lt; obj_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temporary Main Function for testing- This should go away later</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先初始化节点，调用类的创建，在while循环里不断等待接收图像并处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	ros::init(argc, argv, <span class="string">"simple_grasping_vision_detection"</span>);</span><br><span class="line">  	ros::NodeHandle n_;</span><br><span class="line"></span><br><span class="line">  	ROS_INFO_STREAM(<span class="string">"Waiting for two seconds.."</span>);</span><br><span class="line">  	ros::WallDuration(<span class="number">2.0</span>).sleep();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> length = <span class="number">0.3</span>;</span><br><span class="line">	<span class="keyword">float</span> breadth = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">VisionManager <span class="title">vm</span><span class="params">(n_, length, breadth)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ros::ok())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Process image callback</span></span><br><span class="line">		ros::spinOnce();</span><br><span class="line"></span><br><span class="line">		ros::WallDuration(<span class="number">2.0</span>).sleep();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用 之 SELECT POLL EPOLL 模型</title>
    <url>/2021/09/10/SELECT-POLL-EPOLL/</url>
    <content><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h2><h3 id="服务程序的流程"><a href="#服务程序的流程" class="headerlink" title="服务程序的流程"></a>服务程序的流程</h3><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210910085422323.png" alt="image-20210910085422323" style="zoom:67%;" />



<h3 id="详细注释代码："><a href="#详细注释代码：" class="headerlink" title="详细注释代码："></a>详细注释代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的监听端口。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ./tcpselect port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化服务端用于监听的socket。</span></span><br><span class="line">    <span class="keyword">int</span> listensock = initserver(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listensock=%d\n"</span>, listensock);</span><br><span class="line">    <span class="keyword">if</span> (listensock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"initserver() failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前只有一个监听的sock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件的集合，包括监听socket和客户端连接上来的socket。</span></span><br><span class="line">    fd_set readfdset;</span><br><span class="line">    <span class="keyword">int</span> maxfd; <span class="comment">// readfdset中socket的最大值。</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readfdset);     <span class="comment">// 初始化结构体</span></span><br><span class="line">    FD_SET(listensock, &amp;readfdset); <span class="comment">// 把listensock添加到集合中。</span></span><br><span class="line">    maxfd = listensock; <span class="comment">// maxfd表示的是fd_set里最大的sock值，目前只有listensock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 调用select函数时，会改变socket集合的内容，所以要把socket集合保存下来，传一个临时的给select。</span></span><br><span class="line">        fd_set tmpfdset = readfdset;</span><br><span class="line">        <span class="keyword">int</span> infds = select(maxfd + <span class="number">1</span>, &amp;tmpfdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 在这里会阻塞</span></span><br><span class="line">        <span class="comment">// printf("select infds=%d\n",infds);</span></span><br><span class="line">        <span class="comment">// 返回失败。</span></span><br><span class="line">        <span class="keyword">if</span> (infds &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select() failed.\n"</span>);</span><br><span class="line">            perror(<span class="string">"select()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时，在本程序中，select函数最后一个参数为空，不存在超时的情况，但以下代码还是留着。</span></span><br><span class="line">        <span class="keyword">if</span> (infds == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select() timeout.\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查有事件发生的socket，包括监听和客户端连接的socket。</span></span><br><span class="line">        <span class="comment">// 这里是客户端的socket事件，每次都要遍历整个集合，因为可能有多个socket有事件。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(eventfd, &amp;tmpfdset) &lt;= <span class="number">0</span>) <span class="comment">// 用FD_ISSET判断set里哪个sock有事件发生</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (eventfd == listensock)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 如果发生事件的是listensock，表示有新的客户端连上来。即流程图的左分支</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">int</span> clientsock = accept(listensock, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (clientsock &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"accept() failed.\n"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client(socket=%d) connected ok.\n"</span>, clientsock);</span><br><span class="line">                <span class="comment">// 把新的客户端socket加入集合。这里不加在备份集合里，加到原始集合里</span></span><br><span class="line">                FD_SET(clientsock, &amp;readfdset);</span><br><span class="line">                <span class="keyword">if</span> (maxfd &lt; clientsock) <span class="comment">// 加入新的clientsock后更新maxfd</span></span><br><span class="line">                    maxfd = clientsock;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 客户端有数据过来或客户端的socket连接被断开。</span></span><br><span class="line">                <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如何判断是有数据过来，还是断开？用read函数，</span></span><br><span class="line">                <span class="comment">// read函数返回值&lt;0是失败，=0是对方连接关闭，&gt;0读取数据到的大小</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取客户端的数据。</span></span><br><span class="line">                <span class="keyword">ssize_t</span> isize = read(eventfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                <span class="comment">// 发生了错误或socket被对方关闭。</span></span><br><span class="line">                <span class="keyword">if</span> (isize &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client(eventfd=%d) disconnected.\n"</span>, eventfd);</span><br><span class="line">                    close(eventfd);</span><br><span class="line">                    <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line">                    FD_CLR(eventfd, &amp;readfdset);</span><br><span class="line">                    <span class="comment">// 从集合中移去客户端的socket。</span></span><br><span class="line">                    <span class="comment">// 重新计算maxfd的值，注意，只有当eventfd==maxfd时才需要计算。</span></span><br><span class="line">                    <span class="keyword">if</span> (eventfd == maxfd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> ii = maxfd; ii &gt; <span class="number">0</span>; ii--)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (FD_ISSET(ii, &amp;readfdset))</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxfd = ii;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"maxfd=%d\n"</span>, maxfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接受到了客户端的数据 </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv(eventfd=%d,size=%d):%s\n"</span>, eventfd, isize, buffer);</span><br><span class="line">                <span class="comment">// 把收到的报文发回给客户端。</span></span><br><span class="line">                write(eventfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化服务端的监听端口。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket() failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数设置，Linux如下</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;opt, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走流程，创建结构体servdaar，bind绑定到sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind() failed.\n"</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen() failed.\n"</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要accept了，因为accept会阻塞，让select去accept</span></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h3><ul>
<li>select支持的文件描述符数量太小了，默认是1024，虽然可以调整，但是描述符数量越大，效率将更低，调整的意义不大。并发量大就用epoll了</li>
<li>每次调用select，都需要把fdset从用户态拷贝到内核</li>
<li><code>int infds = select(maxfd + 1, &amp;tmpfdset, NULL, NULL, NULL);</code> 当infds大于0时，只是知道有事件发生，但不知道是哪个事件，所以要遍历fdset。同时在线的大量客户端有事件发生的可能不多，但还是要遍历fdset，因此随着监听的描述符数量增长，这一点和第一个缺点是矛盾的，文件描述符设大了，遍历时间就长，其效率也会下降</li>
</ul>
<h3 id="select的其它用途"><a href="#select的其它用途" class="headerlink" title="select的其它用途"></a>select的其它用途</h3><p>在unix世界里，一切皆文件，文件就是一串二进制流，不管socket、管道、终端、设备等都是文件，一切都是流。在信息交换的过程中，都是对这些流进行数据的收发操作，简称IO操作，从流中读数据，系统调用read；写入数据，系统调用write</p>
<p>select是IO复用函数，在网络并发数不高的情况下，性能还是优于epoll的，除了用于网络通信，还可以用于文件、管道、终端、设备等操作，但开发场景比较少</p>
<h2 id="poll模型"><a href="#poll模型" class="headerlink" title="poll模型"></a>poll模型</h2><ul>
<li>poll和select本质上没有差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。<ul>
<li>select采用fdset（fdset采用了bitmap），poll采用了数组，所以表示的描述符比select大</li>
</ul>
</li>
<li>poll和select同样存在一个缺点就是，文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不管这些文件描述符是否有事件，它们的开销随着文件描述符数量的增加而线性增大。</li>
<li>poll返回后，也需要遍历整个描述符的数组才能得到有事件的描述符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// file descriptor</span></span><br><span class="line">    short events; <span class="comment">// requested events</span></span><br><span class="line">    short revents; <span class="comment">// returned events</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="详细注释代码：-1"><a href="#详细注释代码：-1" class="headerlink" title="详细注释代码："></a>详细注释代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// ulimit -n 查看系统能打开文件的数量，根据这个值来定义MAXNFDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNFDS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的监听端口。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ./tcppoll port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化服务端用于监听的socket。</span></span><br><span class="line">    <span class="keyword">int</span> listensock = initserver(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listensock=%d\n"</span>, listensock);</span><br><span class="line">    <span class="keyword">if</span> (listensock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"initserver() failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxfd;</span><br><span class="line">    <span class="comment">// fds数组中需要监视的socket的大小。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">MAXNFDS</span>];</span></span><br><span class="line">    <span class="comment">// fds存放需要监视的socket。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; MAXNFDS; ii++)</span><br><span class="line">        fds[ii].fd = <span class="number">-1</span>; <span class="comment">// 初始化数组，把全部的fd设置为-1。poll会忽略负数的fd</span></span><br><span class="line">    <span class="comment">// 把listensock添加到数组中。</span></span><br><span class="line">    fds[listensock].fd = listensock;</span><br><span class="line">    fds[listensock].events = POLLIN; <span class="comment">// 有数据可读事件，包括新客户端的连接、客户端socket有数据可读和客户端socket断开三种情况。</span></span><br><span class="line">    maxfd = listensock;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里不需要传fds的备份，因为poll修改的是结构体中的revents，fd和events值不变</span></span><br><span class="line">        <span class="keyword">int</span> infds = poll(fds, maxfd + <span class="number">1</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// printf("poll infds=%d\n",infds);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回失败。</span></span><br><span class="line">        <span class="keyword">if</span> (infds &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"poll() failed.\n"</span>);</span><br><span class="line">            perror(<span class="string">"poll():"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时。</span></span><br><span class="line">        <span class="keyword">if</span> (infds == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"poll() timeout.\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查有事情发生的socket，包括监听和客户端连接的socket。</span></span><br><span class="line">        <span class="comment">// 这里是客户端的socket事件，每次都要遍历整个集合，因为可能有多个socket有事件。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fds[eventfd].fd &lt; <span class="number">0</span>) <span class="comment">// 负数忽略</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((fds[eventfd].revents &amp; POLLIN) == <span class="number">0</span>) <span class="comment">// 没有读的事件</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            fds[eventfd].revents = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 先把revents清空。</span></span><br><span class="line">            <span class="keyword">if</span> (eventfd == listensock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果发生事件的是listensock，表示有新的客户端连上来。</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">int</span> clientsock = accept(listensock, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (clientsock &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"accept() failed.\n"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client(socket=%d) connected ok.\n"</span>, clientsock);</span><br><span class="line">                <span class="keyword">if</span> (clientsock &gt; MAXNFDS)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"clientsock(%d)&gt;MAXNFDS(%d)\n"</span>, clientsock, MAXNFDS);</span><br><span class="line">                    close(clientsock);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fds[clientsock].fd = clientsock;</span><br><span class="line">                fds[clientsock].events = POLLIN;</span><br><span class="line">                fds[clientsock].revents = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (maxfd &lt; clientsock)</span><br><span class="line">                    maxfd = clientsock;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"maxfd=%d\n"</span>, maxfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 客户端有数据过来或客户端的socket连接被断开。</span></span><br><span class="line">                <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                <span class="comment">// 读取客户端的数据。</span></span><br><span class="line">                <span class="keyword">ssize_t</span> isize = read(eventfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">                <span class="comment">// 发生了错误或socket被对方关闭。</span></span><br><span class="line">                <span class="keyword">if</span> (isize &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client(eventfd=%d) disconnected.\n"</span>, eventfd);</span><br><span class="line">                    close(eventfd);</span><br><span class="line">                    <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line">                    fds[eventfd].fd = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// 重新计算maxfd的值，注意，只有当eventfd==maxfd时才需要计算。</span></span><br><span class="line">                    <span class="keyword">if</span> (eventfd == maxfd)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> ii = maxfd; ii &gt; <span class="number">0</span>; ii--)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (fds[ii].fd != <span class="number">-1</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxfd = ii;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"maxfd=%d\n"</span>, maxfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv(eventfd=%d,size=%d):%s\n"</span>, eventfd, isize, buffer);</span><br><span class="line">                <span class="comment">// 把收到的报文发回给客户端。</span></span><br><span class="line">                write(eventfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化服务端的监听端口。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket() failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Linux如下</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;opt, len);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind() failed.\n"</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen() failed.\n"</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h2><ul>
<li>epoll解决了select和poll的所有问题（fdset拷贝和轮询），采用了最合理的设计和实现方案</li>
</ul>
<h3 id="epoll的函数和参数"><a href="#epoll的函数和参数" class="headerlink" title="epoll的函数和参数"></a>epoll的函数和参数</h3><ul>
<li>创建epoll的句柄，它本事就是一个fd</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>注册需要监听fd和事件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待事件发生</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="详细注释代码：-2"><a href="#详细注释代码：-2" class="headerlink" title="详细注释代码："></a>详细注释代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:./tcpclient ip port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket() failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect(%s:%s) failed.\n"</span>, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect ok.\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">10000</span>; ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从命令行输入内容。</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        <span class="comment">// sprintf(buf,"1111111111111111111111ii=%08d",ii);</span></span><br><span class="line">        <span class="keyword">if</span> (write(sockfd, buf, <span class="built_in">strlen</span>(buf)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"write() failed.\n"</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (read(sockfd, buf, <span class="keyword">sizeof</span>(buf)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read() failed.\n"</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv:%s\n"</span>, buf);</span><br><span class="line">        <span class="comment">// close(sockfd); break;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="epoll的水平触发和边缘触发"><a href="#epoll的水平触发和边缘触发" class="headerlink" title="epoll的水平触发和边缘触发"></a>epoll的水平触发和边缘触发</h3><ul>
<li><p>水平触发：如果报告了fd后事件没有被处理或数据没有被完全读取，那么epoll会<strong>立即再报告该fd</strong></p>
<ul>
<li>epoll默认为水平触发，<strong>ev.events = EPOLLIN</strong></li>
<li>比如将接收端接收的大小固定为4个字节，如果发送端发送aaaabbbbcc，接收端会处理三次，分别接收aaaa、bbbb、cc</li>
<li>select和poll都是水平触发</li>
</ul>
</li>
<li><p>边缘触发：如果报告了fd后事件没有被处理货数据没有被完全读取，那么epoll会<strong>下次再报告该fd</strong></p>
<ul>
<li><strong>ev.events = EPOLLET</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Unix网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unix网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS MoviIt!学习 - 8.ROS抓取</title>
    <url>/2021/05/27/ROS%20MoviIt!%E6%95%99%E7%A8%8B%20-%208.ROS%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<h1 id="八、ROS抓取"><a href="#八、ROS抓取" class="headerlink" title="八、ROS抓取"></a>八、ROS抓取</h1><h2 id="8-1-视觉抓取中的关键技术"><a href="#8-1-视觉抓取中的关键技术" class="headerlink" title="8.1 视觉抓取中的关键技术"></a>8.1 视觉抓取中的关键技术</h2><ul>
<li>手眼标定（内参、外参）<ul>
<li><a href="http://wiki.ros.org/camera_calibration/" target="_blank" rel="noopener">内参标定_ camera_calibration</a></li>
<li><a href="http://wiki.ros.org/visp_hand2eye_calibration" target="_blank" rel="noopener">外参标定 visp_hand2eye_calibration</a></li>
<li><a href="https://github.com/IFL-CAMP/easy_handeye" target="_blank" rel="noopener">外参标定_ros easy_handeye</a></li>
</ul>
</li>
<li>物体识别与定位<ul>
<li><a href="http://wiki.ros.org/object_recognition" target="_blank" rel="noopener">find_object_2d</a></li>
<li><a href="https://github.com/tensorflow/models/tree/master/research/object_detection" target="_blank" rel="noopener">Tensorflow Object Detection API:</a></li>
<li><a href="http://wiki.ros.org/object_recognition" target="_blank" rel="noopener">object_recognition</a></li>
</ul>
</li>
<li>抓取姿态分析<ul>
<li><a href="http://wiki.ros.org/agile_grasp" target="_blank" rel="noopener">agile_grasp</a></li>
<li><a href="http://wiki.ros.org/graspit" target="_blank" rel="noopener">graspit</a></li>
<li><a href="http://wiki.ros.org/moveit_simple_grasps" target="_blank" rel="noopener">moveit_simple_grasps</a></li>
</ul>
</li>
<li>运动规划<ul>
<li>轨迹规划</li>
<li>运动学</li>
<li>动力学</li>
<li>避障 </li>
</ul>
</li>
</ul>
<h2 id="8-2-手眼标定"><a href="#8-2-手眼标定" class="headerlink" title="8.2 手眼标定"></a>8.2 手眼标定</h2><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214110724.png" alt="image-20201214110717521"></p>
<ul>
<li>eye to hand 求解机械臂base_link和相机坐标系的位置关系</li>
<li>eye in hand 求解机械臂终端和相机坐标系的位置关系</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214111721.png" alt="image-20201214111721206"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214112331.png" alt="image-20201214112331518"></p>
<p>公式左边是第一个位姿，右边是第二个位姿</p>
<p>即求解 X ，X 为 <img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214112053.png" alt="image-20201214112053027">，机器人坐标系和相机坐标系的位置关系</p>
<h3 id="easy-handeye-TF-VISP-Hand-Eye-Calibration"><a href="#easy-handeye-TF-VISP-Hand-Eye-Calibration" class="headerlink" title="easy_handeye: TF / VISP Hand - Eye Calibration"></a>easy_handeye: TF / VISP Hand - Eye Calibration</h3><p><a href="https://github.com/IFL-CAMP/easy_handeye" target="_blank" rel="noopener">easy_handeye</a></p>
<h2 id="8-3-机械臂视觉抓取案例"><a href="#8-3-机械臂视觉抓取案例" class="headerlink" title="8.3 机械臂视觉抓取案例"></a>8.3 机械臂视觉抓取案例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roslaunch probot_grasping probot_anno_grasping_demo.launch</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214145149.png" alt="image-20201214145149426"></p>
<p><strong>grasping_demo.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"probot_grasping/grasping_demo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">GraspingDemo::GraspingDemo(ros::NodeHandle n_, <span class="keyword">float</span> pregrasp_x, <span class="keyword">float</span> pregrasp_y, <span class="keyword">float</span> pregrasp_z, <span class="keyword">float</span> length, <span class="keyword">float</span> breadth) :</span><br><span class="line">    it_(n_), </span><br><span class="line">    armgroup(<span class="string">"manipulator"</span>), </span><br><span class="line">    grippergroup(<span class="string">"gripper"</span>), </span><br><span class="line">    vMng_(length, breadth)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;nh_ = n_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先获取base_link和camera_link的位置关系，即手眼标定的结果，仿真中可以直接将相机添加到urdf文件中</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// waitForTransform用来查询TF树当中是不是存在base_link和camera_link两个坐标系的变换关系，如果存在，通过lookupTransform查询它们的变换关系，把结果保存到camera_to_robot_</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;tf_camera_to_robot.waitForTransform(<span class="string">"/base_link"</span>, <span class="string">"/camera_link"</span>, ros::Time(<span class="number">0</span>), ros::Duration(<span class="number">50.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (tf::TransformException &amp;ex)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"[adventure_tf]: (wait) %s"</span>, ex.what());</span><br><span class="line">    ros::Duration(<span class="number">1.0</span>).sleep();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tf_camera_to_robot.lookupTransform(<span class="string">"/base_link"</span>, <span class="string">"/camera_link"</span>, ros::Time(<span class="number">0</span>), (<span class="keyword">this</span>-&gt;camera_to_robot_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (tf::TransformException &amp;ex)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"[adventure_tf]: (lookup) %s"</span>, ex.what());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  grasp_running = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>-&gt;pregrasp_x = pregrasp_x;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pregrasp_y = pregrasp_y;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pregrasp_z = pregrasp_z;</span><br><span class="line">  <span class="comment">// 在构造函数中让机械臂运动到初始位置</span></span><br><span class="line">  <span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  spinner.start();</span><br><span class="line">  ros::WallDuration(<span class="number">5.0</span>).sleep();</span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Getting into the Grasping Position...."</span>);</span><br><span class="line">  attainPosition(pregrasp_x, pregrasp_y, pregrasp_z);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Subscribe to input video feed and publish object location</span></span><br><span class="line">  <span class="comment">// 订阅图像话题，创建一个订阅者，有图像进来则进入回调函数imageCb</span></span><br><span class="line">  image_sub_ = it_.subscribe(<span class="string">"/probot_anno/camera/image_raw"</span>, <span class="number">1</span>, &amp;GraspingDemo::imageCb, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::imageCb</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 先做cv_bridge变换</span></span><br><span class="line">  <span class="keyword">if</span> (!grasp_running)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO_STREAM(<span class="string">"Processing the Image to locate the Object..."</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_ERROR(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS_INFO("Image Message Received");</span></span><br><span class="line">    <span class="keyword">float</span> obj_x, obj_y;</span><br><span class="line">    <span class="comment">// 得到物体的xy，图像坐标系下，摄像头拍到的图像的中心点为0坐标的xy</span></span><br><span class="line">    vMng_.get2DLocation(cv_ptr-&gt;<span class="built_in">image</span>, obj_x, obj_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Temporary Debugging</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" X-Co-ordinate in Camera Frame :"</span> &lt;&lt; obj_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" Y-Co-ordinate in Camera Frame :"</span> &lt;&lt; obj_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 变换到三维坐标系</span></span><br><span class="line">    obj_camera_frame.setZ(-obj_y);</span><br><span class="line">    obj_camera_frame.setY(-obj_x);</span><br><span class="line">    obj_camera_frame.setX(<span class="number">0.45</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 把物体从相机坐标系下的位置变换为base_link下的位置</span></span><br><span class="line">    obj_robot_frame = camera_to_robot_ * obj_camera_frame;</span><br><span class="line">    grasp_running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Temporary Debugging，将得到的物体在机器人坐标系下的位置打印出来</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" X-Co-ordinate in Robot Frame :"</span> &lt;&lt; obj_robot_frame.getX() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" Y-Co-ordinate in Robot Frame :"</span> &lt;&lt; obj_robot_frame.getY() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">" Z-Co-ordinate in Robot Frame :"</span> &lt;&lt; obj_robot_frame.getZ() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::attainPosition</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS_INFO("The attain position function called");</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For getting the pose</span></span><br><span class="line">  geometry_msgs::PoseStamped currPose = armgroup.getCurrentPose();</span><br><span class="line"></span><br><span class="line">  geometry_msgs::Pose target_pose1;</span><br><span class="line">  target_pose1.orientation = currPose.pose.orientation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Starting Postion before picking</span></span><br><span class="line">  target_pose1.<span class="built_in">position</span>.x = x;</span><br><span class="line">  target_pose1.<span class="built_in">position</span>.y = y;</span><br><span class="line">  target_pose1.<span class="built_in">position</span>.z = z;</span><br><span class="line">  armgroup.setPoseTarget(target_pose1);</span><br><span class="line"></span><br><span class="line">  armgroup.<span class="built_in">move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::attainObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS_INFO("The attain Object function called");</span></span><br><span class="line">  attainPosition(obj_robot_frame.getX(), obj_robot_frame.getY(), obj_robot_frame.getZ() + <span class="number">0.04</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open Gripper</span></span><br><span class="line">  ros::WallDuration(<span class="number">1.0</span>).sleep();</span><br><span class="line">  grippergroup.setNamedTarget(<span class="string">"open"</span>);</span><br><span class="line">  grippergroup.<span class="built_in">move</span>();  <span class="comment">// 让夹爪张开</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Slide down the Object 运动到物体上方0.02米</span></span><br><span class="line">  geometry_msgs::PoseStamped currPose = armgroup.getCurrentPose();</span><br><span class="line">  geometry_msgs::Pose target_pose1;</span><br><span class="line"></span><br><span class="line">  target_pose1.orientation = currPose.pose.orientation;</span><br><span class="line">  target_pose1.<span class="built_in">position</span> = currPose.pose.<span class="built_in">position</span>;</span><br><span class="line"></span><br><span class="line">  target_pose1.<span class="built_in">position</span>.z = obj_robot_frame.getZ() - <span class="number">0.02</span>;</span><br><span class="line">  armgroup.setPoseTarget(target_pose1);</span><br><span class="line">  armgroup.<span class="built_in">move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::grasp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS_INFO("The Grasping function called");</span></span><br><span class="line"></span><br><span class="line">  ros::WallDuration(<span class="number">1.0</span>).sleep();</span><br><span class="line">  grippergroup.setNamedTarget(<span class="string">"close"</span>);</span><br><span class="line">  grippergroup.<span class="built_in">move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::lift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS_INFO("The lift function called");</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For getting the pose</span></span><br><span class="line">  geometry_msgs::PoseStamped currPose = armgroup.getCurrentPose();</span><br><span class="line"></span><br><span class="line">  geometry_msgs::Pose target_pose1;</span><br><span class="line">  target_pose1.orientation = currPose.pose.orientation;</span><br><span class="line">  target_pose1.<span class="built_in">position</span> = currPose.pose.<span class="built_in">position</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Starting Postion after picking</span></span><br><span class="line">  <span class="comment">//target_pose1.position.z = target_pose1.position.z + 0.06;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(rand() % <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    target_pose1.<span class="built_in">position</span>.y = target_pose1.<span class="built_in">position</span>.y + <span class="number">0.02</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    target_pose1.<span class="built_in">position</span>.y = target_pose1.<span class="built_in">position</span>.y - <span class="number">0.02</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  armgroup.setPoseTarget(target_pose1);</span><br><span class="line">  armgroup.<span class="built_in">move</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open Gripper</span></span><br><span class="line">  ros::WallDuration(<span class="number">1.0</span>).sleep();</span><br><span class="line">  grippergroup.setNamedTarget(<span class="string">"open"</span>);</span><br><span class="line">  grippergroup.<span class="built_in">move</span>();</span><br><span class="line"></span><br><span class="line">  target_pose1.<span class="built_in">position</span>.z = target_pose1.<span class="built_in">position</span>.z + <span class="number">0.06</span>;</span><br><span class="line">  armgroup.setPoseTarget(target_pose1);</span><br><span class="line">  armgroup.<span class="built_in">move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::goHome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  geometry_msgs::PoseStamped currPose = armgroup.getCurrentPose();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to Home Position</span></span><br><span class="line">  attainPosition(homePose.pose.<span class="built_in">position</span>.x, homePose.pose.<span class="built_in">position</span>.y, homePose.pose.<span class="built_in">position</span>.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraspingDemo::initiateGrasping</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  spinner.start();</span><br><span class="line">  ros::WallDuration(<span class="number">3.0</span>).sleep();</span><br><span class="line"></span><br><span class="line">  homePose = armgroup.getCurrentPose();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先让机器人靠近物体</span></span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Approaching the Object...."</span>);</span><br><span class="line">  attainObject();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 抓取物体</span></span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Attempting to Grasp the Object now.."</span>);</span><br><span class="line">  grasp();</span><br><span class="line">  </span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Lifting the Object...."</span>);</span><br><span class="line">  lift();</span><br><span class="line"></span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Going back to home position...."</span>);</span><br><span class="line">  goHome();</span><br><span class="line"></span><br><span class="line">  grasp_running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化ros节点</span></span><br><span class="line">  ros::init(argc, argv, <span class="string">"simple_grasping"</span>);</span><br><span class="line">  <span class="keyword">float</span> length, breadth, pregrasp_x, pregrasp_y, pregrasp_z;</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">if</span> (!n.getParam(<span class="string">"probot_grasping/table_length"</span>, length))</span><br><span class="line">    length = <span class="number">0.3</span>;</span><br><span class="line">  <span class="keyword">if</span> (!n.getParam(<span class="string">"probot_grasping/table_breadth"</span>, breadth))</span><br><span class="line">    breadth = <span class="number">0.3</span>;</span><br><span class="line">  <span class="comment">// 抓取前的参数，机械臂起始位置</span></span><br><span class="line">  <span class="keyword">if</span> (!n.getParam(<span class="string">"probot_grasping/pregrasp_x"</span>, pregrasp_x))</span><br><span class="line">    pregrasp_x = <span class="number">0.20</span>;</span><br><span class="line">  <span class="keyword">if</span> (!n.getParam(<span class="string">"probot_grasping/pregrasp_y"</span>, pregrasp_y))</span><br><span class="line">    pregrasp_y = <span class="number">-0.17</span>;</span><br><span class="line">  <span class="keyword">if</span> (!n.getParam(<span class="string">"probot_grasping/pregrasp_z"</span>, pregrasp_z))</span><br><span class="line">    pregrasp_z = <span class="number">0.28</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">GraspingDemo <span class="title">simGrasp</span><span class="params">(n, pregrasp_x, pregrasp_y, pregrasp_z, length, breadth)</span></span>;</span><br><span class="line">  ROS_INFO_STREAM(<span class="string">"Waiting for five seconds.."</span>);</span><br><span class="line"></span><br><span class="line">  ros::WallDuration(<span class="number">5.0</span>).sleep();</span><br><span class="line">  <span class="keyword">while</span> (ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Process image callback</span></span><br><span class="line">    ros::spinOnce();</span><br><span class="line"></span><br><span class="line">    simGrasp.initiateGrasping();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214162512.png" alt="image-20201214162512287"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20201214162627.png" alt="image-20201214162627887"></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ROS</tag>
        <tag>MoveIt!</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》03 - 数组中重复的数字</title>
    <url>/2021/06/17/SwordToOffer%20-%2003%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》03-数组中重复的数字"><a href="#《剑指Offer》03-数组中重复的数字" class="headerlink" title="《剑指Offer》03 - 数组中重复的数字"></a>《剑指Offer》03 - 数组中重复的数字</h1><p><strong>题目：</strong> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 03. 数组中重复的数字</a></p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line">限制：2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<h3 id="方法一：哈希（空间换时间）"><a href="#方法一：哈希（空间换时间）" class="headerlink" title="方法一：哈希（空间换时间）"></a>方法一：哈希（空间换时间）</h3><ul>
<li>这是最容易想到的方法，题目给定了 n 的范围，建立哈希表，查到重复数字直接返回。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums[i]] &gt; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> nums[i];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210616163223161.png" alt="image-20210616163223161"></p>
<ul>
<li>使用set集合，可以减少一定的空间。用unordered_set也可以。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(elem) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> elem;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.insert(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617100158770.png" alt="image-20210617100158770"></p>
<ul>
<li>使用unordered_map和set同理，加强一下对STL使用的熟练度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[elem]) <span class="keyword">return</span> elem;</span><br><span class="line">            <span class="built_in">map</span>[elem] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617102550205.png" alt="image-20210617102550205"></p>
<h3 id="方法二：原地置换"><a href="#方法二：原地置换" class="headerlink" title="方法二：原地置换"></a>方法二：原地置换</h3><p>此方法的空间复杂度为 $O(1)$ ，想法很精妙，但是条件很苛刻，题目中指出了<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>，如果不在n-1范围内则不能使用此方法。</p>
<p>原地置换的原理：遍历数组，当 x1 != nums [x] 时，将数组元素 x1 放到 nums[x]的位置，这样遇到与x1相等的x2时候，再往nums[x]的位置放，则会发现这个位置已经被占了，即找到了重复元素的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">else</span> swap(nums[i],nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210616164213885.png" alt="image-20210616164213885"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》02 - 实现Singleton模式</title>
    <url>/2021/08/11/SwordToOffer%20-%2002%20%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="《剑指Offer》02-实现Singleton模式"><a href="#《剑指Offer》02-实现Singleton模式" class="headerlink" title="《剑指Offer》02 - 实现Singleton模式"></a>《剑指Offer》02 - 实现Singleton模式</h1><p><strong>题目：设计一个类，我们只能生成该类的一个实例</strong></p>
<p><strong>什么是单例模式？</strong><br>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>定义一个单例类：</p>
<ul>
<li>私有化它的构造函数，以防止外界创建单例类的对象；</li>
<li>使用类的私有静态指针变量指向类的唯一实例；</li>
<li>使用一个公有的静态方法获取该实例。</li>
</ul>
<h3 id="1-单线程解法（常见Singleton模式写法）"><a href="#1-单线程解法（常见Singleton模式写法）" class="headerlink" title="(1) - 单线程解法（常见Singleton模式写法）"></a>(1) - 单线程解法（常见Singleton模式写法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">            m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton实例初始化</span></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="keyword">new</span> Singleton(); <span class="comment">// 前面不能加static，会和类外全局static混淆</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">            m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton实例初始化</span></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="keyword">new</span> Singleton(); <span class="comment">// 前面不能加static，会和类外全局static混淆</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单线程获取多次实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 预期结果：两个实例指针指向的地址相同</span></span><br><span class="line">    Singleton *singletonObj = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singletonObj &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Singleton *singletonObj2 = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singletonObj2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Singleton::destroyInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0xcf6140</span></span><br><span class="line"><span class="comment">// 0xcf6140</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>1.1和1.2的区别主要是new的地方不同，但是这两种方法并不等价，<code>Singleton</code>实例初始化时<code>new Singleton()</code> ,其实是线程安全的</p>
</li>
<li><p><strong>这种写法的主要缺点是：多线程情况下，每个线程可能创建出不同的<code>Singleton</code>实例</strong></p>
</li>
</ul>
<h3 id="2-多线程-锁-写法"><a href="#2-多线程-锁-写法" class="headerlink" title="(2) - 多线程 + 锁 写法"></a>(2) - 多线程 + 锁 写法</h3><p>此处进行了两次m_pInstance == NULL的判断，是借鉴了Java的单例模式实现时，使用的所谓的“双检锁”机制。因为进行一次加锁和解锁是需要付出对应的代价的，而进行两次判断，就可以避免多次加锁与解锁操作，同时也保证了线程安全。但是，如果进行大数据的操作，加锁操作将成为一个性能的瓶颈；为此，一种新的单例模式的实现也就出现了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解法二：多线程 + 加锁</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_pInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重点在这**</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GC</span> // 类似<span class="title">Java</span>的垃圾回收器</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~GC() &#123;</span><br><span class="line">            <span class="comment">// 可以在这里释放所有想要释放的资源，比如数据库连接，文件句柄……等等。</span></span><br><span class="line">            <span class="keyword">if</span> (m_pInstance != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"GC: will delete resource !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">                m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类的实例</span></span><br><span class="line">    <span class="keyword">static</span> GC gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton::GC Singleton::gc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* obj1 = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程获取单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，中间可能缺失换行符，属于正常现象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.push_back(thread(print_instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thr : threads) &#123;</span><br><span class="line">        thr.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单线程获取单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，换行符分隔</span></span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test1 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"预期输出：相同的地址，中间可以缺失换行（每次运行结果的排列格式通常不一样）。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test2 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"预期输出：相同的地址，每行一个。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210531143729.png" alt=""></p>
<h3 id="（3）const-static-型实例"><a href="#（3）const-static-型实例" class="headerlink" title="（3）const static 型实例"></a>（3）const static 型实例</h3><p>因为静态初始化在程序开始时，也就是进入主函数之前，由主线程以单线程方式完成了初始化，所以静态初始化实例保证了线程安全性。在性能要求比较高时，就可以使用这种方式，从而避免频繁的加锁和解锁造成的资源浪费。由于上述三种实现，都要考虑到实例的销毁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Singleton* m_pInstance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Singleton *&gt;(m_pInstance); <span class="comment">// 去掉“const”特性</span></span><br><span class="line">        <span class="comment">// 注意！若该函数的返回值改为const static型，则此处不必进行const_cast静态转换</span></span><br><span class="line">        <span class="comment">// 所以该函数可以改为：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const static Singleton* getInstance()&#123;</span></span><br><span class="line"><span class="comment">            return m_pInstance;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">            m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton(); <span class="comment">// 利用const只能定义一次，不能再次修改的特性，static继续保持类内只有一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_singleton_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton *singletonObj = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singletonObj &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个进程获得单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预期结果，打印出相同的地址，之间可能缺失换行符，也属正常现象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(thread(print_singleton_instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads)&#123;</span><br><span class="line">        thr.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test1();</span><br><span class="line">    Singleton::destroyInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210531144406.png" alt="image-20210531144030174"></p>
<h3 id="（4）-在get函数中创建并返回static临时实例的引用"><a href="#（4）-在get函数中创建并返回static临时实例的引用" class="headerlink" title="（4）- 在get函数中创建并返回static临时实例的引用"></a>（4）- 在get函数中创建并返回static临时实例的引用</h3><p>该方法不能人为控制单例实例的销毁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton m_pInstance; <span class="comment">// 注意，声明在该函数内</span></span><br><span class="line">        <span class="keyword">return</span> &amp;m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_singleton_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton *singletonObj = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singletonObj &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个进程获得单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预期结果，打印出相同的地址，之间可能缺失换行符，也属正常现象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(thread(print_singleton_instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads)&#123;</span><br><span class="line">        thr.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个进程获得多次实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预期结果，打印出相同的地址，之间换行符分隔</span></span><br><span class="line">    print_singleton_instance();</span><br><span class="line">    print_singleton_instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test1 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test2 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210531144552.png" alt="image-20210531144552052"></p>
<h3 id="（5）最终方案-显式控制实例销毁"><a href="#（5）最终方案-显式控制实例销毁" class="headerlink" title="（5）最终方案 显式控制实例销毁"></a>（5）最终方案 显式控制实例销毁</h3><p>在上述的四种方法中，除了第四种没有使用new操作符实例化对象以外，其余三种都使用了；</p>
<p> 一般的编程观念是，new操作是需要和delete操作进行匹配的；是的，这种观念是正确的。在上述的实现中，是添加了一个destoryInstance的static函数，这也是最简单，最普通的处理方法了；但是，很多时候很容易忘记调用destoryInstance函数，就像忘记了调用delete操作一样。由于怕忘记delete操作，所以就有了智能指针；那么，在单例模型中，没有“智能单例”，怎么办？</p>
<p>在实际项目中，特别是客户端开发，其实是不在乎这个实例的销毁的。因为，全局就这么一个变量，全局都要用，它的生命周期伴随着软件的生命周期，软件结束了，它也就自然而然的结束了，因为一个程序关闭之后，它会释放它占用的内存资源的，所以，也就没有所谓的内存泄漏了。</p>
<p> 但是，有以下情况，是必须需要进行实例销毁的：</p>
<ul>
<li>在类中，有一些文件锁了，文件句柄，数据库连接等等，这些随着程序的关闭而不会立即关闭的资源，必须要在程序关闭前，进行手动释放；</li>
<li>具有强迫症的程序员。</li>
</ul>
<p>第四种方法能满足第二个条件，但是无法满足第一个条件。最终解决方案如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_pInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重点在这**</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GC</span> // 类似<span class="title">Java</span>的垃圾回收器</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~GC()&#123;</span><br><span class="line">            <span class="comment">// 可以在这里释放所有想要释放的资源，比如数据库连接，文件句柄……等等。</span></span><br><span class="line">            <span class="keyword">if</span>(m_pInstance != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"GC: will delete resource !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">                m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类的实例</span></span><br><span class="line">    <span class="keyword">static</span> GC gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton::GC Singleton::gc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton* obj1 = Singleton::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程获取单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，中间可能缺失换行符，属于正常现象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(thread(print_instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; thr : threads)&#123;</span><br><span class="line">        thr.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单线程获取单例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预期输出：相同的地址，换行符分隔</span></span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">    print_instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test1 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"预期输出：相同的地址，中间可以缺失换行（每次运行结果的排列格式通常不一样）。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test2 begins: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"预期输出：相同的地址，每行一个。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210531145029.png" alt="image-20210531145029134"></p>
<p>在程序运行结束时，系统会调用Singleton的静态成员GC的析构函数，该析构函数会进行资源的释放，而这种资源的释放方式是在程序员“不知道”的情况下进行的，而程序员不用特别的去关心，使用单例模式的代码时，不必关心资源的释放。</p>
<p>那么这种实现方式的原理是什么呢？由于程序在结束的时候，系统会自动析构所有的全局变量，系统也会析构所有类的静态成员变量，因为静态变量和全局变量在内存中，都是存储在静态存储区的，所有静态存储区的变量都会被释放。</p>
<p> 由于此处使用了一个内部GC类，而该类的作用就是用来释放资源，而这种使用技巧在C++中是广泛存在的，见”C++中的RAII机制”。</p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》04 - 二维数组中的查找</title>
    <url>/2021/06/17/SwordToOffer%20-%2004%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="《剑指Offer》04-二维数组中的查找"><a href="#《剑指Offer》04-二维数组中的查找" class="headerlink" title="《剑指Offer》04 - 二维数组中的查找"></a>《剑指Offer》04 - 二维数组中的查找</h1><p><strong>题目</strong>： <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>题目与LeetCode240相同：</strong> <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ul>
<li>矩阵大小为[m,n]，指针为row col，从右上角开始查找，如果这个元素大于target,则肯定不在这一列，将这一列剔除，col–；如果这个元素小于target，则肯定不在这一行，将这一行剔除，就这样用while循环逐渐缩小返回，直到<code>matrix[row][col] == target</code>，返回true。</li>
<li>注意特判，否则空数组传入发生越界错误。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size(); </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; m &amp;&amp; col &gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &gt; target) col--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) row++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617141234922.png" alt="image-20210617141234922"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》08 - 二叉树的下一个节点</title>
    <url>/2021/06/20/SwordToOffer%20-%2008%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》08-二叉树的下一个节点"><a href="#《剑指Offer》08-二叉树的下一个节点" class="headerlink" title="《剑指Offer》08 - 二叉树的下一个节点"></a>《剑指Offer》08 - 二叉树的下一个节点</h1><p><strong>题目：</strong></p>
<p>给定一棵二叉树和其中的一个结点，如何找出<strong>中序遍历</strong>顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210620174050878.png" alt="image-20210620174050878" style="zoom:33%;" />

<ul>
<li>如果一个节点有右子树，那么它的下一个节点就是它的右子树中的最左子节点，比如 b 的下一个节点为 h</li>
<li>如果一个节点没有右子树：<ul>
<li>如果它是它父节点的左子树，那么它的下一个节点就是它的父节点。比如 d 的下一个节点是 b</li>
<li>如果它是它父节点的右子树，需要沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点即是要找的下一个节点。比如 i 的下一个节点是 a</li>
</ul>
</li>
</ul>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BinaryTreeNode *left;</span><br><span class="line">    BinaryTreeNode *right;</span><br><span class="line">    BinaryTreeNode *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode *<span class="title">GetNext</span><span class="params">(BinaryTreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pRight = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (pRight-&gt;left)</span><br><span class="line">            pRight = pRight-&gt;left;</span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;parent)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode *pParent = pNode-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span> (pParent &amp;&amp; pCurrent == pParent-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 构建二叉树 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode *<span class="title">CreateBinaryTreeNode</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode *pNode = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    pNode-&gt;value = value;</span><br><span class="line">    pNode-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    pNode-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    pNode-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectTreeNodes</span><span class="params">(BinaryTreeNode *pParent, BinaryTreeNode *pLeft, BinaryTreeNode *pRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pParent)</span><br><span class="line">    &#123;</span><br><span class="line">        pParent-&gt;left = pLeft;</span><br><span class="line">        pParent-&gt;right = pRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pLeft)</span><br><span class="line">            pLeft-&gt;parent = pParent;</span><br><span class="line">        <span class="keyword">if</span> (pRight)</span><br><span class="line">            pRight-&gt;parent = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTreeNode</span><span class="params">(BinaryTreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"value of this node is: %d\n"</span>, pNode-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"value of its left child is: %d.\n"</span>, pNode-&gt;left-&gt;value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"left child is null.\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"value of its right child is: %d.\n"</span>, pNode-&gt;right-&gt;value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"right child is null.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this node is null.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(BinaryTreeNode *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PrintTreeNode(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;left)</span><br><span class="line">            PrintTree(pRoot-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;right)</span><br><span class="line">            PrintTree(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyTree</span><span class="params">(BinaryTreeNode *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pLeft = pRoot-&gt;left;</span><br><span class="line">        BinaryTreeNode *pRight = pRoot-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> pRoot;</span><br><span class="line">        pRoot = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        DestroyTree(pLeft);</span><br><span class="line">        DestroyTree(pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================测试代码====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="built_in">string</span> testName, BinaryTreeNode *pNode, BinaryTreeNode *expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (testName.size())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; testName &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pNext = GetNext(pNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pNext == expected &amp;&amp; pNext)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pNode-&gt;value &lt;&lt; <span class="string">" 下一个节点为 "</span> &lt;&lt; pNext-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pNext == expected &amp;&amp; !pNext) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pNode-&gt;value &lt;&lt; <span class="string">" 下一个节点为 null"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"FAILED.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            8</span></span><br><span class="line"><span class="comment">//        6      10</span></span><br><span class="line"><span class="comment">//      5   7    9  11</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode *pNode8 = CreateBinaryTreeNode(<span class="number">8</span>);</span><br><span class="line">    BinaryTreeNode *pNode6 = CreateBinaryTreeNode(<span class="number">6</span>);</span><br><span class="line">    BinaryTreeNode *pNode10 = CreateBinaryTreeNode(<span class="number">10</span>);</span><br><span class="line">    BinaryTreeNode *pNode5 = CreateBinaryTreeNode(<span class="number">5</span>);</span><br><span class="line">    BinaryTreeNode *pNode7 = CreateBinaryTreeNode(<span class="number">7</span>);</span><br><span class="line">    BinaryTreeNode *pNode9 = CreateBinaryTreeNode(<span class="number">9</span>);</span><br><span class="line">    BinaryTreeNode *pNode11 = CreateBinaryTreeNode(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    ConnectTreeNodes(pNode8, pNode6, pNode10);</span><br><span class="line">    ConnectTreeNodes(pNode6, pNode5, pNode7);</span><br><span class="line">    ConnectTreeNodes(pNode10, pNode9, pNode11);</span><br><span class="line"></span><br><span class="line">    Test(<span class="string">"Test1"</span>, pNode8, pNode9);</span><br><span class="line">    Test(<span class="string">"Test2"</span>, pNode6, pNode7);</span><br><span class="line">    Test(<span class="string">"Test3"</span>, pNode10, pNode11);</span><br><span class="line">    Test(<span class="string">"Test4"</span>, pNode5, pNode6);</span><br><span class="line">    Test(<span class="string">"Test5"</span>, pNode7, pNode8);</span><br><span class="line">    Test(<span class="string">"Test6"</span>, pNode9, pNode10);</span><br><span class="line">    Test(<span class="string">"Test7"</span>, pNode11, <span class="literal">nullptr</span>);</span><br><span class="line">    DestroyTree(pNode8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestTree();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210620173423353.png" alt="image-20210620173423353"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》05 - 替换空格</title>
    <url>/2021/06/17/SwordToOffer%20-%2005%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="《剑指Offer》05-替换空格"><a href="#《剑指Offer》05-替换空格" class="headerlink" title="《剑指Offer》05 - 替换空格"></a>《剑指Offer》05 - 替换空格</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="方法一：原地扩展，空间-O-1"><a href="#方法一：原地扩展，空间-O-1" class="headerlink" title="方法一：原地扩展，空间$O(1)$"></a>方法一：原地扩展，空间$O(1)$</h4><ul>
<li>先扩展字符串长度，为两倍的空格数量 + 原字符串长度</li>
<li><strong>能迅速想到从后往前替换！</strong>双指针从后面向前遍历，一个指向末尾，一个指向扩展前的字符串末尾</li>
<li>注意循环内的条件是 <code>i &lt; j</code> ，而不是 <code>i != 0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, len = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> elem : s)</span><br><span class="line">            <span class="keyword">if</span> (elem == <span class="string">' '</span>) cnt++;</span><br><span class="line">        </span><br><span class="line">        s.resize(s.size() + <span class="number">2</span> * cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>, j = s.size() - <span class="number">1</span>; i &lt; j; i--, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">' '</span>)  s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j] = <span class="string">'0'</span>;</span><br><span class="line">                s[j<span class="number">-1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                s[j<span class="number">-2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617153526250.png" alt="image-20210617153526250"></p>
<h4 id="方法二：新建字符串，浪费内存，容易想到，不建议"><a href="#方法二：新建字符串，浪费内存，容易想到，不建议" class="headerlink" title="方法二：新建字符串，浪费内存，容易想到，不建议"></a>方法二：新建字符串，浪费内存，容易想到，不建议</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_new;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">' '</span>)</span><br><span class="line">                s_new += s[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s_new += <span class="string">"%20"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s_new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617151544841.png" alt="image-20210617151544841"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》06 - 从尾到头打印链表</title>
    <url>/2021/06/17/SwordToOffer%20-%2006%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="《剑指Offer》06-从尾到头打印链表"><a href="#《剑指Offer》06-从尾到头打印链表" class="headerlink" title="《剑指Offer》06 - 从尾到头打印链表"></a>《剑指Offer》06 - 从尾到头打印链表</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></p>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="方法一：用栈-时间优先"><a href="#方法一：用栈-时间优先" class="headerlink" title="方法一：用栈 时间优先"></a>方法一：用栈 时间优先</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* p  = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">list</span>.push(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">list</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="built_in">list</span>.top();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            <span class="built_in">list</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617155546530.png" alt="image-20210617155546530"></p>
<h4 id="方法二-不用栈-空间优先"><a href="#方法二-不用栈-空间优先" class="headerlink" title="方法二 不用栈 空间优先"></a>方法二 不用栈 空间优先</h4><ul>
<li>先遍历得到结点数</li>
<li>预分配空间建立vector</li>
<li>用反向迭代器 rbegin rend，依次从后往前放入vector</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(cnt)</span></span>;  <span class="comment">// 预分配空间</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.rbegin(); i != v.rend(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            *i = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210617160148113.png" alt="image-20210617160148113"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》09 - 用两个栈实现队列</title>
    <url>/2021/06/20/SwordToOffer%20-%2009%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》09-用两个栈实现队列"><a href="#《剑指Offer》09-用两个栈实现队列" class="headerlink" title="《剑指Offer》09 - 用两个栈实现队列"></a>《剑指Offer》09 - 用两个栈实现队列</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; values &lt;&#x3D; 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br></pre></td></tr></table></figure>



<ul>
<li><p>stack1用来入队，对应 <code>appendTail</code> ，直接push到stack1即可</p>
</li>
<li><p>stack2用来出队，对应 <code>deleteHead</code> ，当需要出队时，需要将stack1的所有值依次pop并push到stack2中，这样stack2的top值即为所要出队的值。做完这个操作后，如果stack2仍为空，则没有元素返回-1。</p>
<ul>
<li>当stack2不为孔，在stack2中的栈顶元素是最先进入队列的元素，stack2.top()可以直接出队。</li>
<li>当stack2为空时，需要将stack1中的元素逐个pop并push到stack2中，stack2.top()再出队。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st1, st2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st1.empty()) st1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!st2.empty()) st2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                st2.push(st1.top());</span><br><span class="line">                st1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st2.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = st2.top();</span><br><span class="line">            st2.pop();</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210620192300002.png" alt="image-20210620192300002"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 10 - 斐波那契数列</title>
    <url>/2021/06/20/SwordToOffer%20-%2010%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-10-斐波那契数列"><a href="#《剑指Offer》-10-斐波那契数列" class="headerlink" title="《剑指Offer》 10 - 斐波那契数列"></a>《剑指Offer》 10 - 斐波那契数列</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></p>
<p>写一个函数，输入 $n$ ，求斐波那契（Fibonacci）数列的第 $n$ 项（即 $F(N)）$。斐波那契数列的定义如下：</p>
<p>$F(0) = 0$,   $F(1) = 1$<br>$F(N) = F(N - 1) + F(N - 2)$, 其中 $N &gt; 1.$</p>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 $10^9+7（1000000007）$，如计算初始结果为：$1000000008$，请返回 $1$。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：常规解法"><a href="#方法一：常规解法" class="headerlink" title="方法一：常规解法"></a>方法一：常规解法</h4><ul>
<li>不推荐使用递归做，若递归深度过大会导致栈溢出</li>
<li>使用动态规划，将每次前两个数的之和存起来，用于下次使用，大大减少了内存的压力。</li>
<li>可以将其理解为一个滚动的数组，注意循环的次数！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">0</span>, fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            fn = (f1 + f2) % <span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            f2 = f1;</span><br><span class="line">            f1 = fn;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210621085052416.png" alt="image-20210621085052416"></p>
<h4 id="方法二：简洁写法"><a href="#方法二：简洁写法" class="headerlink" title="方法二：简洁写法"></a>方法二：简洁写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            arr[i &amp; <span class="number">1</span>] = (arr[<span class="number">0</span>] + arr[<span class="number">1</span>]) % (<span class="keyword">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n &amp; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210621091424829.png" alt="image-20210621091424829"></p>
<p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>题目与LeetCode70相同：</strong><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>, q = <span class="number">0</span>, r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 滚动</span></span><br><span class="line">            r = (p + q) % <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">            q = p;</span><br><span class="line">            p = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210621092430973.png" alt="image-20210621092430973"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 11 - 旋转数组的最小数字</title>
    <url>/2021/06/22/SwordToOffer%20-%2011%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-11-旋转数组的最小数字"><a href="#《剑指Offer》-11-旋转数组的最小数字" class="headerlink" title="《剑指Offer》 11 - 旋转数组的最小数字"></a>《剑指Offer》 11 - 旋转数组的最小数字</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>题目与LeetCode154相同：</strong><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>有序数组，首先想到二分法，由于又是旋转数组，需要做一些变通。</li>
<li>最小值 $x$ 也是旋转点。</li>
<li>设$left，right$为左右指针，$mid$为中点，有以下三种情况：<ul>
<li>当$nums[mid] &gt; nums[right]$ 时，旋转点$x$一定在右边，即区间$ [mid+1,right]$，所以$ left = mid + 1$</li>
<li>当$nums[mid] &lt; nums[right] $时，旋转点$x$一定在左边，即区间$[left, mid]$，所以 $right = m$</li>
<li>当$nums[mid] = nums[right] $时，无法判断mid是在哪个排序数组中。所以缩小范围，$right = right - 1$，缩小区间后会有两种情况：<ul>
<li>$x &lt; right$ ,旋转点仍在区间$ [left, right]$内</li>
<li>$x = right$, 越过了旋转点，但是最终返回的元素值$ nums[left]$ 仍等于旋转点$nums[x]$</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,  <span class="keyword">int</span> right = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) <span class="keyword">return</span> numbers[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] == numbers[right]) right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210621165654981.png" alt="image-20210621165654981"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 12 - 矩阵中的路径</title>
    <url>/2021/06/22/SwordToOffer%20-%2012%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-12-矩阵中的路径"><a href="#《剑指Offer》-12-矩阵中的路径" class="headerlink" title="《剑指Offer》 12 - 矩阵中的路径"></a>《剑指Offer》 12 - 矩阵中的路径</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></p>
<p>给定一个 $m \times n$ 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 $3 \times 4$ 的矩阵中包含单词 <code>&quot;ABCCED&quot;</code>（单词中的字母已标出）。</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210621170029189.png" alt="image-20210621170029189" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; board.length &lt;&#x3D; 200</span><br><span class="line">1 &lt;&#x3D; board[i].length &lt;&#x3D; 200</span><br><span class="line">board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode79相同：</strong><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：使用回溯，注意细节！"><a href="#方法一：使用回溯，注意细节！" class="headerlink" title="方法一：使用回溯，注意细节！"></a>方法一：使用回溯，注意细节！</h4><ul>
<li>为何要将当前元素置为 <code>\0</code> 后还要恢复？<ul>
<li><strong>回溯的前提保持原有样子</strong>。将<code>board[i][j]</code>标记为<code>&#39;\0&#39;</code>只是假设它一定是路径上的一点，然后再从它的上下左右去寻找剩下的。但如果它的上下左右递归下去并不能完美匹配出对应<code>word</code>的所有元素的路径，就说明 <code>board[i][j]</code>并不一定是路径上的一点，我们就去下一个点，假设下一个点一定是路径上的一点，如此往复。所以一旦确定<code>board[i][j]</code>并不一定是路径上的点之后，就要给它恢复才行。</li>
</ul>
</li>
<li><strong>传值传引用的重要性</strong>！！！<ul>
<li>在做此题时，自己的答案和别人的题解写法基本相同，但就是速度和内存差别很大，我的代码运行时在400ms左右，内存在170MB左右。而别人的代码只需要20ms左右时间，7MB多的内存，经过反复对比发现，是在传值的时候用了引用，即 <code>string&amp; word</code> ，可以大大提高运行时间，减少内存消耗。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 使用回溯法解题</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前元素在矩阵board中的行列索引i和j, 当前目标字符在word中的索引k</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.size() || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].size() || j &lt; <span class="number">0</span> || board[i][j] != word[k])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == word.size() - <span class="number">1</span>) <span class="comment">// 记得减去 1 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>; <span class="comment">// 修改为空字符，表示已访问过，防止之后重复访问</span></span><br><span class="line">        <span class="keyword">if</span> (dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)|| <span class="comment">// 向右走</span></span><br><span class="line">            dfs(board, word, i<span class="number">-1</span>, j, k+<span class="number">1</span>)|| <span class="comment">// 向左走</span></span><br><span class="line">            dfs(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>)|| <span class="comment">// 向下走</span></span><br><span class="line">            dfs(board, word, i, j<span class="number">-1</span>, k+<span class="number">1</span>))  <span class="comment">// 向上走</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = word[k]; <span class="comment">// 还原当前矩阵元素，将board[i][j]还原至初始值，即work[k]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210622114220696.png" alt="image-20210622114220696"></p>
<h4 id="方法二：使用数组记录访问过的元素"><a href="#方法二：使用数组记录访问过的元素" class="headerlink" title="方法二：使用数组记录访问过的元素"></a>方法二：使用数组记录访问过的元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isVisited;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        rows = board.size();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 特判</span></span><br><span class="line">        cols = board[<span class="number">0</span>].size();</span><br><span class="line">        isVisited = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>)); <span class="comment">// 全为false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;cols; ++j)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= rows || i &lt; <span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || board[i][j] != word[k] || isVisited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == word.size() - <span class="number">1</span>) <span class="comment">// 记得减去 1 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)|| <span class="comment">// 向右走</span></span><br><span class="line">                   dfs(board, word, i<span class="number">-1</span>, j, k+<span class="number">1</span>)|| <span class="comment">// 向左走</span></span><br><span class="line">                   dfs(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>)|| <span class="comment">// 向下走</span></span><br><span class="line">                   dfs(board, word, i, j<span class="number">-1</span>, k+<span class="number">1</span>);  <span class="comment">// 向上走</span></span><br><span class="line">        isVisited[i][j] = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 13 - 机器人的运动范围</title>
    <url>/2021/06/22/SwordToOffer%20-%2013%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-13-机器人的运动范围"><a href="#《剑指Offer》-13-机器人的运动范围" class="headerlink" title="《剑指Offer》 13 - 机器人的运动范围"></a>《剑指Offer》 13 - 机器人的运动范围</h1><p>  <strong>题目：</strong><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></p>
<p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当<code>k</code>为<code>18</code>时，机器人能够进入方格 <code>[35, 37]</code> ，因为<code>3+5+3+7=18</code>。但它不能进入方格 <code>[35, 38]</code>，因为<code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n,m &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 20</span><br></pre></td></tr></table></figure>

<p>##　题解：</p>
<h4 id="方法一：DFS-回溯"><a href="#方法一：DFS-回溯" class="headerlink" title="方法一：DFS - 回溯"></a>方法一：DFS - 回溯</h4><ul>
<li>此题与《剑指Offer》第12题矩阵中的路径类似。</li>
<li>此题机器人<strong>仅可通过向右和向下移动，访问所有可达解</strong>，这一点是第一次做此题没有想到的。</li>
<li>DFS：通过递归，先朝一个方向搜到底，再回溯至上一个节点，沿另一个方向搜索，以此类推。</li>
<li>剪枝：在搜索中，遇到数和和大于k、此元素已经访问过，则立即返回，即<strong>可行性剪枝</strong>。</li>
<li>递推工作：<ul>
<li>标记当前单元格 ：将索引<code>(i, j)</code>存入<code>visited</code> 中，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 </li>
</ul>
</li>
<li>回溯返回值：返回 <strong>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</strong>，代表从本单元格递归搜索的可达解总数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, k, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">10</span> + i / <span class="number">10</span> + j % <span class="number">10</span> + j / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> &amp;m, <span class="keyword">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || k &lt; calSum(i, j) || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, k, m, n) + dfs(i, j + <span class="number">1</span>, k, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210622153808120.png" alt="image-20210622153808120"></p>
<h4 id="方法二-BFS-用栈"><a href="#方法二-BFS-用栈" class="headerlink" title="方法二 BFS - 用栈"></a>方法二 BFS - 用栈</h4><ul>
<li><p>初始化： 将机器人初始点<code>(0, 0)(0,0)</code>加入队列<code>queue</code>；</p>
</li>
<li><p>迭代终止条件： <code>queue 为空</code>。代表已遍历完所有可达解。</p>
</li>
<li><p>迭代工作：</p>
<ul>
<li><p>单元格出队： 将队首单元格的索引弹出，作为当前搜索单元格。</p>
</li>
<li><p>判断是否跳过： 若 ①行列索引越界 或 ② 数位和超出目标值 <code>k</code> 或 ③ 当前元素已访问过 时，执行 <code>continue</code> 跳过，<code>visited[i][j]</code>不会置为<code>true</code> 。</p>
</li>
<li><p>标记当前单元格 ：将单元格索引 <code>(i, j)</code> 存入 <code>visited</code> 中，代表此单元格 已被访问过 。</p>
</li>
<li><p>单元格入队： 将当前元素的 下方、右方 单元格的 索引加入 <code>queue</code>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push(&#123;<span class="number">0</span>, <span class="number">0</span>,&#125;);</span><br><span class="line">        <span class="keyword">while</span>(que.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; calSum(i, j) || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            que.push(&#123;i+<span class="number">1</span>, j&#125;);</span><br><span class="line">            que.push(&#123;i, j+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">10</span> + i / <span class="number">10</span> + j % <span class="number">10</span> + j / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210622160300989.png" alt="image-20210622160300989"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》07 - 重建二叉树</title>
    <url>/2021/06/19/SwordToOffer%20-%2007%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="《剑指Offer》07-重建二叉树"><a href="#《剑指Offer》07-重建二叉树" class="headerlink" title="《剑指Offer》07 - 重建二叉树"></a>《剑指Offer》07 - 重建二叉树</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<pre><code>例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：    

    3
   / \
  9  20
    /  \
   15   7

限制：
0 &lt;= 节点个数 &lt;= 5000</code></pre><p>题目与LeetCode105相同：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：时间有先，用了map，适用于没有重复的元素"><a href="#方法一：时间有先，用了map，适用于没有重复的元素" class="headerlink" title="方法一：时间有先，用了map，适用于没有重复的元素"></a>方法一：时间有先，用了map，适用于没有重复的元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210618092147217.png" alt="image-20210618092147217"></p>
<h4 id="方法二：空间优先，不用map，节省空间，浪费时间，可以有重复元素"><a href="#方法二：空间优先，不用map，节省空间，浪费时间，可以有重复元素" class="headerlink" title="方法二：空间优先，不用map，节省空间，浪费时间，可以有重复元素"></a>方法二：空间优先，不用map，节省空间，浪费时间，可以有重复元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ino, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; r1 || l2 &gt; r2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 == r1) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[l1]);</span><br><span class="line">        <span class="keyword">if</span> (l2 == r2) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(ino[l2]);</span><br><span class="line">        <span class="keyword">int</span> idx = l2;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt;= r2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ino[idx] == pre[l1]) <span class="keyword">break</span>;</span><br><span class="line">            idx ++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[l1]);</span><br><span class="line">        root-&gt;left = helper(pre, ino, l1+<span class="number">1</span>, l1+idx-l2, l2, idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = helper(pre, ino, l1+idx-l2+<span class="number">1</span>, r1, idx+<span class="number">1</span>, r2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210618092817412.png" alt="image-20210618092817412"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 14 - 剪绳子</title>
    <url>/2021/06/22/SwordToOffer%20-%2014%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-14-剪绳子"><a href="#《剑指Offer》-14-剪绳子" class="headerlink" title="《剑指Offer》 14 - 剪绳子"></a>《剑指Offer》 14 - 剪绳子</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></p>
<p>给你一根长度为 <code>n</code>的绳子，请把绳子剪成整数长度的 <code>m</code> 段（<code>m、n</code>都是整数，<code>n &gt; 1</code>并且<code>m &gt; 1</code>），每段绳子的长度记为<code>k[0],k[1]...k[m-1]</code> 。请问<code>k[0]*k[1]*...*k[m-1]</code>可能的最大乘积是多少？例如，当绳子的长度是<code>8</code>时，我们把它剪成长度分别为<code>2、3、3</code>的三段，此时得到的最大乘积是<code>18</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode343相同：</strong><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h4><ul>
<li><p><strong>动态规划的四个特点：</strong></p>
<ul>
<li>1 - 求一个问题的最优解（通常是最大值和最小值）</li>
<li>2 - 整体问题的最优解是依赖各个子问题的最优解</li>
<li>3 - 可以把大问题分解成若干个小问题，这些I啊哦问题之间还有相互重叠的更小的子问题</li>
<li>4 - 从上往下分析问题，从下往上求解问题</li>
</ul>
</li>
<li><p>在剪第一刀的时候就有<code>n-1</code>个选择，然后可以剪在长度为<code>1,2,...,n-1</code>的任意位置。即$f(n) = max(f(i) \times f(n-i))$，其中$0 &lt; i &lt;n$。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> product = dp[j] * dp[i - j];</span><br><span class="line">                <span class="keyword">if</span>(max &lt; product)</span><br><span class="line">                    max = product;</span><br><span class="line">                dp[i] = max;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>####　方法二　贪心算法</p>
<ul>
<li>当选则贪心算法解决问题时，要想清楚为什么这样的贪心选择可以得到最优解？这是应用贪心算法时都需要考虑的问题，需要用数学方式来证明贪婪选择是正确的</li>
</ul>
<p>设将$x$等分为$a$段，则$n=ax$，$a=\frac{n}{x}$，乘积为 $x^a$，故：</p>
<p>$$x^a=x^{\frac{n}{x}}=(x^{\frac{1}{x}})^n$$</p>
<p>即求 $y=(x^{\frac{1}{x}})$的极大值，对$x$求导，先取对数，过程如下：</p>
<p>$$\ln{y} = \frac{1}{x}\ln{x}$$</p>
<p>$$\frac{1}{y}y’ = \frac{1}{x^2} - \frac{1}{x^2}\ln{x} = \frac{1-\ln{x}}{x^2}$$</p>
<p>$$y’ = \frac{1-\ln{x}}{x^2}x^{\frac{1}{x}}$$</p>
<p>令$y’=0$，则$1-\ln{x} = 0$，则驻点$x_0 = e \approx 2.7$，根据单调性得 $x_0$ 是极大值点，因为$x$必须是整数，代入验算可知取 $3$ 时乘积最大。</p>
<ul>
<li>从上述推导可知，$n &lt;= 3$ 时，按照规则必须切一刀，因此必须剪出一段长为 1 的绳子，即返回 $n-1$。</li>
<li>当 $n &gt; 3$时， $n = 3a + b$：<ul>
<li>$b=0$ 返回  $3^a$</li>
<li>$b=1$ 返回 $3^{a-1} \times 4$</li>
<li>$b=2$ 返回 $3^a \times 2$</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)  <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)  <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);          </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>)  <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a<span class="number">-1</span>) * <span class="number">4</span>;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210622203546745.png" alt="image-20210622203546745"></p>
<p><strong>上述方法的简洁写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">3</span> ? n - <span class="number">1</span> : <span class="built_in">pow</span>(<span class="number">3</span>, n / <span class="number">3</span>) * <span class="number">4</span> / (<span class="number">4</span> - n % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></p>
<p>给你一根长度为 <code>n</code>的绳子，请把绳子剪成整数长度的 <code>m</code> 段（<code>m、n</code>都是整数，<code>n &gt; 1</code>并且<code>m &gt; 1</code>），每段绳子的长度记为<code>k[0],k[1]...k[m-1]</code> 。请问<code>k[0]*k[1]*...*k[m-1]</code>可能的最大乘积是多少？例如，当绳子的长度是<code>8</code>时，我们把它剪成长度分别为<code>2、3、3</code>的三段，此时得到的最大乘积是<code>18</code>。</p>
<p><strong>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</strong></p>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>动态规划会超时，直接用上述的方法也会发生越界错误。要换个思路，边用3边取余</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            res = res % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210622205427746.png" alt="image-20210622205427746"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 15 - 二进制中 1 的个数</title>
    <url>/2021/06/23/SwordToOffer%20-%2015%20%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%201%20%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-15-二进制中-1-的个数"><a href="#《剑指Offer》-15-二进制中-1-的个数" class="headerlink" title="《剑指Offer》 15 - 二进制中 1 的个数"></a>《剑指Offer》 15 - 二进制中 1 的个数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中<code>1</code>的个数。例如，把<code>9</code>表示成二进制是 <code>1001</code>，有<code>2</code>位是<code>1</code>。因此，如果输入 <code>9</code>，则该函数输出<code>2</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输入必须是长度为 32 的 二进制串 。</span><br></pre></td></tr></table></figure>

<p><strong>此题与LeetCode191相同：</strong><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ul>
<li>自己的写法，还有很多细节需要优化。</li>
<li>虽然题目输入参数是<code>uint32_t</code>类型，但如果是输入负数，此解法存在问题，由于右移是高位补1，如果一直做右移运算，最终数字会变成<code>0xFFFFFFFF</code>，从而陷入死循环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623094631405.png" alt="image-20210623094631405"></p>
<ul>
<li>为了避免死循环，可以不右移输入的数字 <code>n</code>，首先把<code>n</code>和<code>1</code>相与，判断<code>n</code>的最低位是不是<code>1</code>，接着把<code>1</code>左移一位变成<code>2</code>，再和<code>n</code>做与运算，就能判断<code>n</code>的次低位是不是<code>1</code>，以此类推。<code>00000000000000000000000000000001</code>左移一位是<code>00000000000000000000000000000010</code>，再左移是<code>00000000000000000000000000000100</code>，从而做到逐个位置判断是否为1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; flag) cnt++;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623093414317.png" alt="image-20210623093414317"></p>
<h4 id="方法二：巧用-n-amp-n-1"><a href="#方法二：巧用-n-amp-n-1" class="headerlink" title="方法二：巧用 n &amp; (n - 1)"></a>方法二：巧用 n &amp; (n - 1)</h4><ul>
<li><p>上述解法中，循环的次数等于整数二进制的位数，32位的整数需要循环32次，而使用<strong>n &amp; ( n - 1 )</strong>，整数中有几个<code>1</code>就只循环几次。</p>
</li>
<li><p><strong>n &amp; ( n - 1 )</strong>，其运算结果恰为把<code>n</code>的二进制位中的最低位的 <code>1</code> 变为 <code>0</code> 之后的结果。</p>
</li>
<li><p>如 <code>6 &amp; (6 - 1) = 4</code>，<code>6 = 110B</code>， <code>4 = 100B</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623093414317.png" alt="image-20210623093414317"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 16 - 数值的整数次方</title>
    <url>/2021/06/23/SwordToOffer%20-%2016%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-16-数值的整数次方"><a href="#《剑指Offer》-16-数值的整数次方" class="headerlink" title="《剑指Offer》 16 - 数值的整数次方"></a>《剑指Offer》 16 - 数值的整数次方</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></p>
<p>实现 <code>pow(x, n)</code>，即计算 <code>x</code>的 <code>n</code> 次幂函数，即 $x^n$。不得使用库函数，同时不需要考虑大数问题。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p>取值范围：$-100 &lt; x &lt; 100.0$、 $ -2^{31} &lt;= n &lt;=2^{31}=1$、 $-10^4&lt;= x^n&lt;=10^4$</p>
<p><strong>本题与LeetCode50相同：</strong><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>C++中 <code>int</code>类型的取值范围是 <code>-2147483648 ~ 2147483647</code>，所以当<code>n = -2147483648 时</code>，<code>n = -n</code>会发生越界错误。</li>
<li>如果依次求解$x^1,x^2,…,x^{n-1},x^n$，则时间复杂度为$O(n)$。<strong>快速幂</strong>可以将时间复杂度降低至$O(\log_2{n})$，快速幂可以从<strong>二分法</strong>和<strong>二进制</strong>两个角度实现。</li>
</ul>
<h4 id="方法一：快速幂（二进制角度）"><a href="#方法一：快速幂（二进制角度）" class="headerlink" title="方法一：快速幂（二进制角度）"></a>方法一：快速幂（二进制角度）</h4><ul>
<li>举例说明，计算$x^{10}$，$10$转换为二进制$1010$, $1010$转十进制的计算过程为 $2^3+2^0+2^1+2^0=10$，则$x^{10} = x^{2^3+0+2^1+0}=x^8*x^2=10$，只计算了$3$次乘法，时间复杂度为 $O(\log{n})$ 。</li>
<li>通过<code>while</code>循环中计算$x^1, x^2, x^3,…$ ，通过 <code>if ((ln &amp; 1) == 1)</code> 从$x^1, x^2, x^3,…$ 中选出二进制对应为1的项相乘。</li>
<li>时间复杂度：$O(\log{n})$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ln = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ln &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            ln = -ln;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ln &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ln &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                res *= x;  <span class="comment">// 从 x^1, x^2, x^3,... 中选出二进制对应为1的项相乘</span></span><br><span class="line">            x *= x;        <span class="comment">// 计算 x^1, x^2, x^3,...</span></span><br><span class="line">            ln &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623143840471.png" alt="image-20210623143840471"></p>
<h4 id="方法二：快速幂（二分法角度-递归）"><a href="#方法二：快速幂（二分法角度-递归）" class="headerlink" title="方法二：快速幂（二分法角度 递归）"></a>方法二：快速幂（二分法角度 递归）</h4><ul>
<li><p>当 <code>n</code>为偶数时：$x^n = (x^2)^{\frac{n}{2}}$</p>
</li>
<li><p>当 `n 为奇数时：$x^n=x(x^2)^{\frac{n-1}{2}}$</p>
</li>
<li><p>转换为位运算：</p>
<ul>
<li>向下整除<code>n//2</code><strong>等价于</strong> 右移一位 <code>n &gt;&gt; 1</code> ；</li>
<li>取余数<code>n % 2</code> <strong>等价于</strong> 判断二进制最右一位值 <code>n &amp; 1</code> ；</li>
</ul>
</li>
<li><p>时间复杂度：$O(\log{n})$</p>
</li>
<li><p>空间复杂度：$O(\log{n})$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ln = n;</span><br><span class="line">        <span class="keyword">if</span> (ln &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            ln = -ln;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ln &amp; <span class="number">1</span> ? x * myPow(x * x, ln &gt;&gt; <span class="number">1</span>) : myPow(x * x, ln &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623151344884.png" alt="image-20210623151344884"></p>
<h4 id="方法三：循环累乘，效率低下（超时），但是注意到了-2147483648-取绝对值越界问题"><a href="#方法三：循环累乘，效率低下（超时），但是注意到了-2147483648-取绝对值越界问题" class="headerlink" title="方法三：循环累乘，效率低下（超时），但是注意到了 -2147483648 取绝对值越界问题"></a>方法三：循环累乘，效率低下（超时），但是注意到了 -2147483648 取绝对值越界问题</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x<span class="number">-0.0</span>)&lt;=<span class="number">1e-6</span> &amp;&amp; n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uint32_t</span> abs_n = (<span class="keyword">uint32_t</span>)n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) abs_n = -(<span class="keyword">uint32_t</span>)n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = _myPow(x,abs_n);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span> / result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> _myPow(<span class="keyword">double</span> x, <span class="keyword">uint32_t</span> <span class="built_in">exp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">exp</span>; ++i)</span><br><span class="line">            result *= x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>此题是《剑指Offer》第三章 高质量的代码 第一题。介绍了三种处理错误的方法：</p>
<ul>
<li>1 - 函数用返回值来告知调用者是否出错</li>
<li>2 - 当错误发生时设置一个全局变量</li>
<li>3 - 异常，函数运行出错时，抛出一个异常</li>
</ul>
<p>虽然下面的解法效率较低，但代码的规法性是值得学习的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>; <span class="comment">// 采用全局变量来标识是否出错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (equal(base, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) (exponent);</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>)</span><br><span class="line">        absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) (-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span> / result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    result *= result;</span><br><span class="line">    <span class="keyword">if</span> ((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((num1 - num2 &gt; <span class="number">-0.0000001</span>) &amp;&amp; (num1 - num2 &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 17 - 打印从1到最大的n位数</title>
    <url>/2021/06/23/SwordToOffer%20-%2017%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-17-打印从1到最大的n位数"><a href="#《剑指Offer》-17-打印从1到最大的n位数" class="headerlink" title="《剑指Offer》 17 - 打印从1到最大的n位数"></a>《剑指Offer》 17 - 打印从1到最大的n位数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></p>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">用返回一个整数列表来代替打印</span><br><span class="line">n 为正整数</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：常规解法，在LeetCode上可以通过，但在面试时不推荐"><a href="#方法一：常规解法，在LeetCode上可以通过，但在面试时不推荐" class="headerlink" title="方法一：常规解法，在LeetCode上可以通过，但在面试时不推荐"></a>方法一：常规解法，在LeetCode上可以通过，但在面试时不推荐</h4><ul>
<li>用快速幂代替 <code>pow</code>库函数，可以提高运算效率</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                result *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result; ++i) &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623155700019.png" alt="image-20210623155700019"></p>
<h4 id="方法二：大数运算-递归生成全排列"><a href="#方法二：大数运算-递归生成全排列" class="headerlink" title="方法二：大数运算 + 递归生成全排列"></a>方法二：大数运算 + 递归生成全排列</h4><ul>
<li>在求最大的<code>n</code>位数时，无论是<code>int</code>、<code>long</code>、<code>long long</code>都会可能溢出，所以此题最好使用大数运算</li>
<li>使用递归生成全排列</li>
<li>虽然运行时间和空间效率不高，但此方法才是最普适性的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        s.resize(n, <span class="string">'0'</span>);</span><br><span class="line">        dfs(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举所有情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == end) &#123;</span><br><span class="line">            save(); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            s[index] = i + <span class="string">'0'</span>;</span><br><span class="line">            dfs(end, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除首部0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; s.size() &amp;&amp; s[ptr] == <span class="string">'0'</span>) ptr++;</span><br><span class="line">        <span class="keyword">if</span> (ptr != s.size())</span><br><span class="line">            nums.emplace_back(stoi(s.substr(ptr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623171704393.png" alt="image-20210623171704393"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 18 - 删除链表的节点</title>
    <url>/2021/06/23/SwordToOffer%20-%2018%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-18-删除链表的节点"><a href="#《剑指Offer》-18-删除链表的节点" class="headerlink" title="《剑指Offer》 18 - 删除链表的节点"></a>《剑指Offer》 18 - 删除链表的节点</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">题目保证链表中节点的值互不相同</span><br><span class="line">若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：单指针遍历"><a href="#方法一：单指针遍历" class="headerlink" title="方法一：单指针遍历"></a>方法一：单指针遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623203816837.png" alt="image-20210623203816837"></p>
<h4 id="方法二：双指针遍历"><a href="#方法二：双指针遍历" class="headerlink" title="方法二：双指针遍历"></a>方法二：双指针遍历</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *p = head, *q = head-&gt;next;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">while</span> (q &amp;&amp; (q-&gt;val != val))</span><br><span class="line">        &#123;</span><br><span class="line">            p = q; <span class="comment">// p = p-&gt;next</span></span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q) p-&gt;next = q-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210623203441213.png" alt="image-20210623203441213"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 19 - 正则表达式匹配</title>
    <url>/2021/06/24/SwordToOffer%20-%2019%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-19-正则表达式匹配"><a href="#《剑指Offer》-19-正则表达式匹配" class="headerlink" title="《剑指Offer》 19 - 正则表达式匹配"></a>《剑指Offer》 19 - 正则表达式匹配</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">剑指 Offer 19. 正则表达式匹配</a></p>
<p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode10相同：</strong><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h4><p>设<code>s</code>长为<code>n</code>，<code>p</code>长为<code>m</code>，由于两个空串的匹配的，所以从<code>s[:1]</code>,<code>p[:1]</code>开始判断，每轮添加一个字符，直到<code>s[:n]</code>, <code>p[:m]</code>，假设 <code>s[:i]</code>与<code>p[:j]</code> 可以匹配，则下一个状态有：</p>
<ul>
<li>添加 $s_{i+1}$ 后是否匹配</li>
<li>添加 $p_{i+1}$否是否匹配</li>
</ul>
<p>共 $m \times n$种状态，定义<code>dp[m][n]</code>，<code>dp[i][j]</code>代表 <code>s[:i]</code>与<code>p[:j]</code>是否可以匹配</p>
<p><strong>状态转移方程：</strong> 由于<code>dp[0][0]</code> 是空字符串,所以 <code>dp[i][j]</code> 对应要添加的字符是 <code>s[i-1]</code> 、<code>p[j-1]</code></p>
<ul>
<li>当 <code>p[j-1] = &#39;*&#39;</code> ：要将<code>p[j-2] *</code>看做一个整体，<code>dp[i][j]</code> 在以下任一情况为<code>true</code> 时为<code>true</code><ul>
<li>1 - <code>dp[i][j-2] = true</code>，即将<code>p[j-2] *</code>看做<code>0</code>次，忽略<code>p[j-2]</code>后能否匹配</li>
<li>2 - <code>dp[i-1][j] = true</code>，且 <code>s[i-1] = p[j-2]</code> ，让<code>p[j-2]</code>出现两次后能否匹配</li>
<li>3 - <code>dp[i-1][j] = true</code>，且<code>p[j-2] = &#39;.&#39;</code>，出现一次 <code>&#39;.&#39;</code>后能否匹配</li>
</ul>
</li>
<li>当<code>p[j-1] != &#39;*&#39;</code>：<code>dp[i][j]</code> 在以下任一情况为<code>true</code> 时为<code>true</code><ul>
<li>1 - <code>dp[i-1][j-1] = true</code>，且<code>s[i-1] = p[j-1]</code></li>
<li>2 - <code>dp[i-1][j-1] = true</code>，且<code>p[j-1] = &#39;.&#39;</code></li>
</ul>
</li>
</ul>
<p><strong>初始化：</strong> 先初始化<code>dp</code>矩阵首行，以避免状态转移时索引越界</p>
<ul>
<li><code>dp[0][0] = true</code>：两个空字符串是匹配的</li>
<li><code>dp[0][j] = dp[0][j-2]</code>且 <code>p[j-1] = &#39;*&#39;</code>：首行 <code>s</code>为空字符串，因为<code>p</code>的偶数位为<code>&#39;*&#39;</code>时才能匹配，即让<code>p</code>的奇数位出现<code>0</code>次，可以保证<code>p</code>是空字符串（<code>c*</code>是一个整体，可以看成空，<code>c</code>出现<code>0</code>次，所以<code>a*b*c*d*</code>这种可以表示空字符串）。所以循环变力字符串<code>p</code>，步长为<code>2</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = p.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化首行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j+=<span class="number">2</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = (dp[<span class="number">0</span>][j<span class="number">-2</span>] &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j<span class="number">-2</span>]) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] &amp;&amp; s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>]) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] &amp;&amp; p[j<span class="number">-2</span>] == <span class="string">'.'</span>) dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>]) dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">'.'</span>) dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624111913162.png" alt="image-20210624111913162"></p>
<p><strong>简洁写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = p.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化首行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j+=<span class="number">2</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = (dp[<span class="number">0</span>][j<span class="number">-2</span>] &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] = (p[j<span class="number">-1</span>] == <span class="string">'*'</span>) ?</span><br><span class="line">                    dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>):</span><br><span class="line">                    dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (p[j<span class="number">-1</span>] == <span class="string">'.'</span> || s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624111901590.png" alt="image-20210624111901590"></p>
<h4 id="方法二-递归-效率较低"><a href="#方法二-递归-效率较低" class="headerlink" title="方法二 递归 效率较低"></a>方法二 递归 效率较低</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>* str = s.data();</span><br><span class="line">        <span class="keyword">char</span>* pattern = p.data();</span><br><span class="line">         <span class="keyword">if</span> (*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> isMatch(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> isMatch(str, pattern+<span class="number">2</span>) || isMatch(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isMatch(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624113059212.png" alt="image-20210624113059212"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 20 - 表示数值的字符串</title>
    <url>/2021/06/24/SwordToOffer%20-%2020%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-20-表示数值的字符串"><a href="#《剑指Offer》-20-表示数值的字符串" class="headerlink" title="《剑指Offer》 20 - 表示数值的字符串"></a>《剑指Offer》 20 - 表示数值的字符串</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p>
<ul>
<li>数值（按顺序）可以分成以下几个部分：<ul>
<li>若干空格</li>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
<li>若干空格 </li>
</ul>
</li>
<li>小数（按顺序）可以分成以下几个部分：<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
</li>
<li>整数（按顺序）可以分成以下几个部分：<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
</li>
</ul>
<p>部分数值列举如下：<br><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></p>
<p>部分非数值列举如下：<br><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;e&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;.&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：s &#x3D; &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 20</span><br><span class="line">s 仅含英文字母（大写和小写），数字（0-9），加号 &#39;+&#39; ，减号 &#39;-&#39; ，空格 &#39; &#39; 或者点 &#39;.&#39; 。</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：分情况讨论"><a href="#方法一：分情况讨论" class="headerlink" title="方法一：分情况讨论"></a>方法一：分情况讨论</h4><ul>
<li>用到了几个库函数，巩固一下对STL的使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 除去s前后的空格</span></span><br><span class="line">        s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">' '</span>));  </span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">' '</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找有e或E的位置把s分割成前后两个部分</span></span><br><span class="line">        <span class="keyword">int</span> epos = <span class="built_in">string</span>::npos;</span><br><span class="line">        epos = s.find(<span class="string">'e'</span>) != <span class="built_in">string</span>::npos ? s.find(<span class="string">'e'</span>) : epos;</span><br><span class="line">        epos = s.find(<span class="string">'E'</span>) != <span class="built_in">string</span>::npos ? s.find(<span class="string">'E'</span>) : epos;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有e的部分前面可以不是整数，但后面必须是整数</span></span><br><span class="line">        <span class="keyword">if</span> (epos != <span class="built_in">string</span>::npos)</span><br><span class="line">            <span class="keyword">return</span> checkNum(s.substr(<span class="number">0</span>, epos), <span class="literal">false</span>) &amp;&amp; checkNum(s.substr(epos + <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 没有e的则可以不是整数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> checkNum(s, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符串是不是合法的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">bool</span> mustInt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hasDot = <span class="literal">false</span>, hasNum = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 根据是否有正负号确定起始的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = (s[<span class="number">0</span>] == <span class="string">'+'</span> || s[<span class="number">0</span>] == <span class="string">'-'</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i; i &lt; s.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果必须是整数或已经有.了则直接返回false</span></span><br><span class="line">                <span class="keyword">if</span> (mustInt || hasDot)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                hasDot = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                hasNum = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 出现其他字符也返回false</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断字符串中是否有数组</span></span><br><span class="line">        <span class="keyword">return</span> hasNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624164051217.png" alt="image-20210624164051217"></p>
<ul>
<li>剑指Offer书中写法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 整数的格式可以用[+|-]B表示, 其中B为无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">int</span>&amp; index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">'+'</span> || s[index] == <span class="string">'-'</span>)</span><br><span class="line">            ++index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(s, index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">int</span>&amp; index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> befor = index;</span><br><span class="line">        <span class="keyword">while</span>(index != s.size() &amp;&amp; s[index] &gt;= <span class="string">'0'</span> &amp;&amp; s[index] &lt;= <span class="string">'9'</span>)</span><br><span class="line">            index ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index &gt; befor;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，</span></span><br><span class="line">    <span class="comment">// 其中A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串开始有空格，可以返回true</span></span><br><span class="line">        <span class="keyword">while</span>(s[index] == <span class="string">' '</span>)  <span class="comment">//书中代码没有该项测试</span></span><br><span class="line">            ++index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> numeric = scanInteger(s, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'.'，接下来是数字的小数部分</span></span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">'.'</span>)&#123;</span><br><span class="line"></span><br><span class="line">            ++index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用||的原因：</span></span><br><span class="line">            <span class="comment">// 1. 小数可以没有整数部分，例如.123等于0.123；</span></span><br><span class="line">            <span class="comment">// 2. 小数点后面可以没有数字，例如233.等于233.0；</span></span><br><span class="line">            <span class="comment">// 3. 当然小数点前面和后面可以有数字，例如233.666</span></span><br><span class="line">            numeric = scanUnsignedInteger(s, index) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'e'或者'E'，接下来跟着的是数字的指数部分</span></span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">'e'</span> || s[index] == <span class="string">'E'</span>)&#123;</span><br><span class="line"></span><br><span class="line">            ++index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用&amp;&amp;的原因：</span></span><br><span class="line">            <span class="comment">// 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</span></span><br><span class="line">            <span class="comment">// 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</span></span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(s ,index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串结尾有空格，可以返回true</span></span><br><span class="line">        <span class="keyword">while</span>(s[index] == <span class="string">' '</span>)</span><br><span class="line">            ++index;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; index;   <span class="comment">//调试用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; index == s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624164411823.png" alt="image-20210624164411823"></p>
<h4 id="方法二-：有限状态自动机"><a href="#方法二-：有限状态自动机" class="headerlink" title="方法二 ：有限状态自动机"></a>方法二 ：有限状态自动机</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有限状态自动机DFA，时间复杂度 O(N)</span></span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;unmap&gt; states = &#123;</span><br><span class="line">            unmap&#123;charint(<span class="string">' '</span>,<span class="number">0</span>),charint(<span class="string">'s'</span>,<span class="number">1</span>),charint(<span class="string">'d'</span>,<span class="number">2</span>),charint(<span class="string">'.'</span>,<span class="number">4</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">2</span>),charint(<span class="string">'.'</span>,<span class="number">4</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">2</span>),charint(<span class="string">'.'</span>,<span class="number">3</span>),charint(<span class="string">'e'</span>,<span class="number">5</span>),charint(<span class="string">' '</span>,<span class="number">8</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">3</span>),charint(<span class="string">'e'</span>,<span class="number">5</span>),charint(<span class="string">' '</span>,<span class="number">8</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">3</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'s'</span>,<span class="number">6</span>),charint(<span class="string">'d'</span>,<span class="number">7</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">7</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">'d'</span>,<span class="number">7</span>),charint(<span class="string">' '</span>,<span class="number">8</span>)&#125;,</span><br><span class="line">            unmap&#123;charint(<span class="string">' '</span>,<span class="number">8</span>)&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">                t = <span class="string">'d'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'+'</span> || c == <span class="string">'-'</span>)</span><br><span class="line">                t = <span class="string">'s'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'e'</span> || c == <span class="string">'E'</span>)</span><br><span class="line">                t = <span class="string">'e'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'.'</span> || c == <span class="string">' '</span>)</span><br><span class="line">                t = c;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t = <span class="string">'?'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].count(t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = (<span class="keyword">int</span>) states[p][t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624164221368.png" alt="image-20210624164221368"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 21 - 调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/06/24/SwordToOffer%20-%2021%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-21-调整数组顺序使奇数位于偶数前面"><a href="#《剑指Offer》-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="《剑指Offer》 21 - 调整数组顺序使奇数位于偶数前面"></a>《剑指Offer》 21 - 调整数组顺序使奇数位于偶数前面</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 50000</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：首尾指针遍历"><a href="#方法一：首尾指针遍历" class="headerlink" title="方法一：首尾指针遍历"></a>方法一：首尾指针遍历</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size()<span class="number">-1</span>; i &lt; j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &amp; <span class="number">1</span>) i++;     </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!(nums[j] &amp; <span class="number">1</span>)) j--;</span><br><span class="line">            <span class="keyword">else</span> swap(nums[i],nums[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624204426702.png" alt="image-20210624204426702"></p>
<h4 id="方法二：快慢双指针"><a href="#方法二：快慢双指针" class="headerlink" title="方法二：快慢双指针"></a>方法二：快慢双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] &amp; <span class="number">1</span>) </span><br><span class="line">                swap(nums[low++], nums[fast]);             </span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624204706785.png" alt="image-20210624204706785"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 22 - 链表中倒数第k个节点</title>
    <url>/2021/06/24/SwordToOffer%20-%2022%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-22-链表中倒数第k个节点"><a href="#《剑指Offer》-22-链表中倒数第k个节点" class="headerlink" title="《剑指Offer》 22 - 链表中倒数第k个节点"></a>《剑指Offer》 22 - 链表中倒数第k个节点</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第k个节点</a></p>
<p>输入一个链表，输出该链表中倒数第<code>k</code>个节点。为了符合大多数人的习惯，本题从<code>1</code>开始计数，即链表的尾节点是倒数第<code>1</code>个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code>个节点是值为<code>4</code> 的节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：快慢双指针！掌握！"><a href="#方法一：快慢双指针！掌握！" class="headerlink" title="方法一：快慢双指针！掌握！"></a>方法一：快慢双指针！掌握！</h4><ul>
<li>先让<code>fast</code>走<code>k</code>个节点，然后<code>slow</code>在从头走，这样的话当<code>fast</code>走到末尾时，<code>slow</code>正好在倒数第<code>k</code>个节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(k--) fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624214139125.png" alt="image-20210624214139125"></p>
<ul>
<li>设置 <code>t</code>变量，可使用一次循环完成遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= k) slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624214438899.png" alt="image-20210624214438899"></p>
<p><strong>虽然上述两种写法在LeetCode能够通过，但是仍有不足，需要注意三个易错点！！</strong></p>
<ul>
<li>对输入的空指针特判</li>
<li>此题的<code>k</code>是<code>int</code>类型，如果是无符号整数，输入<code>k=0</code>，<code>k-1</code>将会越界<code>（0xFFFFFFFF）</code>，特判</li>
<li>输入的链表结点数小于<code>k</code>，特判</li>
</ul>
<p>改进写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (k--) </span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        	<span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="方法二：单指针走两遍，不推荐"><a href="#方法二：单指针走两遍，不推荐" class="headerlink" title="方法二：单指针走两遍，不推荐"></a>方法二：单指针走两遍，不推荐</h4><ul>
<li>自己AC的写法，虽然通过了，但是不优雅，感觉憨憨的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;   </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = cnt - k + <span class="number">1</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == temp)</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210624213216265.png" alt="image-20210624213216265"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 24 - 反转链表</title>
    <url>/2021/06/25/SwordToOffer%20-%2024%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-24-反转链表"><a href="#《剑指Offer》-24-反转链表" class="headerlink" title="《剑指Offer》 24 - 反转链表"></a>《剑指Offer》 24 - 反转链表</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode206相同：</strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：前后双指针遍历"><a href="#方法一：前后双指针遍历" class="headerlink" title="方法一：前后双指针遍历"></a>方法一：前后双指针遍历</h4><ul>
<li>定义前后两个指针</li>
<li>为了避免链表在 <code>fast</code> 后断开，需要在反转前用 <code>t</code> 将 其先保存下来，通过中间指针<code>t</code> 实现局部反转后，<code>fast</code> <code>slow</code>同时向前移动一个位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = <span class="literal">nullptr</span>, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = fast-&gt;next;</span><br><span class="line">            fast-&gt;next = slow;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625113236752.png" alt="image-20210625113236752"></p>
<h4 id="方法二-：递归"><a href="#方法二-：递归" class="headerlink" title="方法二 ：递归"></a>方法二 ：递归</h4><p>令<code>F(node)</code>为问题: 反转以<code>node</code>为头节点的单向链表；</p>
<p>一般，需要考虑<code>F(n)</code>和<code>F(n-1)</code>的关系，那么这里，如果<code>n</code>代表以<code>node</code>为头节点的单向链表，那么<code>n-1</code>就代表以<code>node-&gt;next</code> 为头节点的单向链表。所以，令<code>F(node-&gt;next)</code>为问题：反转以<code>node-&gt;next</code>为头节点的单向链表；<br>那么，<code>F(node)</code> 和 <code>F(node-&gt;next)</code>之间的关系是？假设反转3个节点的链表：<br><code>1 -&gt; 2 -&gt; 3</code><br>那么，<code>F(node = 1) = F(node = 2) + ?</code><br>这里假设子问题<code>F(node = 2)</code>已经解决，那么如何解决 <code>F(node = 1)</code>：<br>很明显，需要反转<code>node = 2</code> 和 <code>node = 1</code>， 即 <code>node-&gt;next-&gt;next = node</code>; 同时 <code>node-&gt;next = nullptr</code>;<br>所以，这个问题就可以是：<code>F(node = 1) = F(node = 2) + 反转 node = 2 和 node = 1</code></p>
<ul>
<li>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作<code>p</code> .</li>
<li>此后，每次函数在返回的过程中，让当前结点的下一个结点的 <code>next</code> 指针指向当前节点。</li>
<li>同时让当前结点的 <code>next</code>指针指向 <code>nullptr</code> ，从而实现从链表尾部开始的局部反转</li>
<li>当递归函数全部出栈后，链表反转完成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* p = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625115547327.png" alt="image-20210625115547327"></p>
<h4 id="方法三-如图所示"><a href="#方法三-如图所示" class="headerlink" title="方法三  如图所示"></a>方法三  如图所示</h4><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625150438633.png" alt="image-20210625150438633"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625150453593.png" alt="image-20210625150453593"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625150511305.png" alt="image-20210625150511305"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625150529306.png" alt="image-20210625150529306"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = p;</span><br><span class="line">            p = head-&gt;next;</span><br><span class="line">            head-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625150405258.png" alt="image-20210625150405258"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 25 - 合并两个排序的链表</title>
    <url>/2021/06/25/SwordToOffer%20-%2025%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-25-合并两个排序的链表"><a href="#《剑指Offer》-25-合并两个排序的链表" class="headerlink" title="《剑指Offer》 25 - 合并两个排序的链表"></a>《剑指Offer》 25 - 合并两个排序的链表</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 25. 合并两个排序的链表</a></p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode21相同：</strong><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：非递归-利用伪头结点"><a href="#方法一：非递归-利用伪头结点" class="headerlink" title="方法一：非递归 利用伪头结点"></a>方法一：非递归 利用伪头结点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span> (l1) p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625154911507.png" alt="image-20210625154911507"></p>
<h4 id="方法二：-递归"><a href="#方法二：-递归" class="headerlink" title="方法二： 递归"></a>方法二： 递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625160829523.png" alt="image-20210625160829523"></p>
<p><strong>简洁写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 || !l2) <span class="keyword">return</span> !l1 ? l2 : l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 23 - 链表中环的入口点</title>
    <url>/2021/06/25/SwordToOffer%20-%2023%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-23-链表中环的入口点"><a href="#《剑指Offer》-23-链表中环的入口点" class="headerlink" title="《剑指Offer》 23 - 链表中环的入口点"></a>《剑指Offer》 23 - 链表中环的入口点</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数<code>pos</code> 来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。 如果 <code>pos</code>是<code>-1</code>，则在该链表中没有环。注意，<code>pos</code>仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明：不允许修改给定的链表。</span><br><span class="line">进阶：是否可以使用 O(1) 空间解决此题？</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625095025742.png" alt="image-20210625095025742"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625095102180.png" alt="image-20210625095102180"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625095111012.png" alt="image-20210625095111012"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例3：</span><br><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 $[0,10^4]$ 内</li>
<li>$-10^5 &lt;= \mathtt{Node.val} &lt;= 10^5$</li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>根据：</p>
<ul>
<li>（1）$f=2s$ （快指针每次2步，路程刚好2倍）</li>
<li>（2）$f = s + nb$ (相遇时，刚好多走了n圈）</li>
</ul>
<p>推出：$s = nb$</p>
<p>从<code>head</code>结点走到入环点需要走 ： $a + nb$， 而<code>slow</code>已经走了$nb$，那么<code>slow</code>再走$a$步就是入环点了。如何知道<code>slow</code>刚好走了$a$步？令<code>fast</code> 从<code>head</code>开始，和<code>slow</code>指针一起走，相遇时刚好就是$a$步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210625102826554.png" alt="image-20210625102826554"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  29 - 顺时针打印矩阵</title>
    <url>/2021/06/28/SwordToOffer%20-%2029%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-29-顺时针打印矩阵"><a href="#《剑指Offer》-29-顺时针打印矩阵" class="headerlink" title="《剑指Offer》  29 - 顺时针打印矩阵"></a>《剑指Offer》  29 - 顺时针打印矩阵</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵</a></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; matrix.length &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode54相同：</strong><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>在判空的时候，注意顺序，如果写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>会报指针错误，因为当res为空时，不存在<code>matrix[0].size()</code>，所以要这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">int</span> col = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>或者写成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();</span><br></pre></td></tr></table></figure>

<p>设置四个边界，如图所示：</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628153341074.png" alt="image-20210628153341074"></p>
<h4 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 左上 --&gt; 右上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) res.push_back(matrix[top][i]);</span><br><span class="line">            <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右上 --&gt; 右下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; ++i) res.push_back(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右下 --&gt; 左下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; --i) res.push_back(matrix[bottom][i]);</span><br><span class="line">            <span class="keyword">if</span> (--bottom &lt; top) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左下 --&gt; 左上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt;= top; --i) res.push_back(matrix[i][left]);</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628153723096.png" alt="image-20210628153723096"></p>
<h4 id="写法二："><a href="#写法二：" class="headerlink" title="写法二："></a>写法二：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = col, top = <span class="number">0</span>, bottom = row;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; ++i)</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 判断是否重复打印，只有一行的时候，就不需要打印了，所以需要top&lt;=bottom</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; --i)</span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 判断是否重复打印，当只有一列的时候，就不需要打印了，所以需要left&lt;=right</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt;= top; --i)</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628142431419.png" alt="image-20210628142431419"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  27 - 树的镜像</title>
    <url>/2021/06/28/SwordToOffer%20-%2027%20%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-27-树的镜像"><a href="#《剑指Offer》-27-树的镜像" class="headerlink" title="《剑指Offer》  27 - 树的镜像"></a>《剑指Offer》  27 - 树的镜像</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></p>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<pre><code>例如输入：
      4
    /   \
  2      7
 / \    / \
1   3  6   9

镜像输出：
      4
    /   \
  7      2
 / \    / \
9   6  3   1

示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

限制：
0 &lt;= 节点个数 &lt;= 1000</code></pre><p><strong>本题与LeetCode226相同：</strong><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ul>
<li>递归交换，有多种写法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628100929962.png" alt="image-20210628100929962"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* left = mirrorTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628101342412.png" alt="image-20210628101342412"></p>
<h4 id="方法二-：辅助栈"><a href="#方法二-：辅助栈" class="headerlink" title="方法二 ：辅助栈"></a>方法二 ：辅助栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) s.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) s.push(cur-&gt;right);</span><br><span class="line">            swap(cur-&gt;left, cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628103051940.png" alt="image-20210628103051940"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 26 - 树的子结构</title>
    <url>/2021/06/28/SwordToOffer%20-%2026%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-26-树的子结构"><a href="#《剑指Offer》-26-树的子结构" class="headerlink" title="《剑指Offer》 26 - 树的子结构"></a>《剑指Offer》 26 - 树的子结构</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></p>
<p>输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)。<code>B</code>是<code>A</code>的子结构， 即 <code>A</code>中有出现和<code>B</code>相同的结构和节点值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ul>
<li>先在树A中找和树B的根节点值相同的节点，再判断树B是不是树A的子树</li>
<li><code>dosAhasB</code> 函数中注意判断的顺序<ul>
<li>当节点 <code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回 <code>true</code> ；</li>
<li>当节点 <code>A</code> 为空：说明已经越过树 <code>A</code>叶子节点，即匹配失败，返回 <code>false</code> ；</li>
<li>当节点 <code>A</code> 和 <code>B</code> 的值不同：说明匹配失败，返回<code>false</code> ；</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A &amp;&amp; B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A-&gt;val == B-&gt;val)</span><br><span class="line">                res = doesAhasB(A, B);</span><br><span class="line">            <span class="keyword">if</span>(!res)</span><br><span class="line">                res = isSubStructure(A-&gt;left, B);</span><br><span class="line">            <span class="keyword">if</span>(!res)</span><br><span class="line">                res = isSubStructure(A-&gt;right,B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">doesAhasB</span><span class="params">(TreeNode*A, TreeNode*B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">        <span class="keyword">if</span> (!A) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> doesAhasB(A-&gt;left, B-&gt;left) &amp;&amp; doesAhasB(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628091648312.png" alt="image-20210628091648312"></p>
<h4 id="方法二-递归-迭代"><a href="#方法二-递归-迭代" class="headerlink" title="方法二 递归+迭代"></a>方法二 递归+迭代</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(A);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            TreeNode* cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val == B-&gt;val &amp;&amp; dfs(cur,B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                s.push(cur-&gt;left);</span><br><span class="line">                s.push(cur-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!A) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A-&gt;val == B-&gt;val &amp;&amp; dfs(A-&gt;left,B-&gt;left) &amp;&amp; dfs(A-&gt;right,B-&gt;right);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628094109478.png" alt="image-20210628094109478"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》 28 - 对称的二叉树</title>
    <url>/2021/06/28/SwordToOffer%20-%2028%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-28-对称的二叉树"><a href="#《剑指Offer》-28-对称的二叉树" class="headerlink" title="《剑指Offer》 28 - 对称的二叉树"></a>《剑指Offer》 28 - 对称的二叉树</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<pre><code>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3

示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true

示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false

限制：
0 &lt;= 节点个数 &lt;= 1000</code></pre><p><strong>本题与LeetCode28相同：</strong><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：递归遍历，比较前序遍历和对称前序遍历"><a href="#方法一：递归遍历，比较前序遍历和对称前序遍历" class="headerlink" title="方法一：递归遍历，比较前序遍历和对称前序遍历"></a>方法一：递归遍历，比较前序遍历和对称前序遍历</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* L, TreeNode* R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!L &amp;&amp; !R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!L || !R || L-&gt;val != R-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(L-&gt;left, R-&gt;right) &amp;&amp; isSymmetric(L-&gt;right, R-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628105631979.png" alt="image-20210628105631979"></p>
<h4 id="方法二：使用辅助栈-BFS"><a href="#方法二：使用辅助栈-BFS" class="headerlink" title="方法二：使用辅助栈 BFS"></a>方法二：使用辅助栈 BFS</h4><ul>
<li>入栈两对（左子树的左孩子和右子树的右孩子是一对，左子树的右孩子和右子树的左孩子是一对），出栈的时候出栈一对，判别是否符合条件，全部遍历完，队列为空，则全部符合，返回<code>true</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root-&gt;left);</span><br><span class="line">        s.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curR = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            TreeNode* curL = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((!curL &amp;&amp; curR) || curL &amp;&amp; !curR)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (curL &amp;&amp; curR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curL-&gt;val != curR-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 左子树的左孩子，右子树的右孩子</span></span><br><span class="line">                s.push(curL-&gt;left);</span><br><span class="line">                s.push(curR-&gt;right);</span><br><span class="line">                <span class="comment">// 左子树的右孩子，右子树的左孩子</span></span><br><span class="line">                s.push(curL-&gt;right);</span><br><span class="line">                s.push(curR-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628132837470.png" alt="image-20210628132837470"></p>
<h4 id="方法三-使用辅助队列-BFS"><a href="#方法三-使用辅助队列-BFS" class="headerlink" title="方法三 使用辅助队列 BFS"></a>方法三 使用辅助队列 BFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curL = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* curR = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((!curL &amp;&amp; curR) || (curL &amp;&amp; !curR)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (curL &amp;&amp; curR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (curL-&gt;val != curR-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(curL-&gt;left);</span><br><span class="line">                q.push(curR-&gt;right);</span><br><span class="line"></span><br><span class="line">                q.push(curL-&gt;right);</span><br><span class="line">                q.push(curR-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628133703740.png" alt="image-20210628133703740"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  30 - 包含min函数的栈</title>
    <url>/2021/06/28/SwordToOffer%20-%2030%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-30-包含min函数的栈"><a href="#《剑指Offer》-30-包含min函数的栈" class="headerlink" title="《剑指Offer》  30 - 包含min函数的栈"></a>《剑指Offer》  30 - 包含min函数的栈</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">剑指 Offer 30. 包含min函数的栈</a></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">各函数的调用总次数不超过 20000 次</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode155相同：</strong><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：异步-双栈"><a href="#方法一：异步-双栈" class="headerlink" title="方法一：异步 双栈"></a>方法一：异步 双栈</h4><ul>
<li>注意<code>INT_MAX</code>的使用，表示整数最大值。</li>
<li>注意<code>push</code>操作中的比较是 <code>&lt;=</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty()) s1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!s2.empty()) s2.pop();</span><br><span class="line">        s2.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (s2.empty() || x &lt;= s2.top())</span><br><span class="line">            s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.top() == s2.top())</span><br><span class="line">            s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628162136494.png" alt="image-20210628162136494"></p>
<h4 id="方法二：同步-双栈"><a href="#方法二：同步-双栈" class="headerlink" title="方法二：同步 双栈"></a>方法二：同步 双栈</h4><ul>
<li>两个栈的元素个数保持一致，所以<code>pop()</code>时可以同时<code>pop()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        s2.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        s2.push(<span class="built_in">std</span>::min(s2.top(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628161247579.png" alt="image-20210628161247579"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  31 - 栈的压入、弹出序列</title>
    <url>/2021/06/29/SwordToOffer%20-%2031%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-31-栈的压入、弹出序列"><a href="#《剑指Offer》-31-栈的压入、弹出序列" class="headerlink" title="《剑指Offer》  31 - 栈的压入、弹出序列"></a>《剑指Offer》  31 - 栈的压入、弹出序列</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode946相同：</strong><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>建立一个辅助栈，把输入的第一个序列中的数字依次压入辅助栈，并按第二个序列的顺序依次从该栈弹出，如果最后栈为空，则序列一致。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == popped[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628170348181.png" alt="image-20210628170348181"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  33 - 二叉搜索数的后序遍历序列</title>
    <url>/2021/06/29/SwordToOffer%20-%2033%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-33-二叉搜索数的后序遍历序列"><a href="#《剑指Offer》-33-二叉搜索数的后序遍历序列" class="headerlink" title="《剑指Offer》  33 - 二叉搜索数的后序遍历序列"></a>《剑指Offer》  33 - 二叉搜索数的后序遍历序列</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">数组长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：递归分治"><a href="#方法一：递归分治" class="headerlink" title="方法一：递归分治"></a>方法一：递归分治</h4><ul>
<li>首先理清后序遍历的定义，后续遍历中最后一个数字是根节点的值。前面的数字可以分成两部分，第一部分是左子树节点的值，它们都小于根节点；第二部分是右子树节点的值，它们都比根节点大。</li>
<li><strong>终止条件</strong>：当 <code>i &gt;= j</code>，说明此子树节点数量 <code>&lt;= 1</code>，则无需判断直接返回 <code>true</code></li>
<li><strong>递推</strong>：<ul>
<li>按照后序遍历的性质划分左右子树</li>
<li>判断左右子树是否均为二叉搜索数</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>此树正确 &amp;&amp;</li>
<li>左子树正确 &amp;&amp;</li>
<li>右子树正确</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _verifyPostorder(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _verifyPostorder(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &lt; postorder[j]) ++p;</span><br><span class="line">        <span class="keyword">int</span> cut_point = p;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &gt; postorder[j]) ++p;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; _verifyPostorder(postorder, i, cut_point - <span class="number">1</span>) &amp;&amp; _verifyPostorder(postorder, cut_point, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Cszz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210629094743098.png" alt="image-20210629094743098"></p>
<h4 id="方法二-：-辅助单调栈"><a href="#方法二-：-辅助单调栈" class="headerlink" title="方法二 ： 辅助单调栈"></a>方法二 ： 辅助单调栈</h4><ul>
<li><strong>后序遍历的倒序：</strong> 根|右|左。类似于先序遍历的镜像（根|左|右）。</li>
<li>设后续遍历的倒序为 $r_n,r_{n-1},…r_1$ ，设索引为i，若为<strong>二叉搜索树</strong>，则有：<ul>
<li>若 $r_{i+1} &lt; r_i$：$r_i$ 是 $r_{i+1}$ 的右子节点</li>
<li>若 $r_{i+1} &gt; r_i$：$r_i$ 一定是某节点 <code>root</code> 的左子节点，且 <code>root</code> 为节点 $r_{i+1}, r_{i+2},… r_1$ 中值大于且最接近 $r_i$ 的节点且最接近 $r_i$ 的节点，因为 <code>root</code> 是直接连接左子节点 $r_i$ 的。</li>
</ul>
</li>
<li>当遍历时遇到递减节点  $r_{i+1} &gt; r_i$ 时，如果是二叉搜索树，最对于后序遍历中节点 $r_i$ 右边的所有节点，都必须小于 <code>root</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \   </span><br><span class="line"> 1   3   </span><br><span class="line"> </span><br><span class="line"> 后序：13265</span><br><span class="line"> 栈的操作过程：</span><br><span class="line">i &#x3D; 4 : s[INT_MAX] -&gt; root &#x3D; INT_MAX -&gt; s[5]</span><br><span class="line">i &#x3D; 3 : s[5] -&gt; s[5,6]</span><br><span class="line">i &#x3D; 2 : s[5,6] -&gt; root&#x3D;6,s[5];root&#x3D;5,s[] -&gt; s[2]</span><br><span class="line">i &#x3D; 1 : s[2] -&gt; s[2,3]</span><br><span class="line">i &#x3D; 0 : s[2,3] -&gt; root &#x3D; 3,s[2];root&#x3D;2,s[] -&gt; s[1]</span><br><span class="line">return true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后序：[1,6,3,2,5]</span><br><span class="line">栈的操作过程：false</span><br><span class="line">i &#x3D; 4: s[INT_MAX] -&gt; root &#x3D; INT_MAX -&gt; s[5]</span><br><span class="line">i &#x3D; 3: s[5] -&gt;  root &#x3D; 5,s[] -&gt; s[2]</span><br><span class="line">i &#x3D; 2: s[2] -&gt; s[2,3]</span><br><span class="line">i &#x3D; 1: s[2,3] -&gt; 6 &gt; 5 return false</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &gt; postorder[i]) <span class="comment">// 遇到递减元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  35 - 复杂链表的复制</title>
    <url>/2021/06/29/SwordToOffer%20-%2035%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-35-复杂链表的复制"><a href="#《剑指Offer》-35-复杂链表的复制" class="headerlink" title="《剑指Offer》  35 - 复杂链表的复制"></a>《剑指Offer》  35 - 复杂链表的复制</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></p>
<p>请实现<code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629153211479.png" alt="image-20210629153211479"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629153433704.png" alt="image-20210629153433704"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629153442371.png" alt="image-20210629153442371"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 3：</span><br><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 4：</span><br><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line">-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node-&gt;random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode138相同：</strong><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：-哈希表，但空间复杂度为-O-n"><a href="#方法一：-哈希表，但空间复杂度为-O-n" class="headerlink" title="方法一： 哈希表，但空间复杂度为 $O(n)$"></a>方法一： 哈希表，但空间复杂度为 $O(n)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* p = head;  </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[p] = <span class="keyword">new</span> Node(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[p]-&gt;next = <span class="built_in">map</span>[p-&gt;next];</span><br><span class="line">            <span class="built_in">map</span>[p]-&gt;random = <span class="built_in">map</span>[p-&gt;random];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629154148112.png" alt="image-20210629154148112"></p>
<h4 id="方法二：拼接-重连-拆分-空间复杂度为-O-1"><a href="#方法二：拼接-重连-拆分-空间复杂度为-O-1" class="headerlink" title="方法二：拼接 + 重连 + 拆分 空间复杂度为 $O(1)$"></a>方法二：拼接 + 重连 + 拆分 空间复杂度为 $O(1)$</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* p = head;</span><br><span class="line">               </span><br><span class="line">        <span class="comment">// 1. 拼接 A-&gt;A'-&gt;B-B' ...</span></span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = <span class="keyword">new</span> Node(p-&gt;val);</span><br><span class="line">            <span class="comment">// node-&gt;random = nullptr;</span></span><br><span class="line">            node-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            p = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 重连接 如果 A-&gt;random为S，则S'为A-&gt;random-&gt;next;</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="built_in">random</span>)</span><br><span class="line">                p-&gt;next-&gt;<span class="built_in">random</span> = p-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 拆分为两个链表</span></span><br><span class="line">        p = head-&gt;next; <span class="comment">// 新链表起点</span></span><br><span class="line">        Node *pre = head, *newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629164053283.png" alt="image-20210629164053283"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  32 - 从上到下打印二叉树</title>
    <url>/2021/06/29/SwordToOffer%20-%2032%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-32-从上到下打印二叉树"><a href="#《剑指Offer》-32-从上到下打印二叉树" class="headerlink" title="《剑指Offer》  32 - 从上到下打印二叉树"></a>《剑指Offer》  32 - 从上到下打印二叉树</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></p>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<pre><code>例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回：
[3,9,20,15,7]

提示：
节点总数 &lt;= 1000 </code></pre><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="层序遍历即可-也可用于-图的遍历（BFS）"><a href="#层序遍历即可-也可用于-图的遍历（BFS）" class="headerlink" title="层序遍历即可 也可用于 图的遍历（BFS）"></a>层序遍历即可 也可用于 图的遍历（BFS）</h4><ul>
<li>可以使用queue或者deque来做，两者的区别是：<ul>
<li>queue可以访问两端但是只能修改队头</li>
<li>deque可以访问两端并且可以在队首和队尾删除和插入元素</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628173336152.png" alt="image-20210628173336152"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></p>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<pre><code>例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]</code></pre><p><strong>本题与LeetCode102题相同：</strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>巧用 <code>for</code> 循环， 循环次数为当前层节点数（即队列 <code>queue</code> 长度）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                temp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628201922777.png" alt="image-20210628201922777"></p>
<p><strong>剑指Offer中的写法：</strong></p>
<ul>
<li>利用三个临时变量<ul>
<li><code>toBePrinted</code>表示当前层中还没有打印的结点数</li>
<li><code>nextLayer</code>变量表示下一层节点的数目</li>
<li><code>curLayer</code>变量表示当前所在层</li>
</ul>
</li>
<li>本题要求分层打印，入队和出队的先后顺序将影响当前所在行的判断，因此必须严格遵循先出队再入队的顺序，否则会得到错误的结果。由于出队会造成信息的丢失，因此需要设置一个中间变量<code>temp</code>保存出队的结点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> toBePrinted = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextLayer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLayer = <span class="number">0</span>;</span><br><span class="line">        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(toBePrinted == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                toBePrinted = nextLayer;</span><br><span class="line">                nextLayer = <span class="number">0</span>;</span><br><span class="line">                curLayer++;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            res[curLayer].push_back(q.front()-&gt;val);</span><br><span class="line">            TreeNode *temp = q.front();</span><br><span class="line">            toBePrinted--;</span><br><span class="line">            q.pop_front();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push_back(temp-&gt;left);</span><br><span class="line">                nextLayer++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push_back(temp-&gt;right);</span><br><span class="line">                nextLayer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628204845960.png" alt="image-20210628204845960"></p>
<p><strong>递归写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelOrder(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= res.size()) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        levelOrder(root-&gt;left, level + <span class="number">1</span>, res);</span><br><span class="line">        levelOrder(root-&gt;right, level + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628205401347.png" alt="image-20210628205401347"></p>
<p><strong>题目3：</strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<pre><code>例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：
[
  [3],
  [20,9],
  [15,7]
]

提示：
节点总数 &lt;= 1000</code></pre><h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：-双端队列，两层一组"><a href="#方法一：-双端队列，两层一组" class="headerlink" title="方法一： 双端队列，两层一组"></a>方法一： 双端队列，两层一组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                temp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push_back(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push_back(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (q.empty()) <span class="keyword">break</span>; <span class="comment">// 若为空，则最后一层是奇数层，直接跳出</span></span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.back();</span><br><span class="line">                q.pop_back();</span><br><span class="line">                temp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push_front(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push_front(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210628213618908.png" alt="image-20210628213618908"></p>
<h4 id="方法二：按奇偶行从-队后-or-队前插入-temp"><a href="#方法二：按奇偶行从-队后-or-队前插入-temp" class="headerlink" title="方法二：按奇偶行从 队后 or 队前插入 temp"></a>方法二：按奇偶行从 队后 or 队前插入 temp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="keyword">public</span>:    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);        <span class="keyword">while</span>(!q.empty())        &#123;            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; temp;            <span class="comment">// 打印奇数层            for (int i = q.size(); i &gt; 0; --i)            &#123;                TreeNode* node = q.front();                q.pop();                if (res.size() % 2 == 0) temp.push_back(node-&gt;val);                else temp.push_front(node-&gt;val);                if (node-&gt;left) q.push(node-&gt;left);                if (node-&gt;right) q.push(node-&gt;right);            &#125;            res.push_back((vector&lt;int&gt;)&#123;temp.begin(),temp.end()&#125;);        &#125;        return res;    &#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629091332699.png" alt="image-20210629091332699"></p>
<h4 id="方法三：根据res的大小判断奇偶行，然后决定是否使用-reverse-函数"><a href="#方法三：根据res的大小判断奇偶行，然后决定是否使用-reverse-函数" class="headerlink" title="方法三：根据res的大小判断奇偶行，然后决定是否使用 reverse 函数"></a>方法三：根据res的大小判断奇偶行，然后决定是否使用 reverse 函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="keyword">public</span>:    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);        <span class="keyword">while</span>(!q.empty())        &#123;            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)            &#123;                TreeNode* node = q.front();                q.pop();                temp.push_back(node-&gt;val);                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);            &#125;            <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">1</span>)                reverse(temp.begin(),temp.end());            res.push_back(temp);        &#125;        <span class="keyword">return</span> res;    &#125;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629091202472.png" alt="image-20210629091202472"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  34 - 二叉树中和为某一值的路径</title>
    <url>/2021/06/29/SwordToOffer%20-%2034%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-34-二叉树中和为某一值的路径"><a href="#《剑指Offer》-34-二叉树中和为某一值的路径" class="headerlink" title="《剑指Offer》  34 - 二叉树中和为某一值的路径"></a>《剑指Offer》  34 - 二叉树中和为某一值的路径</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></p>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定如下二叉树，以及目标和 target &#x3D; 22，</span><br><span class="line"> 			  5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode113相同：</strong><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS 回溯"></a>DFS 回溯</h4><ul>
<li>递推参数： 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</li>
<li>终止条件： 若节点 <code>root</code> 为空，则直接返回。</li>
<li>递推工作：<ul>
<li>路径更新： 将当前节点值 <code>root-&gt;val</code> 加入路径 <code>path</code> ；</li>
<li>目标值更新： <code>tar = tar - root-&gt;val</code>（即目标值 <code>tar</code> 从<code>sum</code> 减至<code>0</code> ）；</li>
<li>路径记录： 当 ① <code>root</code>为叶节点 且 ② 路径和等于目标值 ，则将此路径 <code>path</code>加入<code>res</code>。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop_back()</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        tar -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (tar == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        dfs(root-&gt;left,tar);</span><br><span class="line">        dfs(root-&gt;right,tar);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629144342707.png" alt="image-20210629144342707"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  36 - 二叉搜索树与双向链表</title>
    <url>/2021/06/29/SwordToOffer%20-%2036%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-36-二叉搜索树与双向链表"><a href="#《剑指Offer》-36-二叉搜索树与双向链表" class="headerlink" title="《剑指Offer》  36 - 二叉搜索树与双向链表"></a>《剑指Offer》  36 - 二叉搜索树与双向链表</h1><p><strong>题目：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表</a></strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629174716566.png" alt="image-20210629174716566" style="zoom:50%;" />

<p>希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。<code>head</code> 表示指向链表中有最小元素的节点。</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629174744696.png" alt="image-20210629174744696" style="zoom:67%;" />

<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p><strong>本题与LeetCode426相同：</strong> <a href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank" rel="noopener">Leetcode426</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>中序遍历递归流程：</strong></p>
<ul>
<li>1  - 终止条件，当节点<code>cur</code>为空，直接返回</li>
<li>2 - 递归左子树</li>
<li>3 - 构建链表<ul>
<li>当 <code>pre</code> 为空时，代表正在访问链表头结点，记为 <code>head</code></li>
<li>当 <code>pre</code> 不为空，修改节点指针，前一个节点的右指针指向当前节点 <code>pre-&gt;right = cur</code>，当前节点的左指针指向前一个节点 <code>cur-&gt;left = pre</code></li>
<li>保存 <code>cur</code>，更新 <code>pre = cur</code>，即当前节点 <code>cur</code> 是后继节点的 <code>pre</code></li>
</ul>
</li>
<li>4 - 递归右子树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *pre, *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre) </span><br><span class="line">            pre-&gt;right = cur;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head = cur; <span class="comment">// pre为空，说明此时在访问头节点</span></span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur; <span class="comment">// 后移</span></span><br><span class="line">        inOrder(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210629200045502.png" alt="image-20210629200045502"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  38 - 字符串的排列</title>
    <url>/2021/06/30/SwordToOffer%20-%2038%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-38-字符串的排列"><a href="#《剑指Offer》-38-字符串的排列" class="headerlink" title="《剑指Offer》  38 - 字符串的排列"></a>《剑指Offer》  38 - 字符串的排列</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a></p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h4><p><strong>全排列：</strong></p>
<p>把字符串<code>&quot;abcc&quot;</code>分成两部分，第一部分是第一个字符<code>&quot;a&quot;</code>，另一部分是剩下的字符<code>&quot;bcd&quot;</code>，</p>
<p><strong>去重：</strong></p>
<p>如果字符串中不存在重复元素，可以省略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.find(s[i]) != st.end()) <span class="keyword">continue</span>;</span><br><span class="line">st.insert(s[i]);</span><br></pre></td></tr></table></figure>

<p>这段代码用来去掉重复元素，比如<code>&quot;abb&quot;</code>的全排列只有三种，而<code>&quot;abc&quot;</code>的全排列有六种。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        _permutation(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _permutation(<span class="built_in">string</span> s, <span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.size() - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.find(s[i]) != st.end()) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            st.insert(s[i]); 			<span class="comment">// 用来去重</span></span><br><span class="line">            swap(s[i], s[index]);  		<span class="comment">// 交换</span></span><br><span class="line">            _permutation(s, index + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            swap(s[i], s[index]); 		<span class="comment">// 回溯</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630145433031.png" alt="image-20210630145433031"></p>
<h4 id="方法二-next-permutation"><a href="#方法二-next-permutation" class="headerlink" title="方法二 next_permutation"></a>方法二 next_permutation</h4><p><code>next_permutation(first, last)</code>; <code>next_permutation()</code>会以字典序取得<code>[first,last)</code>所标示之序列的下一个排列组合。想要全部的排列，初始化的时候需要先给<code>string</code>排序，使之<strong>处于最小的字典序排列</strong>，之后循环遍历即可。</p>
<p>比如<code>1234</code>的下一个字典序为 <code>1243</code>，之后 是 <code>1324</code> ，<code>1342 ....</code>，对于任意一个序列，他的下一个字典序的求法，从后往前遍历，先找到一个递增点，比如求<code>s = &quot;15432&quot;</code>的下一个字典序<code>21345</code>，即 <code>1 &gt; 5</code>, 找到<code>1</code>，<code>1</code> 的下标是<code>0</code>，令 <code>i = 0</code>，再从后向前遍历，找到一个比 <code>1</code> 大的数字，是 <code>2</code>，其下标是<code>4</code>，则<code>j = 4</code>，交换这两个数字的顺序，<code>15432 -&gt; 25431</code>，由于之前的找<code>i</code>和 <code>j</code>的操作，<code>i</code> 和 <code>j</code> 之间的序列字典序一定是递减的，所有最后<code>reserve s[i+1]到最后的元素</code>，变成递增的，才符合字典序，即<code>[5431</code>]变成<code>[1345]</code>，最终结果为<code>21345</code>。</p>
<p><strong>调用库函数实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.emplace_back(s);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next_permutation(s.begin(),s.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630153928704.png" alt="image-20210630153928704"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nexPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] &gt;= s[i + <span class="number">1</span>]) i--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] &gt;= s[j]) j--;</span><br><span class="line"></span><br><span class="line">        swap(s[i],s[j]);</span><br><span class="line">        reverse(s.begin() + i + <span class="number">1</span>, s.end());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.emplace_back(s);</span><br><span class="line">        &#125; <span class="keyword">while</span> (nexPermutation(s));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630154756876.png" alt="image-20210630154756876"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  37 - 序列化二叉树</title>
    <url>/2021/06/30/SwordToOffer%20-%2037%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-37-序列化二叉树"><a href="#《剑指Offer》-37-序列化二叉树" class="headerlink" title="《剑指Offer》  37 - 序列化二叉树"></a>《剑指Offer》  37 - 序列化二叉树</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示：两个函数可以实现互相转化即可，所以空指针可以使用 <code>$</code>、<code>#</code>或其他符号代替</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630102356814.png" alt="image-20210630102356814" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode297相同：</strong><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h4><ul>
<li>由题意知，如果使用层序遍历，如示例所示，利用层序遍历的性质，层序遍历中父节点和其左右子节点的索引位置关系是唯一确定的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> output;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!node) output &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                output &lt;&lt; node-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(input &gt;&gt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == <span class="string">"#"</span>) nodes.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">else</span> nodes.push_back(<span class="keyword">new</span> TreeNode(stoi(val)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i] == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            nodes[i]-&gt;left = nodes[pos++];</span><br><span class="line">            nodes[i]-&gt;right = nodes[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630103458521.png" alt="image-20210630103458521"></p>
<h4 id="方法二-递归-先序遍历"><a href="#方法二-递归-先序遍历" class="headerlink" title="方法二 递归 + 先序遍历"></a>方法二 递归 + 先序遍历</h4><p><strong>反序列列化：</strong> 先序遍历为：1 2 4 # # # 3 5 # # 6 # #</p>
<ul>
<li>第一个读出的数字是 1 ，由于前序遍历是从根节点开始，所以 1 是根节点的值。接下来读出的数字是 2 ，根据前序遍历的规则，这是根节点左子节点的值。以此类推，接下来的数字 4 是值为 2 的节点的左子节点。接着从序列里读出两个 # ，表明值为 4 的节点的左右子节点均为 nullptr 指针，因此这是一个叶子节点。接下来回到值为2的节点，重建其右子节点。下一个字符是 #，表明值为2的节点的右子节点为 nullptr 指针。此节点左右子树均已经构建完成，接下来回到根节点，反序列化根节点右子树。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> output;</span><br><span class="line">        _serialize(root, output);</span><br><span class="line">        <span class="keyword">return</span> output.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _serialize(TreeNode* root, <span class="built_in">ostringstream</span>&amp; output)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            output &lt;&lt; <span class="string">"#"</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        _serialize(root-&gt;left, output);</span><br><span class="line">        _serialize(root-&gt;right, output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; data_list;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                data_list.push_back(s);</span><br><span class="line">                s.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s.push_back(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            data_list.push_back(s);</span><br><span class="line">            s.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _deserialize(data_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* _deserialize(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;&amp; data_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data_list.front() == <span class="string">"#"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data_list.erase(data_list.begin());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(stoi(data_list.front()));</span><br><span class="line">        data_list.erase(data_list.begin());</span><br><span class="line">        node-&gt;left = _deserialize(data_list);</span><br><span class="line">        node-&gt;right  = _deserialize(data_list);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630133757930.png" alt="image-20210630133757930"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  40 - 最小的k个数</title>
    <url>/2021/07/01/SwordToOffer%20-%2040%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-40-最小的k个数"><a href="#《剑指Offer》-40-最小的k个数" class="headerlink" title="《剑指Offer》  40 - 最小的k个数"></a>《剑指Offer》  40 - 最小的k个数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入<code>4、5、1、6、2、7、3、8</code>这<code>8</code>个数字，则最小的<code>4</code>个数字是 <code>1、2、3、4</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000</span><br><span class="line">0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：基于快速排序寻找最小的k个数，会修改原数组"><a href="#方法一：基于快速排序寻找最小的k个数，会修改原数组" class="headerlink" title="方法一：基于快速排序寻找最小的k个数，会修改原数组"></a>方法一：基于快速排序寻找最小的k个数，会修改原数组</h4><p>如果某次划分后基准数下标正好是<code>k+1</code>，则它左边的所有数字便是题目所求的最小的<code>k</code>个数。而划分时候则划分为最小的<code>k</code>个数和其他数字两部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.size()) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[left]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[left]) i++;</span><br><span class="line">            swap(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[left]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.assign(arr.begin(),arr.begin() + k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701110253793.png" alt="image-20210701110253793"></p>
<h4 id="方法二：堆排序，无需修改原数组"><a href="#方法二：堆排序，无需修改原数组" class="headerlink" title="方法二：堆排序，无需修改原数组"></a>方法二：堆排序，无需修改原数组</h4><ul>
<li><code>priority_queue</code> 优先队列的栈顶元素为栈中的最大值，所有一旦遍历到比栈顶元素小的值，就用其替换，这样遍历到结尾，栈顶元素即是第<code>k</code>小的数。栈内元素即是最小的 <code>k</code> 个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 优先队列，大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            q.push(arr[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (q.top() &gt; arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701121145285.png" alt="image-20210701121145285"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  39 - 数组中出现次数超过一半的数字</title>
    <url>/2021/07/01/SwordToOffer%20-%2039%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-39-数组中出现次数超过一半的数字"><a href="#《剑指Offer》-39-数组中出现次数超过一半的数字" class="headerlink" title="《剑指Offer》  39 - 数组中出现次数超过一半的数字"></a>《剑指Offer》  39 - 数组中出现次数超过一半的数字</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字</a></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode169相同：</strong><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：排序选众数"><a href="#方法一：排序选众数" class="headerlink" title="方法一：排序选众数"></a>方法一：排序选众数</h4><ul>
<li>做此题时的第一想法就是先排序，然后遍历计数，但是没有想到超过一半的数字在排序后有一个特性，即排序后的数组中间必是此众数。</li>
<li>一般调用的语言自带排序算法空间复杂度为 $O(\log{n})$ 的栈空间，如果要求使用 $O(1)$的空间，可以自己编写堆排序函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630204239506.png" alt="image-20210630204239506"></p>
<h4 id="方法二：基于快速排序划分选众数，速度快但是会修改原数组"><a href="#方法二：基于快速排序划分选众数，速度快但是会修改原数组" class="headerlink" title="方法二：基于快速排序划分选众数，速度快但是会修改原数组"></a>方法二：基于快速排序划分选众数，速度快但是会修改原数组</h4><ul>
<li>在快速排序中，会随机挑选一个数字，然后把比它小的移动到它的左边，比它大的移动到它右边，如果这个选中的数字的下标刚好是 $\frac{n}{2}$，那么此数就是中位数，如果它的下标大于$\frac{n}{2}$，那么中位数在它左边，去左边数组找，同理，如果它的下标小于$\frac{n}{2}$，就去右边找。用递归实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rand() % (end - start + <span class="number">1</span>) + start; <span class="comment">// 表示 start ~ end 之间的随机数</span></span><br><span class="line">        swap(data[index], data[end]);</span><br><span class="line">        <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (index = start; index &lt; end; ++index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[index] &lt; data[end])</span><br><span class="line">            &#123;</span><br><span class="line">                ++small;</span><br><span class="line">                <span class="keyword">if</span> (small != index) swap(data[index], data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small;</span><br><span class="line">        swap(data[small],data[end]);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mid = length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = Partition(nums, length, start, end);</span><br><span class="line">        <span class="keyword">while</span> (index != mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">                index = Partition(nums, length, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">                index = Partition(nums, length, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701102759182.png" alt="image-20210701102759182"></p>
<h4 id="方法三：Boyer-Moore-投票算法（最优，时间-O-n-空间-O-1-），不会修改原数组"><a href="#方法三：Boyer-Moore-投票算法（最优，时间-O-n-空间-O-1-），不会修改原数组" class="headerlink" title="方法三：Boyer-Moore 投票算法（最优，时间$O(n)$  空间$O(1)$），不会修改原数组"></a>方法三：Boyer-Moore 投票算法（最优，时间$O(n)$  空间$O(1)$），不会修改原数组</h4><ul>
<li>设众数为<code>x</code>，数组长度为 <code>n</code>，则有：<ul>
<li>若记众数的票数为 <code>+1</code>，非众数的票数为<code>-1</code>，则<strong>所有数字的票数和大于0</strong></li>
<li>若数组的前<code>a</code>个数字的票数和为<code>0</code>，则剩余<code>(n - a)</code>个数字的<strong>票数和一定大于0</strong>，且后<code>(n - a)</code>个数字的众数仍为 <code>x</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> votes = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) res = num;</span><br><span class="line">            res == num ? votes ++ : votes--;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210630205043433.png" alt="image-20210630205043433"></p>
<p>由于题目说明<code>给定的数组总是存在多数元素</code> ，因此本题不用考虑 数组不存在众数 的情况。若考虑，需要加入一个 “验证环节” ，再一次遍历数组<code>nums</code>统计 x 的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> votes = <span class="number">0</span>, res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) res = num;</span><br><span class="line">            res == num ? votes ++ : votes--;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span> (num == res) cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; nums.size() / <span class="number">2</span> ? res : <span class="number">-1</span>; <span class="comment">// -1-代表没有众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法四：随机化"><a href="#方法四：随机化" class="headerlink" title="方法四：随机化"></a>方法四：随机化</h4><p>对于此题，众数的数量超过一半，随机挑选一个，有很大几率找到众数。此方法的期望的时间复杂度为 $o(n)$，空间复杂度为 $O(1)$</p>
<p>原理：当众数恰好占据数组的一半时，第一次随机我们有 $\frac{1}{2}$ 的概率找到众数，如果没有找到，则第二次随机时，包含上一次我们有 $\frac{1}{4}$ 的概率找到众数，以此类推。因此期望的次数为 $i * \frac{1}{2^i}i $的和，可以计算出这个和为 <code>2</code>，说明期望的随机次数是常数。每一次随机后，我们需要 $O(n)$的时间判断这个数是否为众数，因此期望的时间复杂度为 $O(n)$。</p>
<p>$\lim_{n \to \infty}{\sum_{i=1}^{n}i*\frac{1}{2^i}} = 2$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> candidate = nums[rand() % nums.size()];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">                <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; nums.size() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701084118659.png" alt="image-20210701084118659"></p>
<h4 id="方法五：哈希表，容易想到，但是浪费空间"><a href="#方法五：哈希表，容易想到，但是浪费空间" class="headerlink" title="方法五：哈希表，容易想到，但是浪费空间"></a>方法五：哈希表，容易想到，但是浪费空间</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[num]++;</span><br><span class="line">            <span class="keyword">if</span> (mp[num] &gt; cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = mp[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701084504485.png" alt="image-20210701084504485"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  41 - 数据流中的中位数</title>
    <url>/2021/07/01/SwordToOffer%20-%2041%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-41-数据流中的中位数"><a href="#《剑指Offer》-41-数据流中的中位数" class="headerlink" title="《剑指Offer》  41 - 数据流中的中位数"></a>《剑指Offer》  41 - 数据流中的中位数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p><code>[2,3,4]</code> 的中位数是 <code>3</code></p>
<p><code>[2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code></p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中。</li>
<li><code>double findMedian()</code> - 返回目前所有元素的中位数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">最多会对 addNum、findMedian 进行 50000 次调用。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode295相同：</strong><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="最大堆与最小堆"><a href="#最大堆与最小堆" class="headerlink" title="最大堆与最小堆"></a>最大堆与最小堆</h4><p>在<code>C++</code>中可以用优先队列表示堆，声明如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt; Type, Container, Functional &gt;</span><br></pre></td></tr></table></figure>

<p><code>Type</code> 就是数据类型，<code>Container</code> 就是容器类型（<code>Container</code>必须是用数组实现的容器，比如<code>vector</code>,<code>deque</code>等等，但不能用 <code>list</code>。<code>STL</code>里面默认用的是<code>vector</code>），<code>Functional</code> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是最大堆</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; left_q;  <span class="comment">// 大根堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; right_q; <span class="comment">// 小根堆</span></span><br></pre></td></tr></table></figure>

<p>对于此题，可以维护一个最大堆和最小堆，其中最大堆代表中位数往左的部分，最小堆代表中位数向右的部分。在数据不断增多的过程中，要保证两个堆的大小相差不超过<code>1</code>。</p>
<p>举例：</p>
<ul>
<li>当两个堆的大小相等时，一共有偶数个数，中位数是两个堆的堆顶元素之和的一半，此时添加一个数，优先往右放（最小堆），放完之后调整，将最小堆栈顶元素移动到最大堆，这样从<code>if (left_q.size() == right_q.size())</code>出来时左边比右边多一个元素，总和是奇数，求中位数可以直接返回左边（最大堆）的栈顶元素。</li>
<li>由于上述的处理，右边的个数只能出现等于左边或者小于左边<code>1</code>个的情况。所以当两个堆的元素之和为奇数时，必是左边个数比右边多一个，此时添加一个元素，优先往左边添加，添加后取出左边栈顶元素给右边。这样从 <code>else {  }</code>出来后，左右元素个数一样多。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; left_q;  <span class="comment">// 大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; right_q; <span class="comment">// 小根堆</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left_q.size() == right_q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            right_q.push(num);</span><br><span class="line">            left_q.push(right_q.top());</span><br><span class="line">            right_q.pop();         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left_q.push(num);</span><br><span class="line">            right_q.push(left_q.top());</span><br><span class="line">            left_q.pop();           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left_q.size() == right_q.size()) <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">return</span> (left_q.top() + right_q.top()) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> left_q.top() * <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701152407678.png" alt="image-20210701152407678"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  42 - 连续子数组的最大和</title>
    <url>/2021/07/01/SwordToOffer%20-%2042%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-42-连续子数组的最大和"><a href="#《剑指Offer》-42-连续子数组的最大和" class="headerlink" title="《剑指Offer》  42 - 连续子数组的最大和"></a>《剑指Offer》  42 - 连续子数组的最大和</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为$O(n)$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1:</span><br><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</span><br><span class="line">-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode53相同：</strong><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>{1, -2, 3, 10, -4, 7, 2, -5}</strong></p>
<ul>
<li><p>初始化和为<code>0</code>，加上第一个数字为<code>1</code>，为<code>1</code>，加上第二个数字为<code>-2</code>后为<code>-1</code>，下一个是<code>3</code>，加上<code>3</code>后等于<code>2</code>，比<code>3</code>还小，还不如不加，所以之前的累积果断抛弃，从<code>3</code>开始，<code>3+10=13</code>,<code>13-4=9</code>，发现变小了，但是万一它加了后面的又变大了呢，所以把<code>13</code>先记下来，它是答案的一个备选方案，后面加上<code>7</code>,<code>9+7=16</code>，又比<code>13</code>大了，把<code>13</code>抛弃，把<code>16</code>记下来，<code>16+2=18</code>，抛弃<code>16</code>记<code>18</code>,<code>18-5=13</code>，结束，答案为<code>18</code>。<code>if (curSum &lt;= ) curSum = nums[i]</code> 用于处理接连出现负数的情况，比如序列<code>{-2,-1}</code>，结果就是<code>-1</code>。</p>
</li>
<li><p>递归公式如下：<br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701203420913.png" alt="image-20210701203420913"></p>
</li>
<li><p>$f(i-1)$表示以第$i-1$个数字为结尾的子数组的和，如果它小于0，那它加上第$i$个数字，还不如不加，拖后腿，所以$f(i)$在此时就等于<code>nums[i]</code>，如果$f(i-1)&gt;0$，它就可以和<code>nums[i]</code>相加了，不会拖后腿了。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum = <span class="number">0x80000000</span>; <span class="comment">// -2147483648</span></span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span> (curSum &lt;= <span class="number">0</span>) curSum = nums[i];</span><br><span class="line">            <span class="keyword">else</span> curSum += nums[i];</span><br><span class="line">            maxSum = max(curSum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701165737771.png" alt="image-20210701165737771"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">            sum += x;</span><br><span class="line">            res = max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210701201210884.png" alt="image-20210701201210884"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  43 - 1~n 整数中1出现的次数</title>
    <url>/2021/07/02/SwordToOffer%20-%2043%201~n%20%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-43-1-n-整数中1出现的次数"><a href="#《剑指Offer》-43-1-n-整数中1出现的次数" class="headerlink" title="《剑指Offer》  43 - 1~n 整数中1出现的次数"></a>《剑指Offer》  43 - 1~n 整数中1出现的次数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></p>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode233相同：</strong><a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">233. 数字 1 的个数</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="逐位固定，分情况计数"><a href="#逐位固定，分情况计数" class="headerlink" title="逐位固定，分情况计数"></a>逐位固定，分情况计数</h4><p>将数字分为两部分，高位和低位，交界处为当前位，初始值为 <code>high = n / 10</code>, <code>cur = n % 10</code>, <code>low = 0</code>，<code>digit</code>为$10^i$, <code>i</code>为位数，<code>cur</code>在个位时<code>i = 0</code>，<code>digit = 1</code>，<code>cur</code>在十位时<code>i = 1</code>，<code>digit = 10</code>，以此类推。对当前值<code>cur</code>分情况讨论：</p>
<ul>
<li>当 <code>cur == 0</code> 时  $res += high \times digit$</li>
<li>当<code>cur == 1</code>  $res += high \times digit + low +1$</li>
<li>当<code>1 &lt; cur &lt;= 9</code> $res += (high +1) \times digit$</li>
</ul>
<p>以 <code>2104</code>为例：初始值<code>hight = 210</code> , <code>cur = 4</code> , <code>low = 0</code> , $dight = 10^0 = 1$</p>
<ul>
<li><code>cur = 4</code>, <code>hight = 210</code>, $(210+1)\times 10^0 = 211$，由于<code>4</code>大于<code>1</code>，所以此位出现<code>1</code>的个数为<code>211</code>个，范围在<code>0000 ~ 2101</code>之间，这之间 <code>0011 0021 0031 ..0091,0101,0201..2081,2091,2101</code>。可以看到其实就是高位的<code>000~210</code>范围内的数，为什么要乘以 <code>digit</code>呢，如果是<code>2140</code>,<code>cur</code>在十位，十位为<code>1</code>的个位为$(21+1)\times10=220$，此时如果把<code>cur</code>去掉，只看高低位，高位为<code>21</code>，最高只能取到<code>21</code>，但是低位可以取到满，即取到<code>9</code>，和起来就是<code>219</code>，高低位的取值在<code>0~219</code>之间，共<code>220</code>个数 。</li>
<li>左移，<code>cur = 0</code>，<code>high = 21</code>，<code>low = 4</code>，$21 \times 10^1=210$，此位出现<code>1</code>的个位只由高位决定，范围在<code>0010~2019</code>，这之间 <code>0010 0011 0012 0013 ... 0111 0112 0113.. 0210 0211 0213.. 0919. .1010 1011 1012.. 2018 2019</code>。可见，去掉<code>cur</code>位置，<code>2104变成214</code>。高位和低位和起来就是<code>000~209</code>，为什么是<code>209</code>，如果是<code>210</code>，那在<code>1</code>和<code>0</code>之间加<code>cur</code>，<code>cur=0</code>，就是<code>2100</code>,<code>1</code>并没有出现在十位上，所以<code>2100</code>不是<code>1</code>出现在<code>cur</code>位置上的数，所以共<code>210</code>个数。</li>
<li>左移，<code>cur = 1</code>，<code>high = 2</code>，<code>low = 04</code>，$2\times10^2+04+1=205$，同理，去掉<code>cur</code>位置，<code>2104</code>变成<code>204</code>，由高位得可以取到<code>0~199</code>这<code>200</code>个数，但是<code>cur=1</code>,<code>200,201,202,203,204</code>都可以取到，在<code>2</code>和<code>0</code>之间添加上<code>cur</code>位的<code>1</code>，就是<code>2100,2101,2102,2103,2104</code>，所以共<code>205</code>个数</li>
<li>左移，<code>cur = 2</code>，<code>high = 0</code>，<code>low = 104</code>，$(0+1)\times10^3=1000$，与上同理，总计$211+210+205+1000=1626$个<code>1</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>, low = <span class="number">0</span>, cur = n % <span class="number">10</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            low += cur * digit;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210702144614714.png" alt="image-20210702144614714"></p>
<p><strong>求任意数字出现次数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param k: An integer</span></span><br><span class="line"><span class="comment">     * @param n: An integer</span></span><br><span class="line"><span class="comment">     * @return: An integer denote the count of digit k in 1..n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitCounts</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, high = n / <span class="number">10</span>, low = <span class="number">0</span>, cur = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (high || (cur &amp;&amp; k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; k) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == k) res += (high - (k == <span class="number">0</span>)) * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + (k != <span class="number">0</span>)) * digit;</span><br><span class="line">            low += cur * digit;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + (k == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  44 - 数字序列中某一位的数字</title>
    <url>/2021/07/02/SwordToOffer%20-%2044%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-44-数字序列中某一位的数字"><a href="#《剑指Offer》-44-数字序列中某一位的数字" class="headerlink" title="《剑指Offer》  44 - 数字序列中某一位的数字"></a>《剑指Offer》  44 - 数字序列中某一位的数字</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字</a></p>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode400相同：</strong><a href="https://leetcode-cn.com/problems/nth-digit/" target="_blank" rel="noopener">400. 第 N 位数字</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="找规律："><a href="#找规律：" class="headerlink" title="找规律："></a>找规律：</h4><table>
<thead>
<tr>
<th>范围</th>
<th>数字个数</th>
<th>数字所占位数个数</th>
</tr>
</thead>
<tbody><tr>
<td>1 ~ 9</td>
<td>0</td>
<td>9 = 1 * 9</td>
</tr>
<tr>
<td>10 ~ 99</td>
<td>90</td>
<td>180 = 2 * 9 *10</td>
</tr>
<tr>
<td>100 ~ 999</td>
<td>900</td>
<td>2700 = 3 * 9 * 100</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>分析过程：以<code>n = 1001</code>举例：</p>
<p><code>1001 &gt; 9</code>: <code>n -= cnt = 1001 - 9 = 992</code>，<code>digit = 2</code>，<code>start = 10</code>，<code>cnt = 2 * 9 * 10 = 180</code></p>
<p><code>992 &gt; 180</code> ：<code>n -= cnt = 992 - 180 = 812</code>, <code>digit = 3</code>, <code>start = 100</code>, <code>cnt = 3 * 9 * 100 = 2700</code></p>
<p><code>812 &lt; 2700</code> : 退出 <code>while</code>循环</p>
<p>锁定具体数字，由于<code>digit = 3</code>，所以现在是在三位数的范围，即<code>100 ~ 999</code>，所以 <code>num = 100 + (812 - 1) / 3 = 370</code>，<strong>这里减1的作用是当n对应num中的最后一位时，不会由于进位，错误的寻找到下一个数字</strong>。（如果这个<code>812</code>是<code>6</code>,则<code>100,101</code>,第六个是<code>101</code>中的个数上的<code>1</code>，如果不减<code>1</code>，则<code>num = 100 + 6/3 = 102</code>，错误的寻找到了下一个数字），之后将<code>num</code>转换为字符串，<code>(812 - 1) % 3 = 1</code>，这里取<code>n-1</code>使得<code>num</code>中各位的位置坐标从左到右从<code>0</code>开始增加，更容易计算。字符串<code>&quot;370&quot;</code>的 索引<code>1</code>位置 为<code>7</code>，即为最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>, cnt = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            cnt = digit * <span class="number">9</span> * start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) /digit;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">return</span> s[(n - <span class="number">1</span>) % digit] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210702170007937.png" alt="image-20210702170007937"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  45 - 把数组排成最小的数</title>
    <url>/2021/07/04/SwordToOffer%20-%2045%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-45-把数组排成最小的数"><a href="#《剑指Offer》-45-把数组排成最小的数" class="headerlink" title="《剑指Offer》  45 - 把数组排成最小的数"></a>《剑指Offer》  45 - 把数组排成最小的数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></p>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br><span class="line"> </span><br><span class="line">提示:</span><br><span class="line">0 &lt; nums.length &lt;&#x3D; 100</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">输出结果可能非常大，所以你需要返回一个字符串而不是整数</span><br><span class="line">拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>看到这一题的第一想法是先进行排序，但是怎么排序呢？可以很自然的想到使用字典序的排列方式，首先先将<code>int</code>整数转换为字符串，对于<code>a</code>和<code>b</code>，可以组成<code>ab</code>和<code>ba</code>，如果<code>ab</code>小于<code>ba</code>，那么自然是<code>a</code>在前<code>b</code>在后。</p>
<p><strong>证明：</strong>一个有效的比较规则需要三个条件：<strong>自反性</strong>、<strong>对称性</strong>、<strong>传递性</strong></p>
<ul>
<li>自反性：<ul>
<li>因为 $xx = xx$，所以 $x = x$。</li>
</ul>
</li>
<li>对称性：<ul>
<li>如果 $x$ 小于$y$（$x$在$y$前面），则$xy&lt;yx$，所以 $yx&gt;xy$，因此 $y$ 大于$x$（ $y$在$x$后面）。</li>
</ul>
</li>
<li>传递性：</li>
</ul>
<p>字符串$xy &lt; yx $ , $yz &lt; zy$ , 需要证明 $xz &lt;zx$一定成立</p>
<p>设十进制数 $x,y,z$ 分别有 $a,b,c$ 位，字符串与其对应的十进制数关系为：</p>
<p>$$xy = x \times 10^b + y$$</p>
<p>$$yx = y \times 10^a +x$$</p>
<p>则 $xy &lt;yx$ 可转换为：</p>
<p>$$x<em>10^b + y &lt; y</em>10^a +x$$</p>
<p>$$x<em>10^b-x &lt; y</em>10^a - y$$</p>
<p>$$x(10^b-1) &lt; y*(10^a-1)  \Rightarrow  \frac{x}{10^a-1}&lt;\frac{y}{10^b-1}  \tag{1}$$</p>
<p>同理 ，可将$yz &lt; zy$ 转化为 $$\frac{y}{10^b-1} &lt; \frac{z}{10^c-1} \tag{2}$$</p>
<p>将$(1)(2)$合并整理可得：</p>
<p>$$\frac{x}{10^a-1} &lt; \frac{y}{10^b-1} &lt;\frac{z}{10^c-1} \tag{3}$$</p>
<p>所以：</p>
<p>$$\frac{x}{10^a-1}&lt;\frac{z}{10^c-1} \Rightarrow x(10^c-1) &lt; z(10^a-1) \tag{4}$$</p>
<p>展开得：</p>
<p>$$x<em>10^c - x &lt; z</em>10^a - z \Rightarrow x<em>10^c +z &lt; z</em>10^a +x \tag{5}$$</p>
<p>由$(5)$可退出$xz &lt;zx$，传递性证毕。</p>
<h4 id="方法一：内置排序"><a href="#方法一：内置排序" class="headerlink" title="方法一：内置排序"></a>方法一：内置排序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            strs.push_back(to_string(num));</span><br><span class="line">        sort(strs.begin(),strs.end(),compare);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s : strs)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210704161422016.png" alt="image-20210704161422016"></p>
<p><strong>使用匿名函数的写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            strs.push_back(to_string(nums[i]));</span><br><span class="line">        sort(strs.begin(), strs.end(), [](<span class="built_in">string</span>&amp; x, <span class="built_in">string</span>&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210704161736484.png" alt="image-20210704161736484"></p>
<h4 id="方法二：快速排序"><a href="#方法二：快速排序" class="headerlink" title="方法二：快速排序"></a>方法二：快速排序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            strs.push_back(to_string(nums[i]));</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (strs[j] + strs[left] &gt;= strs[left] + strs[j] &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (strs[i] + strs[left] &lt;= strs[left] + strs[i] &amp;&amp; i &lt; j) i++;</span><br><span class="line">            swap(strs[i], strs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(strs[i], strs[left]);</span><br><span class="line">        quickSort(strs, left, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210704165548578.png" alt="image-20210704165548578"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  46 - 把数字翻译成字符串</title>
    <url>/2021/07/04/SwordToOffer%20-%2046%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-46-把数字翻译成字符串"><a href="#《剑指Offer》-46-把数字翻译成字符串" class="headerlink" title="《剑指Offer》  46 - 把数字翻译成字符串"></a>《剑指Offer》  46 - 把数字翻译成字符串</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 46. 把数字翻译成字符串</a></p>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; num &lt; 231</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>动态规划问题</strong>：</p>
<p>记数字 $num$ 第 $i$ 位数字为 $x_i$ ，$num$  共有 $n$  位，$num = 12256 ，n = 5，x_1 = 1$</p>
<p><strong>状态定义：</strong>  $dp[i]$ 代表 以 $x_i$ 为结尾的数字的翻译方式数</p>
<p><strong>状态转移方程：</strong>若 $x_i$ 和 $x_{i-1}$ 组成的数在 $10 ~ 25$ 之间，则 $dp[i] = dp[i-1] + dp[i-2]$；否则$dp[i] = dp[i-1]$</p>
<p><strong>初始状态：</strong> $dp[0] = dp[1] = 1$，即无数字和第一位数字的翻译数量均为<code>1</code>，当 $num$ 第 <code>1</code>, <code>2</code> 位的组成的数字 $\in [10,25]$ 时，显然应有 <code>2</code> 种翻译方法，即 $dp[2] = dp[1] + dp[0] = 2$ ，而 $dp[1] = 1$ ，因此推出 $dp[0] = 1$。</p>
<p><strong>返回值：</strong> $dp[n]$</p>
<h4 id="方法一：转换为字符串做动态规划-O-n-O-n"><a href="#方法一：转换为字符串做动态规划-O-n-O-n" class="headerlink" title="方法一：转换为字符串做动态规划 $O(n) - O(n)$"></a>方法一：转换为字符串做动态规划 $O(n) - O(n)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> len = str.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i<span class="number">-2</span>] == <span class="string">'1'</span> || (str[i<span class="number">-2</span>] == <span class="string">'2'</span> &amp;&amp; str[i<span class="number">-1</span>] &lt;= <span class="string">'5'</span>))</span><br><span class="line">                dp[i] = dp[i<span class="number">-2</span>] + dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210704205110401.png" alt="image-20210704205110401"></p>
<h4 id="方法二：数字取余，滚动数组-O-n-O-1"><a href="#方法二：数字取余，滚动数组-O-n-O-1" class="headerlink" title="方法二：数字取余，滚动数组 $O(n) - O(1)$"></a>方法二：数字取余，滚动数组 $O(n) - O(1)$</h4><ul>
<li>类似于求斐波那契数列问题和爬楼梯问题，只需要三个变量即可完成动态规划</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> xy = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="keyword">int</span> c = (xy &gt;= <span class="number">10</span> &amp;&amp; xy &lt;= <span class="number">25</span>) ? a + b : b; <span class="comment">// a b c</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210704211508840.png" alt="image-20210704211508840"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  48 - 最长不含重复字符的子字符串</title>
    <url>/2021/07/05/SwordToOffer%20-%2048%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-48-最长不含重复字符的子字符串"><a href="#《剑指Offer》-48-最长不含重复字符的子字符串" class="headerlink" title="《剑指Offer》  48 - 最长不含重复字符的子字符串"></a>《剑指Offer》  48 - 最长不含重复字符的子字符串</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">s.length &lt;&#x3D; 40000</span><br></pre></td></tr></table></figure>

<p><strong>此题与LeetCode3相同：</strong><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>一维动态规划问题：</p>
<p><strong>状态定义：</strong>设动态规划列表 $dp$，$dp[i]$ 代表以字符 $s[i]$ 为结尾的最长不含重复字符串的子字符串长度</p>
<p><strong>状态转移方程：</strong> 固定 $i$，从 $i$ 往 前找与 $s[i]$ 相同的字符 $s[j]$，距离为 $i - j$</p>
<ul>
<li>没有找到 s[j] , 且已经找到了字符串开头，则 $dp[i] = dp[i-1] + 1$</li>
<li>$dp[i-1] &lt; i - j$ ，说明与$s[i]$ 相同的字符 $s[j]$  在上个 $dp[i-1]$的区间之外，则 $dp[i] = dp[i-1] + 1$</li>
<li>$dp[i-1] \ge i - j$ ，说明与$s[i]$ 相同的字符 $s[j]$  在上个 $dp[i-1]$的区间之内，则 $dp[i] = i - j$</li>
</ul>
<p><strong>返回值：</strong>$max(dp)$</p>
<p><strong>注意事项：做动态规划题目前，写完状态转移方程后，想一想能否用常数个变量完成动态规划过程，从而避免开辟整个 $dp$ 数组，节省空间开销。</strong></p>
<h4 id="方法一：动态规划-向前遍历寻找-s-j-，-O-N-2-O-1"><a href="#方法一：动态规划-向前遍历寻找-s-j-，-O-N-2-O-1" class="headerlink" title="方法一：动态规划 + 向前遍历寻找 $s[j]$ ，  $O(N^2) - O(1)$"></a>方法一：动态规划 + 向前遍历寻找 $s[j]$ ，  $O(N^2) - O(1)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> j, res = <span class="number">0</span>, dp_temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] != s[i]) j--;</span><br><span class="line">            dp_temp = i - j &gt; dp_temp ? dp_temp + <span class="number">1</span> : i - j;  <span class="comment">// dp[j - 1] -&gt; dp[j]</span></span><br><span class="line">            res = max(dp_temp, res); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705103930147.png" alt="image-20210705103930147"></p>
<h4 id="方法二：动态规划-哈希表-O-N-O-1"><a href="#方法二：动态规划-哈希表-O-N-O-1" class="headerlink" title="方法二：动态规划 + 哈希表 $O(N) - O(1)$"></a>方法二：动态规划 + 哈希表 $O(N) - O(1)$</h4><p>字符的 <code>ASCII</code> 码范围为 <code>0 ~ 127</code>，哈希表 <code>dic</code> 最多使用 $O(128) = O(1)$大小的额外空间，所以空间复杂度为 $O(1)$，哈希表存放着最近一次出现字符的所在位置。</p>
<p>举例说明代码中第一次出现某字符 j = -1 的原因，例如字符串”aba”：</p>
<ul>
<li><p>当<code>i = 0</code> 时，<code>mp</code>还是空的，当然找不到 <code>&quot;a&quot;</code>，所以<code>j = -1</code>，后面 <code>i - j = 0 - (- 1) = 1</code>，<code>dp_temp</code>在 <code>i = 0</code> 处等于 <code>1</code>，<code>res = 1</code></p>
</li>
<li><p>当 <code>i = 1</code>时，<code>mp</code>中只有<code>&quot;a&quot;</code>，找不到 <code>&quot;b&quot;</code>，所以 <code>j</code>仍然是<code>-1</code>，后面<code>i - j = 1 -  (-1) = 2</code>，<code>dp_temp在 i = 1</code> 处等于<code>2</code>，<code>res = 2</code></p>
</li>
<li><p>当 <code>i = 2</code> 时，<code>mp</code>中已经有了<code>&quot;a&quot;</code>，<code>mp[&quot;a&quot;] = 1，j = 1</code>，然后更新一下，令当前的索引 <code>i = 2</code> 赋值给 <code>mp[&quot;a&quot;]</code>，这样<code>mp[&quot;a&quot;]</code>就记录当前 <code>&quot;a&quot;</code>的出现位置，<code>j</code> 记录了上一个 <code>&quot;a&quot;</code> 出现的位置，<code>i - j = 2 - 1 = 1 &lt; res</code>，<code>dp_temp</code>在<code>i = 2</code>处等于<code>1</code>，<code>res = 2</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;    </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, dp_temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = mp.find(s[i]) == mp.end() ? <span class="number">-1</span> : mp[s[i]];</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            dp_temp = dp_temp &lt; i - j ? dp_temp + <span class="number">1</span> : i - j;</span><br><span class="line">            res = max(res, dp_temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705115140695.png" alt="image-20210705115140695"></p>
<h4 id="方法三：哈希表-滑动窗口-O-N-O-1"><a href="#方法三：哈希表-滑动窗口-O-N-O-1" class="headerlink" title="方法三：哈希表 + 滑动窗口  $O(N) - O(1)$"></a>方法三：哈希表 + 滑动窗口  $O(N) - O(1)$</h4><ul>
<li>哈希表记录字符<code>s[i]</code> 最后一次出现的索引</li>
<li>每轮更新左边界 <code>j</code>，保证区间 <code>[j + 1, i]</code> 内无重复字符且最大</li>
<li>每轮更新结果<code>res</code>，取上一轮的<code>res</code>与本轮双指针区间 <code>[j + 1, i]</code>的宽度 <code>i - j</code>比较，取最大值</li>
</ul>
<p><strong>常规写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.find(s[i]) != mp.end())</span><br><span class="line">                j = max (j, mp[s[i]]);</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            res = max(res, i - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705124614621.png" alt="image-20210705124614621"></p>
<p><strong>另一种写法，使用空间更少：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">window</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (window[s[right]])</span><br><span class="line">                window[s[left++]] = <span class="literal">false</span>;</span><br><span class="line">            window[s[right++]] = <span class="literal">true</span>;</span><br><span class="line">            res = max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705120537779.png" alt="image-20210705120537779"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  47 - 礼物的最大值</title>
    <url>/2021/07/05/SwordToOffer%20-%2047%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-47-礼物的最大值"><a href="#《剑指Offer》-47-礼物的最大值" class="headerlink" title="《剑指Offer》  47 - 礼物的最大值"></a>《剑指Offer》  47 - 礼物的最大值</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></p>
<p>在一个 <code>m*n</code> 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于<code>0</code>）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt; grid.length &lt;&#x3D; 200</span><br><span class="line">0 &lt; grid[0].length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>二维动态规划问题：</p>
<p><strong>状态定义：</strong>设动态规划矩阵 $dp$，$dp(i, j)$ 代表从期盼的左上角开始，到达单元格 $(i ,j)$ 时能拿到礼物的最大累积价值</p>
<p><strong>状态转移方程：</strong> </p>
<ul>
<li>$i = 0 , j = 0$ 时，为起始元素</li>
<li>$i = 0, j \ne 0$ 时，为矩阵第一行元素，只可从左边径直向右边走</li>
<li>$i \ne 0, j = 0$ 时，为矩阵第一列元素，只可从上径直向下走</li>
<li>$i \ne 0, j \ne 0$ 时，可从左或上边到达到此处</li>
</ul>
<p><strong>初始值：</strong> $dp[0][0] = grid[0][0]$</p>
<p><strong>返回值：</strong> $dp$ 矩阵右下角元素</p>
<h4 id="方法一-：初级写法，有诸多可优化之处"><a href="#方法一-：初级写法，有诸多可优化之处" class="headerlink" title="方法一 ：初级写法，有诸多可优化之处"></a>方法一 ：初级写法，有诸多可优化之处</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> m = grid.size() - <span class="number">1</span>, n = grid[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705082802718.png" alt="image-20210705082802718"></p>
<h4 id="方法二：多开辟一行一列数组，可以使代码更加简洁"><a href="#方法二：多开辟一行一列数组，可以使代码更加简洁" class="headerlink" title="方法二：多开辟一行一列数组，可以使代码更加简洁"></a>方法二：多开辟一行一列数组，可以使代码更加简洁</h4><ul>
<li>方法一的循环中，之所以要分 <code>i ==</code> 0 和 <code>j == 0</code>的情况讨论，是因为如果不讨论， <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i</code>][j] 中的 <code>i - 1</code>和<code>j - 1</code>会产生越界。如果多开辟一行一列数组从 <code>dp[1][1]</code> 开始，就不需要考虑越界问题，使代码更加简洁。</li>
<li>要注意 <code>dp</code> 数组做了偏移，但是原 <code>grid</code> 数组并没有，所以在循环中是和 <code>grid[i-1][j-1]</code>相加。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                 dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705083730295.png" alt="image-20210705083730295"></p>
<h4 id="方法三：-dp-i-j-只与-dp-i-1-j-dp-i-j-1-grid-i-j-有关系，可使用-grid-矩阵用作-dp-矩阵，在原矩阵上修改，可使用空间复杂度从-O-MN-降低至-O-1"><a href="#方法三：-dp-i-j-只与-dp-i-1-j-dp-i-j-1-grid-i-j-有关系，可使用-grid-矩阵用作-dp-矩阵，在原矩阵上修改，可使用空间复杂度从-O-MN-降低至-O-1" class="headerlink" title="方法三：$dp[i][j]$ 只与 $dp[i-1][j], dp[i][j-1], grid[i][j]$有关系，可使用 $grid$ 矩阵用作 $dp$ 矩阵，在原矩阵上修改，可使用空间复杂度从 $O(MN)$ 降低至 O(1)"></a>方法三：$dp[i][j]$ 只与 $dp[i-1][j], dp[i][j-1], grid[i][j]$有关系，可使用 $grid$ 矩阵用作 $dp$ 矩阵，在原矩阵上修改，可使用空间复杂度从 $O(MN)$ 降低至 O(1)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> ) grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]); </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705084506007.png" alt="image-20210705084506007"></p>
<h4 id="方法三改进：当-grid-矩阵很大时，-i-0-或-j-0-的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。"><a href="#方法三改进：当-grid-矩阵很大时，-i-0-或-j-0-的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。" class="headerlink" title="方法三改进：当 $grid$ 矩阵很大时， $i = 0$  或 $j = 0$ 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。"></a>方法三改进：当 $grid$ 矩阵很大时， $i = 0$  或 $j = 0$ 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]); </span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705084909031.png" alt="image-20210705084909031"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  49 - 丑数</title>
    <url>/2021/07/05/SwordToOffer%20-%2049%20%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-49-丑数"><a href="#《剑指Offer》-49-丑数" class="headerlink" title="《剑指Offer》  49 - 丑数"></a>《剑指Offer》  49 - 丑数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></p>
<p>把只包含质因子 <code>2</code>、<code>3</code> 和 <code>5</code> 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 <code>n</code> 个丑数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line"></span><br><span class="line">说明:  </span><br><span class="line">1 是丑数。</span><br><span class="line">n 不超过1690。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode264相同：</strong><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：三指针定界-动态规划-O-N-O-N"><a href="#方法一：三指针定界-动态规划-O-N-O-N" class="headerlink" title="方法一：三指针定界 + 动态规划 $O(N) - O(N)$"></a>方法一：三指针定界 + 动态规划 $O(N) - O(N)$</h4><p><code>dp</code>数组中的丑数是从小到大排序的，最大记作<code>M</code>，而接下来的丑数必定是之前的某一丑数<code>乘以2 或 3 或 5</code>得到的，对于<code>乘以2</code>而言，肯定存在某一个丑数 <code>dp[a]</code>，排在它之前的每个丑数<code>乘以2</code>的得到的结果都会小于<code>M</code>，在它之后的每个丑数<code>乘以2</code>得到的结果都<code>大于M</code>，这个下标 a 就是第一个界限，同理可得另外两个界 <code>dp[b]和 dp[c]</code>，所以最新求得的丑数，就是 <code>dp[a] * 2</code>,  <code>dp[b] * 3</code>, <code>dp[c] * 5</code> 中的最小值，假设是<code>dp[a] * 2</code>，则 <code>dp[i] = dp[a] * 2</code>，<code>界限 a</code> 右移，<code>a++</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = min(min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705145331063.png" alt="image-20210705145331063"></p>
<h4 id="方法二：小根堆（优先队列）-O-N-log-N-O-N"><a href="#方法二：小根堆（优先队列）-O-N-log-N-O-N" class="headerlink" title="方法二：小根堆（优先队列）$O(N\log(N)) - O(N)$"></a>方法二：小根堆（优先队列）$O(N\log(N)) - O(N)$</h4><p>最小堆初始为空，首先将最小的丑数 <code>1</code>放入最小堆中，每次取出堆顶元素 <code>x</code>，则 <code>x</code>是堆中最小的元素，然后将 <code>2x , 3x , 5x</code> 放入堆中。</p>
<p>用一个集合用来去重，往堆中加入丑数时判断之前是否已经加入过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        priority_queue&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt;&gt; min_heap;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span>&gt; s;</span><br><span class="line">        s.insert(<span class="number">1L</span>);</span><br><span class="line">        min_heap.push(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> curr = min_heap.top();</span><br><span class="line">            min_heap.pop();</span><br><span class="line">            ugly = (<span class="keyword">int</span>)curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> factor : factors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span> (s.count(next) == <span class="number">0</span>) <span class="comment">// count()返回集合中某个值元素的个数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s.insert(next);</span><br><span class="line">                    min_heap.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210705151229723.png" alt="image-20210705151229723"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  53 - 二分查找的灵活使用</title>
    <url>/2021/07/07/SwordToOffer%20-%2053%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-53-二分查找的灵活使用"><a href="#《剑指Offer》-53-二分查找的灵活使用" class="headerlink" title="《剑指Offer》  53 - 二分查找的灵活使用"></a>《剑指Offer》  53 - 二分查找的灵活使用</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></p>
<p>统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>此题与LeetCode34相同：</strong><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：两次二分查找找到此数在数组中的左右边界"><a href="#方法一：两次二分查找找到此数在数组中的左右边界" class="headerlink" title="方法一：两次二分查找找到此数在数组中的左右边界"></a>方法一：两次二分查找找到此数在数组中的左右边界</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)  </span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706214150115.png" alt="image-20210706214150115"></p>
<h4 id="方法二：用二分查找锁定插入点，即target右边的位置"><a href="#方法二：用二分查找锁定插入点，即target右边的位置" class="headerlink" title="方法二：用二分查找锁定插入点，即target右边的位置"></a>方法二：用二分查找锁定插入点，即target右边的位置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insertRight(nums, target) - insertRight(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706214801506.png" alt="image-20210706214801506"></p>
<h4 id="方法三：调用STL方法"><a href="#方法三：调用STL方法" class="headerlink" title="方法三：调用STL方法"></a>方法三：调用STL方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (upper_bound(nums.begin(), nums.end(), target)-lower_bound(nums.begin(), nums.end(), target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706214932723.png" alt="image-20210706214932723"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></p>
<p>一个长度为<code>n-1</code>的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围<code>0～n-1</code>之内。在范围<code>0～n-1</code>内的<code>n</code>个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>中心思想：由于是有序数组，且从0开始，如果不发生缺失元素，数组的元素值等于下标值，缺失的元素在后面，<code>left = mid + 1</code>，如果不等，说明在这之前已经发生了缺失。<code>right = mid - 1</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707092019090.png" alt="image-20210707092019090"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  50 - 第一个只出现一次的字符</title>
    <url>/2021/07/05/SwordToOffer%20-%2050%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-50-第一个只出现一次的字符"><a href="#《剑指Offer》-50-第一个只出现一次的字符" class="headerlink" title="《剑指Offer》  50 - 第一个只出现一次的字符"></a>《剑指Offer》  50 - 第一个只出现一次的字符</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">剑指 Offer 50. 第一个只出现一次的字符</a></p>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：二次遍历-哈希表"><a href="#方法一：二次遍历-哈希表" class="headerlink" title="方法一：二次遍历 + 哈希表"></a>方法一：二次遍历 + 哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">            hash[s[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (hash[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706150330338.png" alt="image-20210706150330338"></p>
<p>上述写法的优化，使用 <code>bool</code> 类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">            hash[c] = (hash.find(c) == hash.end()); <span class="comment">// hash中没有c时为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">            <span class="keyword">if</span> (hash[c]) <span class="keyword">return</span> c;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706150419273.png" alt="image-20210706150419273"></p>
<h4 id="方法二：有序哈希表"><a href="#方法二：有序哈希表" class="headerlink" title="方法二：有序哈希表"></a>方法二：有序哈希表</h4><p>减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，效率更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; keys;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.find(c) == hash.end()) </span><br><span class="line">                keys.push_back(c); <span class="comment">// 首次出现c，放入keys中</span></span><br><span class="line">            hash[c] = (hash.find(c) == hash.end());  <span class="comment">// 有c为false，无c为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : keys)</span><br><span class="line">            <span class="keyword">if</span> (hash[c]) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706150525081.png" alt="image-20210706150525081"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  51 - 数组中的逆序对</title>
    <url>/2021/07/05/SwordToOffer%20-%2051%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-51-数组中的逆序对"><a href="#《剑指Offer》-51-数组中的逆序对" class="headerlink" title="《剑指Offer》  51 - 数组中的逆序对"></a>《剑指Offer》  51 - 数组中的逆序对</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>归并排序与逆序对统计：</strong></p>
<p><strong>终止条件：</strong> 当 $left \ge right$ 时，代表子数组长度为 <code>1</code>，此时终止划分</p>
<p><strong>递归划分：</strong> 计算数组中点 $mid$，递归划分左子数组 <code>merge_sort (left, mid)</code> 和右子数组 <code>merge_sort(mid + 1, right)</code></p>
<p><strong>合并与逆序对统计：</strong></p>
<ul>
<li>暂存数组 $nums$ 闭区间 <code>[i, right]</code>  内的元素到辅助数组 <code>temp</code></li>
<li><strong>循环合并：</strong>设置双指针 <code>i</code> 、<code>j</code> 分别指向左 、右子数组的首个元素<ul>
<li><code>if</code>  <code>i  = mid + 1</code> 时：代表左子数组已经合并完，因此添加右子数组当前元素 <code>temp[j]</code>，并 <code>j++</code></li>
<li><code>else if</code> <code>j = right + 1</code>时：代表右子数组已经合并完，因此添加左子数组当前元素<code>temp[i]</code>，并<code>i++</code></li>
<li><code>else if</code> <code>temp[i] &lt;= temp[j]</code>时：添加左子数组当前元素 <code>temp[i]</code>，并<code>i++</code></li>
<li><code>else</code> <code>temp[i] &gt; temp[j]</code>时：添加右子数组当前元素 <code>temp[j]</code>，并<code>j++</code>，此时构成 <code>mid - i + 1</code>个<strong>逆序对</strong>，统计添加至 <code>res</code></li>
</ul>
</li>
</ul>
<p><strong>返回值：</strong> <code>res</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>; <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="comment">// 归并排序是要修改原数组的，如果面试官要求不能修改数组，需要对原数组进行拷贝</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; copy(nums.size());</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); ++i)</span></span><br><span class="line">        <span class="comment">//     copy[i] = nums[i]</span></span><br><span class="line">        <span class="comment">// return mergeSort(copy, temp, 0, nums.size() - 1);</span></span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, temp, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 区间只剩下一个元素，不存在逆序对</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPairs = mergeSort(nums, temp, left, mid);</span><br><span class="line">        <span class="keyword">int</span> rightPairs = mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归并优化，此时数组已经是有序的了，所以直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> leftPairs + rightPairs;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> crossPairs = mergeAndCount(nums, temp, left, mid, right);</span><br><span class="line">        <span class="keyword">return</span> leftPairs + rightPairs + crossPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeAndCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k)  <span class="comment">// 将原数组拷贝到辅助空间</span></span><br><span class="line">            temp[k] = nums[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// i 指向左子数组的首个元素</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// j 指向右子数组的首个元素</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k)  <span class="comment">// 遍历原数组，并排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) <span class="comment">// 这里是小于等于，相等时应该先归并temp[i]，如果写严格小于，归并排序就不是稳定的排序了</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// temp[i] &gt; temp[j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                res += mid - i + <span class="number">1</span>; <span class="comment">//统计逆序对,此题的解法只在归并排序代码的基础上添加了此句。</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706141655270.png" alt="image-20210706141655270"></p>
<p><strong>简洁写法：</strong></p>
<ul>
<li><p>以下两种情况可以合为一处：</p>
<ul>
<li><code>else if</code> <code>j = right + 1</code>时：代表右子数组已经合并完，因此添加左子数组当前元素<code>temp[i]</code>，并<code>i++</code></li>
<li><code>else if</code> <code>temp[i] &lt;= temp[j]</code>时：添加左子数组当前元素 <code>temp[i]</code>，并<code>i++</code></li>
</ul>
</li>
<li><p><code>mergeSort</code> 和 <code>mergeAndCount</code> 可以写成一个函数</p>
</li>
<li><p>如果终止条件是 <code>if (left &gt;= right) return 0</code> ，写大于等于，可以省去 <code>reversePairs()</code>中的特判，即<code>if (nums.size() &lt; 2) return 0</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (nums.size() &lt; 2) return 0;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, temp, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//终止条件</span></span><br><span class="line">        <span class="comment">// 递归划分</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = mergeSort(nums, temp, left, mid) + mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 将原数组拷贝到辅助空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k)</span><br><span class="line">            temp[k] = nums[k];</span><br><span class="line">        <span class="comment">// 合并阶段</span></span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>)</span><br><span class="line">                nums[k] = temp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || temp[i] &lt;= temp[j])</span><br><span class="line">                nums[k] = temp[i++];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = temp[j++];</span><br><span class="line">                res += mid - i + <span class="number">1</span>; <span class="comment">// 统计逆序对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706144603333.png" alt="image-20210706144603333"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  52 - 两个链表的第一个公共节点</title>
    <url>/2021/07/06/SwordToOffer%20-%2052%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-52-两个链表的第一个公共节点"><a href="#《剑指Offer》-52-两个链表的第一个公共节点" class="headerlink" title="《剑指Offer》  52 - 两个链表的第一个公共节点"></a>《剑指Offer》  52 - 两个链表的第一个公共节点</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></p>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706155130032.png" alt="image-20210706155130032"></p>
<p>在节点 c1 开始相交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706155147175.png" alt="image-20210706155147175"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706155244687.png" alt="image-20210706155244687"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706155328472.png" alt="image-20210706155328472"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">如果两个链表没有交点，返回 null.</span><br><span class="line">在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">可假定整个链表结构中没有循环。</span><br><span class="line">程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br></pre></td></tr></table></figure>

<p><strong>此题与LeetCode160相同：</strong><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：双指针法-O-m-n-O-1"><a href="#方法一：双指针法-O-m-n-O-1" class="headerlink" title="方法一：双指针法 $O(m+n) - O(1)$"></a>方法一：双指针法 $O(m+n) - O(1)$</h4><ul>
<li>先逐个遍历两个链表，获得两个链表的长度，并求得两个链表长度的差值 <code>dis</code></li>
<li>令<code>pA</code>指针指向较长的那个链表，其长度为<code>lenA</code></li>
<li>从头重新遍历两个链表，先让 <code>pA</code> 在链表 <code>A</code>上走 <code>dis</code> 个节点。然后 <code>pA</code> 和 <code>pB</code>同时向前走，当两个指针指向同一个节点时，此节点即时两个链表的第一个公共节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA) &#123; lenA++; pA = pA-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span>(pB) &#123; lenB++; pB = pB-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="built_in">abs</span>(lenA - lenB);</span><br><span class="line">        pA = headA;</span><br><span class="line">        pB = headB;</span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(lenA, lenB);</span><br><span class="line">            swap(pA,pB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(dis--)</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pA)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pA == pB)</span><br><span class="line">                <span class="keyword">return</span> pA;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706200003207.png" alt="image-20210706200003207"></p>
<p><strong>神之一手，令人惊叹的解法：</strong></p>
<p>对于链表<code>A</code>，如果开始到公共节点的举例为 <code>a</code>，对于链表<code>B</code>，开始到公共节点的举例为 <code>b</code>，公共节点到结尾的距离均是 <code>c</code></p>
<ul>
<li>指针<code>pA</code>从<code>A</code>的头结点出发，遍历到尾结点后指向链表<code>B</code>的头节点，继续向前走，走到公共节点，共走了：</li>
</ul>
<p>$$(a+c)+b = a + b +c$$</p>
<ul>
<li>指针<code>pB</code>从<code>B</code>的头结点出发，遍历到尾结点后指向链表<code>A</code>的头节点，继续向前走，走到公共节点，共走了：</li>
</ul>
<p>$$(b+c)+a = a + b +c$$</p>
<p>此时指针 <code>pB</code>和<code>pA</code>指向相同的节点，即第一个公共节点。</p>
<p>若两链表 <strong>无</strong> 公共尾部 ：指针 <code>pA</code> , <code>pB</code> 同时指向 <code>nul</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B)</span><br><span class="line">        &#123;</span><br><span class="line">            A = (A != <span class="literal">nullptr</span> ? A-&gt;next : headB);</span><br><span class="line">            B = (B != <span class="literal">nullptr</span> ? B-&gt;next : headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706201502997.png" alt="image-20210706201502997" style="zoom: 80%;" />

<h4 id="方法二：辅助栈-O-m-n-O-m-n-（浪费空间-不推荐）"><a href="#方法二：辅助栈-O-m-n-O-m-n-（浪费空间-不推荐）" class="headerlink" title="方法二：辅助栈  $O(m + n) - O(m + n)$（浪费空间 不推荐）"></a>方法二：辅助栈  $O(m + n) - O(m + n)$（浪费空间 不推荐）</h4><ul>
<li>把两个链表放到两个栈中，然后依次出栈比较两个栈顶元素，当两个指针不同，则上个循环中的栈顶元素为公共节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; A;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; B;</span><br><span class="line">        ListNode *p1 = headA, *p2 = headB, *p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1)</span><br><span class="line">        &#123;</span><br><span class="line">            A.push(p1);</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2)</span><br><span class="line">        &#123;</span><br><span class="line">            B.push(p2);</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!A.empty()&amp;&amp;!B.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = A.top();</span><br><span class="line">            p2 = B.top();</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">                p = p1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">            A.pop();</span><br><span class="line">            B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210706172150804.png" alt="image-20210706172150804"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  54 - 二叉搜索数的第k大节点</title>
    <url>/2021/07/07/SwordToOffer%20-%2054%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-54-二叉搜索数的第k大节点"><a href="#《剑指Offer》-54-二叉搜索数的第k大节点" class="headerlink" title="《剑指Offer》  54 - 二叉搜索数的第k大节点"></a>《剑指Offer》  54 - 二叉搜索数的第k大节点</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></p>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：使用中序遍历的倒数，空间复杂度为-O-1-，最优解"><a href="#方法一：使用中序遍历的倒数，空间复杂度为-O-1-，最优解" class="headerlink" title="方法一：使用中序遍历的倒数，空间复杂度为 $O(1)$，最优解"></a>方法一：使用中序遍历的倒数，空间复杂度为 $O(1)$，最优解</h4><ul>
<li><strong>中序遍历的倒数</strong> 顺序为  <strong>右、根、左</strong></li>
<li>递归遍历时计数，统计当前节点序号，递归到第<code>k</code>个节点的时候，返回</li>
</ul>
<p><strong>递归写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        reverseInOrder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res, k;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseInOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        reverseInOrder(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) </span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        reverseInOrder(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707100655246.png" alt="image-20210707100655246"></p>
<p><strong>非递归写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(root || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (root)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">                root = root-&gt;left; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707105228201.png" alt="image-20210707105228201"></p>
<h4 id="方法二：先遍历，放入数组，再取第k大元素，浪费空间，不推荐"><a href="#方法二：先遍历，放入数组，再取第k大元素，浪费空间，不推荐" class="headerlink" title="方法二：先遍历，放入数组，再取第k大元素，浪费空间，不推荐"></a>方法二：先遍历，放入数组，再取第k大元素，浪费空间，不推荐</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> v[v.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) inOrder(root-&gt;left);</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707095427332.png" alt="image-20210707095427332"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  58 - 翻转单词顺序  左旋转字符串</title>
    <url>/2021/07/11/SwordToOffer%20-%2058%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%20%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-58-翻转单词顺序-左旋转字符串"><a href="#《剑指Offer》-58-翻转单词顺序-左旋转字符串" class="headerlink" title="《剑指Offer》  58 - 翻转单词顺序  左旋转字符串"></a>《剑指Offer》  58 - 翻转单词顺序  左旋转字符串</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - I. 翻转单词顺序</a></p>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串<code>&quot;I am a student. &quot;</code>，则输出<code>&quot;student. a am I&quot;</code>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">无空格字符构成一个单词。</span><br><span class="line">输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p><strong>此题与LeetCode151相同：</strong><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>掌握去首位空格的方法！！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">	s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">	s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法一：双指针倒序遍历，记录单词左右边界"><a href="#方法一：双指针倒序遍历，记录单词左右边界" class="headerlink" title="方法一：双指针倒序遍历，记录单词左右边界"></a>方法一：双指针倒序遍历，记录单词左右边界</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">            s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n, j = n;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">' '</span>) i--;</span><br><span class="line">            res.append(s.substr(i + <span class="number">1</span>, j - i));</span><br><span class="line">            res.append(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">' '</span>) i--;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res.erase(res.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711121931678.png" alt="image-20210711121931678"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - II. 左旋转字符串</a></p>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串<code>&quot;abcdefg&quot;</code>和数字2，该函数将返回左旋转两位得到的结果<code>&quot;cdefgab&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：切片"><a href="#方法一：切片" class="headerlink" title="方法一：切片"></a>方法一：切片</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s.substr(n)).append(s.substr(<span class="number">0</span>,n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711122148749.png" alt="image-20210711122148749"></p>
<h4 id="方法二：三次翻转法-内存更低！"><a href="#方法二：三次翻转法-内存更低！" class="headerlink" title="方法二：三次翻转法 内存更低！"></a>方法二：三次翻转法 内存更低！</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse_string</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= (start + end) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[i];</span><br><span class="line">            s[i] = s[start+end-i];</span><br><span class="line">            s[start+end-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        reverse_string(s, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">        reverse_string(s, <span class="number">0</span>, length-n<span class="number">-1</span>);</span><br><span class="line">        reverse_string(s, length-n, length<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711123245246.png" alt="image-20210711123245246"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  55 - 二叉树的深度 &amp; 平衡二叉树</title>
    <url>/2021/07/07/SwordToOffer%20-%2055%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%20&amp;%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-55-二叉树的深度-amp-平衡二叉树"><a href="#《剑指Offer》-55-二叉树的深度-amp-平衡二叉树" class="headerlink" title="《剑指Offer》  55 - 二叉树的深度 &amp; 平衡二叉树"></a>《剑指Offer》  55 - 二叉树的深度 &amp; 平衡二叉树</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></p>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：给定二叉树 <code>[3,9,20,null,null,15,7]</code>，返回它的最大深度<code>3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">提示：</span><br><span class="line">节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode104相同：</strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：层序遍历（BFS）-巧用-for-循环"><a href="#方法一：层序遍历（BFS）-巧用-for-循环" class="headerlink" title="方法一：层序遍历（BFS） + 巧用 for 循环"></a>方法一：层序遍历（BFS） + 巧用 for 循环</h4><p>此题又用到了<code>剑指Offer32</code>中的思路：巧用 <code>for</code> 循环， 循环次数为当前层节点数（即队列 <code>queue</code> 长度），一次<code>for</code>循环遍历完一层，深度 <code>+1</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707112453775.png" alt="image-20210707112453775"></p>
<h4 id="方法二：后序遍历（DFS）"><a href="#方法二：后序遍历（DFS）" class="headerlink" title="方法二：后序遍历（DFS）"></a>方法二：后序遍历（DFS）</h4><p><strong>树的深度</strong>  等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong>  <code>+1</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_depth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right_depth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>写在一起：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707113103841.png" alt="image-20210707113103841"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></p>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7] 返回 true </span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]  返回 false </span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode110相同：</strong><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：后序遍历-剪枝-自底向上-O-N-O-N"><a href="#方法一：后序遍历-剪枝-自底向上-O-N-O-N" class="headerlink" title="方法一：后序遍历 + 剪枝  自底向上  $O(N) - O(N)$"></a>方法一：后序遍历 + 剪枝  自底向上  $O(N) - O(N)$</h4><p>后序遍历<strong>自底向上</strong>返回子树深度，若不是平衡树则剪枝，直接向上返回。</p>
<p>当某节点左、右子树的高度差小于 <code>2</code>，则返回当前子树的深度 <code>max(left, right) + 1</code>，否则返回 <code>-1</code>，即此子树不是平衡树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = recur(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = recur(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707150557727.png" alt="image-20210707150557727"></p>
<h4 id="方法二：先序遍历-判断深度-（自顶向下）-O-N-log-N-O-N"><a href="#方法二：先序遍历-判断深度-（自顶向下）-O-N-log-N-O-N" class="headerlink" title="方法二：先序遍历 + 判断深度 （自顶向下）  $O(N\log{N}) - O(N)$"></a>方法二：先序遍历 + 判断深度 （自顶向下）  $O(N\log{N}) - O(N)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210707145500452.png" alt="image-20210707145500452"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  56 - 数组中数字出现的次数</title>
    <url>/2021/07/11/SwordToOffer%20-%2056%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-56-数组中数字出现的次数"><a href="#《剑指Offer》-56-数组中数字出现的次数" class="headerlink" title="《剑指Offer》  56 - 数组中数字出现的次数"></a>《剑指Offer》  56 - 数组中数字出现的次数</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数</a></p>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p><strong>知识点：</strong></p>
<ul>
<li><strong>异或运算：</strong>两个相同数字异或为<code>0</code>，且<strong>满足交换律</strong>，即将下方数列执行异或运算，留下的结果则为出现一次的数字<code>x</code><ul>
<li><code>a ^ b ^ b ^ c ^ x ^ a ^ c = a ^ a ^ b ^ b ^ c ^ c ^ x = x</code></li>
</ul>
</li>
</ul>
<p><strong>解题思路：</strong></p>
<ul>
<li>由异或运算的性质可知，对<code>nums</code>中所有数字执行异或运算，得到的结果是两个只存在一次的数字<code>x1</code>和<code>x2</code>的异或结果，即<code>x1 ^ x2</code>，令<code>n = x1 ^ x2</code>，若<code>n</code>的某二进制位是<code>1</code>，则<code>x1和x2</code>在此二进制位一定不同，基于此位将<code>nums</code>数组分成两部分，<code>x1</code>和<code>x2</code>分别在这两个子数组是唯一的，分别进行异或运算，即可将<code>x1</code>和<code>x2</code>分离。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, n = <span class="number">0</span>, m = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            n ^= num;   <span class="comment">// n = x1 ^ x2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((n &amp; m) == <span class="number">0</span>)</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;    <span class="comment">// 找到n的二进制中从右往左数第一个为1的二进制位</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; m) x1 ^= num;</span><br><span class="line">            <span class="keyword">else</span> x2 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x1, x2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711102639223.png" alt="image-20210711102639223"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></p>
<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure>



<h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><ul>
<li>建立一个长度为<code>32</code>的数组<code>counts</code>，遍历<code>nums</code>，将<code>nums</code>中各个数字的各个二进制位相加并统计在<code>counts</code>数组中，然后对<code>counts</code>数组中的各元素对 <code>3</code>取余，结果即为只出现一次的数字的二进制形式，将其恢复到数字<code>res</code>中即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j != <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res &lt;&lt; <span class="number">1</span>; <span class="comment">// 左移 1 位</span></span><br><span class="line">            res = res | counts[i] % m; <span class="comment">// 恢复第 i 位的值到 res，对应的每个二进制位做或运算，只有双方都为0时才为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后左移，最后一轮的 最后一个操作变成了左移，那么最右一位 永远是 0</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711113806665.png" alt="image-20210711113806665"></p>
<ul>
<li>两个循环合在一起</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, sub = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i, sub = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> &amp;n : nums) sub += ((n &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sub % <span class="number">3</span>) res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711114024389.png" alt="image-20210711114024389"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  57 - 和为s的 两个数字 or 连续正数序列</title>
    <url>/2021/08/11/SwordToOffer%20-%2057%20%E5%92%8C%E4%B8%BAs%E7%9A%84%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%20or%20%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-57-和为s的-两个数字-or-连续正数序列"><a href="#《剑指Offer》-57-和为s的-两个数字-or-连续正数序列" class="headerlink" title="《剑指Offer》  57 - 和为s的 两个数字 or 连续正数序列"></a>《剑指Offer》  57 - 和为s的 两个数字 or 连续正数序列</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a></p>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="双指针夹逼"><a href="#双指针夹逼" class="headerlink" title="双指针夹逼"></a>双指针夹逼</h4><ul>
<li>两个指针指向数组头尾，如果这两个数大于目标值，则需要让两数之和变小，右指针左移；同理，如果两个数小于目标值，则需要让两树之和变大，左指针右移。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] == target) </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;nums[left], nums[right]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &gt; target)</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">else</span> ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711115803144.png" alt="image-20210711115803144"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>



<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><h4 id="双指针滑动窗口"><a href="#双指针滑动窗口" class="headerlink" title="双指针滑动窗口"></a>双指针滑动窗口</h4><ul>
<li>由于是连续正数序列，所以一个窗口的数字之和可以用一个公式直接得出，<code>sum = (left + right) * (right - left + 1) / 2</code><ul>
<li><code>sum &gt; target</code>，需要让<code>sum</code>变小，<code>left</code>右移</li>
<li><code>sum &lt; target</code>，需要让<code>sum</code>变大，<code>right</code>右移</li>
<li><code>sum == target</code>，得到一个连续正数数列，放入<code>res</code>中</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;       </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>; left &lt; right;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">int</span> sum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                    tmp.push_back(i);</span><br><span class="line">                res.push_back(tmp);   </span><br><span class="line">                left++;             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) right++;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711120638733.png" alt="image-20210711120638733"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  59 - 滑动窗口的最大值  队列的最大值</title>
    <url>/2021/07/11/SwordToOffer%20-%2059%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%20%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-59-滑动窗口的最大值-队列的最大值"><a href="#《剑指Offer》-59-滑动窗口的最大值-队列的最大值" class="headerlink" title="《剑指Offer》  59 - 滑动窗口的最大值  队列的最大值"></a>《剑指Offer》  59 - 滑动窗口的最大值  队列的最大值</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></p>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode239相同：</strong><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></p>
<h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><h4 id="单调双端队列-维护队列要瞻前顾后"><a href="#单调双端队列-维护队列要瞻前顾后" class="headerlink" title="单调双端队列 - 维护队列要瞻前顾后"></a>单调双端队列 - 维护队列要瞻前顾后</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顾后</span></span><br><span class="line">            <span class="comment">// 从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[i] &gt;= nums[deq.back()])</span><br><span class="line">                deq.pop_back();</span><br><span class="line">            </span><br><span class="line">            deq.push_back(i);  <span class="comment">//把每次滑动的num下标加入队列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 瞻前 </span></span><br><span class="line">            <span class="comment">// 当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (deq.front() &lt; i - k + <span class="number">1</span>)</span><br><span class="line">                deq.pop_front();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当滑动窗口的左边大于等于0时才开始写入窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                res.push_back(nums[deq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711134900704.png" alt="image-20210711134900704"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></p>
<p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code>的均摊时间复杂度都是$O(1)$</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 <code>-1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; push_back,pop_front,max_value 的总操作数 &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; value &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>



<h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p><strong>单调队列</strong></p>
<p>与上题同理，可以说是上一题的简化版，维护双端递减队列要<strong>瞻前顾后</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; data_que;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max_deq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!max_deq.empty())</span><br><span class="line">            <span class="keyword">return</span> max_deq.front();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!max_deq.empty() &amp;&amp; value &gt; max_deq.back())</span><br><span class="line">            max_deq.pop_back(); <span class="comment">// 顾后</span></span><br><span class="line">        max_deq.push_back(value);</span><br><span class="line">        data_que.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data_que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = data_que.front();</span><br><span class="line">            <span class="keyword">if</span> (ans == max_deq.front())</span><br><span class="line">                max_deq.pop_front(); <span class="comment">// 瞻前顾</span></span><br><span class="line">            data_que.pop();</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711170306662.png" alt="image-20210711170306662"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  60 - n个骰子的点数</title>
    <url>/2021/07/11/SwordToOffer%20-%2060%20n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-60-n个骰子的点数"><a href="#《剑指Offer》-60-n个骰子的点数" class="headerlink" title="《剑指Offer》  60 - n个骰子的点数"></a>《剑指Offer》  60 - n个骰子的点数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数</a></p>
<p>把<code>n</code>个骰子扔在地上，所有骰子朝上一面的点数之和为<code>s</code>。输入<code>n</code>，打印出<code>s</code>的所有可能的值出现的概率。需要用一个浮点数数组返回答案，其中第 <code>i</code>个元素代表这<code>n</code> 个骰子所能掷出的点数集合中第 <code>i</code>小的那个的概率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 11</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>循序渐进，逐步优化</strong></p>
<p>这是一到典型的动态规划题目，用<code>dp[n][j]</code>来表示投完第<code>n</code>个骰子后点数 <code>j</code> 出现的次数，第n个骰子的点数可能是<code>1,2,3,4,5,6</code>。因此投完<code>n</code>个骰子后点数 <code>j</code> 出现的次数，可以由投完 <code>n-1</code> 个骰子后，对应点数<code>j-1，j-2，j-3，j-4，j-5，j-6</code>出现的次数之和转化过来。</p>
<p>$$dp[n][j] = \sum_{i=1}^{6} dp[n-1][j-1]$$</p>
<ul>
<li>比如当 <code>n=2</code> 时，<code>j</code> 的取值范围是 <code>2 ~ 12</code>，共有<code>2 * n + 1</code>个取值，拿<code>dp[2][4]</code>举例，它等于 <code>dp[1][1]+dp[1][2],dp[1,3]</code>，<code>dp[1][1]</code>与<code>第n次投</code>出来的<code>点数3</code>得出一次，<code>dp[1][2]</code>  与<code>第n次</code>投出来的点数2得出一次，<code>dp[1][3]</code>与<code>第n次</code>投出来的<code>点数1</code>得出一次，所以<code>dp[2][4]=3</code>，可以发现这里会存在一个界限问题，对应代码中的<code>if (j - k &lt;= 0) break;</code>，<code>dp[1][1]+dp[1][2],dp[1,3]</code>中的第二维索引记为k，取值为<code>[1,6]</code> ，<code>dp[2][4]</code>中的<code>4</code>（即<code>j</code>) 与<code>k</code>的关系是，<code>j-k &gt; 0</code></li>
</ul>
<h4 id="写法一：二维动态规划，更好理解-，逆向递归"><a href="#写法一：二维动态规划，更好理解-，逆向递归" class="headerlink" title="写法一：二维动态规划，更好理解 ，逆向递归"></a>写法一：二维动态规划，更好理解 ，逆向递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; (<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i)</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">6</span> * i; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span> *n; i++)</span><br><span class="line">            res.push_back(dp[n][i] * <span class="number">1.0</span> / all);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="写法二：空间优化，二维转一维"><a href="#写法二：空间优化，二维转一维" class="headerlink" title="写法二：空间优化，二维转一维"></a>写法二：空间优化，二维转一维</h4><p>每个阶段的状态都只和它前一阶段的状态有关，因此不需要用额外的一维来保存所有阶段。用一维数组来保存一个阶段的状态，然后对下一个阶段可能出现的<code>点数 j</code> 从大到小遍历，实现一个阶段到下一阶段的转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i)</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">6</span> * i; j &gt;= i; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从后往前逐个累加，在加到当前点数时，必须把原先存放的n-1个骰子的数据置0，否则累加出错</span></span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果不加此判据，会取到n-2个骰子的数据，此时可认为是“脏数据”，会导致累加出错。从实际情况来分析，n-1个骰子的最小值就是n-1，不会比这再小，因此此处的判据是 i-1，而不是0；</span></span><br><span class="line">                    <span class="keyword">if</span> (j - k &lt; i - <span class="number">1</span>) <span class="keyword">break</span>;  </span><br><span class="line">                    <span class="comment">// 投完n个骰子后点数 j 出现的次数可以由投完n-1个骰子后，对应点数 j-1,j-2,...j-6出现的次数转化过来</span></span><br><span class="line">                    dp[j] += dp[j - k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span>*n; ++i)</span><br><span class="line">            res.push_back(dp[i] * <span class="number">1.0</span> / all);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="方法三：正向递归"><a href="#方法三：正向递归" class="headerlink" title="方法三：正向递归"></a>方法三：正向递归</h4><ul>
<li>设输入<code>n</code>个骰子的解（即概率列表）为 $f(n)$ ，其中点数和为<code>x</code> 的概率为$f(n,x)$ 。</li>
</ul>
<p>$$f(n,x) = \sum_{i=1}^6f(n-1,x-i)\times\frac{1}{6}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="comment">//从i-1个骰子的点数之和的值数组入手，计算i个骰子的点数之和数组的值</span></span><br><span class="line">            <span class="comment">//先拿i-1个骰子的点数之和数组的第j个值，它所影响的是i个骰子时的temp[j+k]的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.size(); ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">                <span class="comment">//这里记得是加上dp数组值与1/6的乘积，1/6是第i个骰子投出某个值的概率</span></span><br><span class="line">                    temp[j + k] += dp[j] * (<span class="number">1.0</span> / <span class="number">6.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i个骰子的点数之和全都算出来后，要将temp数组移交给dp数组，dp数组就会代表i个骰子时的可能出现的点数之和的概率；用于计算i+1个骰子时的点数之和的概率</span></span><br><span class="line">            dp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210709091302439.png" alt="image-20210709091302439"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  61 - 扑克牌中的顺子</title>
    <url>/2021/07/11/SwordToOffer%20-%2061%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-61-扑克牌中的顺子"><a href="#《剑指Offer》-61-扑克牌中的顺子" class="headerlink" title="《剑指Offer》  61 - 扑克牌中的顺子"></a>《剑指Offer》  61 - 扑克牌中的顺子</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></p>
<p>从扑克牌中随机抽 5张牌，判断是不是一个顺子，即这 5张牌是不是连续的。<code>2～10</code>为数字本身，<code>A为1</code>，<code>J为11</code>，<code>Q为12</code>，<code>K为13</code>，而大、小王为<code>0</code> ，可以看成任意数字。<code>A</code> 不能视为 <code>14</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">数组长度为 5 </span><br><span class="line">数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="方法一：-自己AC的写法"><a href="#方法一：-自己AC的写法" class="headerlink" title="方法一： 自己AC的写法"></a>方法一： 自己AC的写法</h4><p><strong>用个hash表，除了0计数，其他有就赋值1，遍历这个哈希表，如果连续五个数的和加上hash[0] == 5就找到了</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) hash[num]++;</span><br><span class="line">            <span class="keyword">else</span> hash[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hash.size() - <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                cnt += hash[i + j];</span><br><span class="line">            <span class="keyword">if</span> (cnt + hash[<span class="number">0</span>] == <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711180104703.png" alt="image-20210711180104703"></p>
<h4 id="方法二：-max-min-lt-5"><a href="#方法二：-max-min-lt-5" class="headerlink" title="方法二：$max - min &lt; 5$"></a>方法二：$max - min &lt; 5$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) joker++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711180834974.png" alt="image-20210711180834974"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  62 - 圆圈中最后剩下的数字（约瑟夫环问题）</title>
    <url>/2021/07/12/SwordToOffer%20-%2062%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-62-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#《剑指Offer》-62-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="《剑指Offer》  62 - 圆圈中最后剩下的数字（约瑟夫环问题）"></a>《剑指Offer》  62 - 圆圈中最后剩下的数字（约瑟夫环问题）</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 62. 圆圈中最后剩下的数字</a></p>
<p><code>0,1,···,n-1</code>这<code>n</code>个数字排成一个圆圈，从数字<code>0</code>开始，每次从这个圆圈里删除<code>第m个</code>数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，<code>0、1、2、3、4</code>这<code>5</code>个数字组成一个圆圈，从<code>数字0</code>开始每次删除<code>第3个数字</code>，则删除的前<code>4</code>个数字依次是<code>2、0、4、1</code>，因此最后剩下的数字是<code>3</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; m &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>





<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>定义函数$f(n,m)$表示在<code>n</code>个数字中不断删除<code>第m个数字</code>最后剩下的数字，在<code>0 ~ n - 1</code> 这<code>n</code> 个数字中，第一个被删除的数字是 $(m-1)% n $ ，记为 k，可得以下两个数列<ul>
<li>$f(n-1,m):0, 1,…k-1,k+1,…,n-1$</li>
<li>$f’(n-1,m): k+1,k+2…,n-1,0,1,…k-1$</li>
</ul>
</li>
<li>我们需要的是$f’(n-1,m)$，但是手里有 $f(n-1,m)$，所以要找到 $f(n-1,m)$ 到$f’(n-1,m)$ 的映射关系 $F$，令$f(n-1,m) = x$ ， $f’(n-1,m) = y$，则：$y = F(x) = (x+k+1)%n$</li>
</ul>
<p>从而有 $$f’(n-1,m) = F(x)=F(f(n-1,m)) = (f(n-1,m)+k+1)%n=(f(n-1,m)+(m-1)%n+1)%n=(f(n-1,m)+m)%n$$</p>
<p>当$n=1$时，数组中只有一个数字<code>0</code>，因此有 $f(1,m) = 0$，由此可得递推公式：</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711203632541.png" alt="image-20210711203632541"></p>
<h4 id="递归写法："><a href="#递归写法：" class="headerlink" title="递归写法："></a>递归写法：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711204919244.png" alt="image-20210711204919244"></p>
<h4 id="非递归写法："><a href="#非递归写法：" class="headerlink" title="非递归写法："></a>非递归写法：</h4><p>$f(n)$可由$f(n-1)$得到，$f(n-1)$  可由  $f(n-2)$得到，….，$f(2)$ 可由 $f(1)$得到，因此，给定 $f(1)$ 的值，就可以递推至任意 $f(n)$，$f(1)=0$</p>
<p>动态转移方程为：$$dp[i] = (dp[i-1]+m)%i$$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            x = (x + m) % i;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210711210811529.png" alt="image-20210711210811529"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  63 - 股票的最大利润</title>
    <url>/2021/07/12/SwordToOffer%20-%2063%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-63-股票的最大利润"><a href="#《剑指Offer》-63-股票的最大利润" class="headerlink" title="《剑指Offer》  63 - 股票的最大利润"></a>《剑指Offer》  63 - 股票的最大利润</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line"><span class="number">0</span> &lt;= 数组长度 &lt;= <span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode121相同：</strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>用一个变量记录前<code>i</code>日的最低价格<code>min_cost</code>，用dp<code>[i]</code>表示第<code>i</code>日最大利润：</p>
<p>$$dp[i] = max(dp[i-1],prices[i]-min(min_cost,prices[i]))$$</p>
<p>由于$dp[i]$只与$dp[i-1],prices[i],min_cost$相关，因此可使用一个变量$profit$代替$dp$列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_cost = INT_MAX, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">            profit = max(profit, price -min_cost);</span><br><span class="line">            min_cost = min(price, min_cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712095202454.png" alt="image-20210712095202454"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  64 - 求1+2+…+n</title>
    <url>/2021/07/12/SwordToOffer%20-%2064%20%E6%B1%821+2+%E2%80%A6+n/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-64-求1-2-…-n"><a href="#《剑指Offer》-64-求1-2-…-n" class="headerlink" title="《剑指Offer》  64 - 求1+2+…+n"></a>《剑指Offer》  64 - 求1+2+…+n</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></p>
<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、<code>for</code>、<code>while</code>、<code>if</code>、<code>else</code>、<code>switch</code>、<code>case</code>等关键字及条件判断语句 <code>A?B:C）</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="使用逻辑运算符的短路效应终止递归"><a href="#使用逻辑运算符的短路效应终止递归" class="headerlink" title="使用逻辑运算符的短路效应终止递归"></a>使用逻辑运算符的短路效应终止递归</h4><p>短路效应：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A &amp;&amp; B)  <span class="comment">// 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A || B) <span class="comment">// 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> x = n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n<span class="number">-1</span>)) &gt; <span class="number">0</span>; <span class="comment">// 当 n = 时，n &gt; 1 不成立，发生短路，终止后续递归</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712104401021.png" alt="image-20210712104401021"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  68 - 最近公共祖先问题</title>
    <url>/2021/09/01/SwordToOffer%20-%2068%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-68-最近公共祖先问题"><a href="#《剑指Offer》-68-最近公共祖先问题" class="headerlink" title="《剑指Offer》  68 - 最近公共祖先问题"></a>《剑指Offer》  68 - 最近公共祖先问题</h1><p><strong>题目1：</strong><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树: <code>root = [6,2,8,0,4,7,9,null,null,3,5]</code></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712163010501.png" alt="image-20210712163010501"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode235相同：</strong><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></p>
<h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>由于是二叉搜索数，如果两个节点都小于根节点，则最近公共祖先在树左，如果两个节点都大于根节点，则最近公共祖先在树右，如果根节点在两个树之间，则最近公共祖先是根节点。</p>
<h4 id="非递归写法：空间-O-1"><a href="#非递归写法：空间-O-1" class="headerlink" title="非递归写法：空间$O(1)$"></a>非递归写法：空间$O(1)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712164733118.png" alt="image-20210712164733118"></p>
<h4 id="递归写法：空间-O-n"><a href="#递归写法：空间-O-n" class="headerlink" title="递归写法：空间$O(n)$"></a>递归写法：空间$O(n)$</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712165633142.png" alt="image-20210712165633142"></p>
<p><strong>题目2：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树<code>T</code>的两个结点<code>p</code>、<code>q</code>，最近公共祖先表示为一个结点<code>x</code>，满足<code>x</code>是 <code>p</code>、<code>q</code> 的祖先且<code>x</code> 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  <code>root = [3,5,1,6,2,0,8,null,null,7,4]</code></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712163010501.png" alt="image-20210712163010501"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、q 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode236相同：</strong><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p>
<h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p><strong>终止条件：</strong></p>
<ul>
<li>当越过叶节点，返回空</li>
<li>当<code>root</code>等于 <code>p</code>，<code>q</code>，返回<code>root</code></li>
</ul>
<p><strong>递推工作：</strong></p>
<ul>
<li>递归左子节点，返回值为<code>left</code></li>
<li>递归右子节点，返回值为<code>right</code></li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>当 <code>left</code> 和 <code>right</code> 同时为空，则左右子树都不含 <code>p</code>、<code>q</code> ，返回 <code>null</code></li>
<li>当 <code>left</code> 和 <code>right</code> 同时不为空，说明p、q在root两侧，返回root</li>
<li>当 <code>left</code>为空，<code>right</code> 不为空，<code>p</code>、<code>q</code> 都在右子树，返回 <code>right</code></li>
<li>当 <code>right</code>为空，<code>left</code> 不为空，<code>p</code>、<code>q</code> 都在左子树，返回 <code>left</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712174953869.png" alt="image-20210712174953869"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16 ROS-Kinetic 环境配置</title>
    <url>/2020/11/05/Ubuntu16-ROS-Kinetic-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Ubuntu16-04-ROS-Kinetic-安装"><a href="#Ubuntu16-04-ROS-Kinetic-安装" class="headerlink" title="Ubuntu16.04  ROS-Kinetic 安装"></a>Ubuntu16.04  ROS-Kinetic 安装</h1><ul>
<li>1.软件更新选项</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105183242435.png" alt="image-20201105183242435"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105183317168.png" alt="image-20201105183317168"></p>
<p>选完之后<code>sudo apt-get update</code></p>
<ul>
<li>2.添加ROS软件源</li>
</ul>
<p><code>sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></p>
<ul>
<li>3.添加密钥</li>
</ul>
<p><code>sudo apt-key adv --keyserver &#39;hkp://keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</code></p>
<ul>
<li>4.更新源并安装ROS</li>
</ul>
<p><code>sudo apt-get update</code></p>
<p><code>sudo apt-get install ros-kinetic-desktop-full</code></p>
<ul>
<li>5.初始化rosdep</li>
</ul>
<p><code>sudo rosdep init</code></p>
<p><code>rosdep update</code></p>
<p>如果出现</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105183737749.png" alt="image-20201105183737749"></p>
<p>在网站 <a href="https://site.ip138.com/raw.githubusercontent.com/" target="_blank" rel="noopener">https://site.ip138.com/raw.githubusercontent.com/</a> 中搜索raw.githubusercontent.com域名，这里我选的香港的，毕竟国内毕竟近</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105192531614.png" alt="image-20201105192531614" style="zoom: 67%;" />

<p>然后终端输入</p>
<p><code>sudo gedit /etc/hosts</code></p>
<p>在最后一行加入151.101.76.133 raw.githubusercontent.com</p>
<p>再次<code>sudo rosdep init</code>成功</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105192735616.png" alt="image-20201105192735616"></p>
<p>之后输入命令</p>
<p><code>rosdep update</code></p>
<ul>
<li>6.设置环境变量</li>
</ul>
<p><code>echo &quot;source /opt/ros/kinetic/setup.bash&quot;&gt;&gt;~/.bashrc</code></p>
<p><code>source ~/.bashrc</code></p>
<ul>
<li>7.安装rosinstall</li>
</ul>
<p><code>sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></p>
<p>安装不成功就多运行几次命令，慢慢磨过去，实在磨不过去就连手机热点就好了</p>
<ul>
<li>8.输入roscore验证安装是否成功</li>
</ul>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105193349411.png" alt="image-20201105193349411"></p>
<ul>
<li>9.配置gazebo</li>
</ul>
<p>将模型文件下好，解压到~./gazebo/models中。终端输入gazebo启动，如果出现下面错误</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20201105202809580.png" alt="image-20201105202809580"></p>
<p>输入以下命令即可解决</p>
<p><code>echo &quot;export SVGA_VGPU10=0&quot; &gt;&gt; ~/.bashrc</code></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04 Cuda10.1 Cudnn8.0 Anaconda4.8 PyCharm2020环境配置</title>
    <url>/2021/05/27/Ubuntu18.04%20Cuda10.1%20Cudnn8.0%20Anaconda4.8%20PyCharm2020%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Ubuntu-Pytorch-环境配置"><a href="#Ubuntu-Pytorch-环境配置" class="headerlink" title="Ubuntu Pytorch 环境配置"></a>Ubuntu Pytorch 环境配置</h1><h2 id="1-显卡驱动安装"><a href="#1-显卡驱动安装" class="headerlink" title="1 - 显卡驱动安装"></a>1 - 显卡驱动安装</h2><p><code>nvidia-smi</code> 查看显卡驱动是否安装</p>
<p>RTX TITAN 驱动：<a href="https://www.nvidia.cn/geforce/drivers/" target="_blank" rel="noopener">https://www.nvidia.cn/geforce/drivers/</a></p>
<p>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd 到驱动路径</span><br><span class="line">bash  NVIDIA-Linux-x86_64-450.66.run</span><br></pre></td></tr></table></figure>



<h2 id="2-Cuda-amp-Cudann-安装"><a href="#2-Cuda-amp-Cudann-安装" class="headerlink" title="2 - Cuda  &amp; Cudann 安装"></a>2 - Cuda  &amp; Cudann 安装</h2><h3 id="2-1-安装cuda10-1"><a href="#2-1-安装cuda10-1" class="headerlink" title="2.1 - 安装cuda10.1"></a>2.1 - 安装cuda10.1</h3><p>cuda 10.1 <a href="https://developer.nvidia.com/cuda-10.1-download-archive-base?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=runfilelocal" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-10.1-download-archive-base?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=runfilelocal</a></p>
<p>安装指令：</p>
<p>在文件目录终端输入</p>
<p><code>sudo sh cuda_10.1.105_418.39_linux.run</code></p>
<p>如果之前安装了驱动，将driver选项取消</p>
<h3 id="2-2-配置环境变量"><a href="#2-2-配置环境变量" class="headerlink" title="2.2 - 配置环境变量"></a>2.2 - 配置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">i 进入编辑模式</span><br><span class="line"># 文件末尾添加</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&quot;&#x2F;usr&#x2F;lcoal&#x2F;cuda-10.1&#x2F;lib64:$LD_LIBRARY_PATH&quot;</span><br><span class="line">Esc :wq</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>

<p>验证是否配置成功, 如果出现Result = PASS则表示安装成功通过!!</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/cuda-10.1/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure>

<h3 id="2-3-安装Cudnn"><a href="#2-3-安装Cudnn" class="headerlink" title="2.3 - 安装Cudnn"></a>2.3 - 安装Cudnn</h3><p><a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-download</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf cudnn-10.1-linux-x64-v8.0.3.33.tgz</span><br><span class="line"></span><br><span class="line">sudo cp cuda/include/cudnn.h /usr/local/cuda-10.1/include</span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/local/cuda-10.1/lib64</span><br><span class="line">sudo chmod a+r /usr/local/cuda-10.1/include/cudnn.h /usr/local/cuda-10.1/lib64/libcudnn*</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.1/lib</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-10.1/bin</span><br></pre></td></tr></table></figure>



<h2 id="3-Anaconda-miniconda-安装"><a href="#3-Anaconda-miniconda-安装" class="headerlink" title="3 - Anaconda (miniconda) 安装"></a>3 - Anaconda (miniconda) 安装</h2><p>官方文档 <a href="https://conda.io/projects/conda/en/latest/" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=S&amp;O=A" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=S&amp;O=A</a></p>
<p><code>sh Miniconda3-py37_4.8.2-Linux-x86_64.sh</code></p>
<p>写入环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit ~&#x2F;.bashrc</span><br><span class="line">export PATH&#x3D;~&#x2F;miniconda3&#x2F;bin:$PATH</span><br><span class="line">source ~&#x2F;.bashrc</span><br><span class="line">conda</span><br></pre></td></tr></table></figure>

<ul>
<li><code>conda list</code>  包列表</li>
<li><code>conda env list</code> 虚拟环境列表</li>
</ul>
<h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>一键使用TUNA源脚本 （ oh-my-tuna）</p>
<p><a href="https://github.com/tuna/oh-my-tuna" target="_blank" rel="noopener">https://github.com/tuna/oh-my-tuna</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;tuna.moe&#x2F;oh-my-tuna&#x2F;oh-my-tuna.py</span><br><span class="line">sudo python3 oh-my-tuna.py --global   # 全局</span><br><span class="line">python3 oh-my-tuna.py</span><br></pre></td></tr></table></figure>

<h2 id="4-安装Pycharm"><a href="#4-安装Pycharm" class="headerlink" title="4 - 安装Pycharm"></a>4 - 安装Pycharm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf pycharm-professional-2020.2.1.tar.gz</span><br><span class="line">cd pycharm-2020.2.1/bin/</span><br><span class="line">sh ./pycharm.sh</span><br></pre></td></tr></table></figure>

<p>在输入激活码的界面退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc</span><br><span class="line">sudo chmod 777 hosts</span><br><span class="line">sudo gedit hosts</span><br><span class="line"># 最后一行添加</span><br><span class="line">0.0.0.0 account.jetbrains.com</span><br></pre></td></tr></table></figure>

<p>重新启动pycharm-2020.2.1/bin/ 终端下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh .&#x2F;pycharm.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入激活码 网上搜索</span><br></pre></td></tr></table></figure>

<p>创建启动图标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /usr/share/applications/pycharm.desktop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]Type&#x3D;ApplicationName&#x3D;PycharmGenericName&#x3D;Pycharm3Comment&#x3D;Pycharm3:The Python IDEExec&#x3D;sh &#x2F;home&#x2F;zhuozhu&#x2F;桌面&#x2F;软件&#x2F;深度学习&#x2F;pycharm-2020.2.1&#x2F;bin&#x2F;pycharm.shIcon&#x3D;&#x2F;home&#x2F;zhuozhu&#x2F;桌面&#x2F;软件&#x2F;深度学习&#x2F;pycharm-2020.2.1&#x2F;bin&#x2F;pycharm.pngTerminal&#x3D;pycharm</span><br></pre></td></tr></table></figure>

<h2 id="5-安装Pytorch"><a href="#5-安装Pytorch" class="headerlink" title="5 - 安装Pytorch"></a>5 - 安装Pytorch</h2><p><a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">https://pytorch.org/get-started/locally/</a></p>
<p><code>conda install pytorch torchvision cudatoolkit=10.1</code></p>
]]></content>
      <categories>
        <category>深度学习环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  67 - 把字符串转换成整数</title>
    <url>/2021/07/12/SwordToOffer%20-%2067%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-67-把字符串转换成整数"><a href="#《剑指Offer》-67-把字符串转换成整数" class="headerlink" title="《剑指Offer》  67 - 把字符串转换成整数"></a>《剑指Offer》  67 - 把字符串转换成整数</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 67. 把字符串转换成整数</a></p>
<p>写一个函数 <code>StrToInt</code>，实现把字符串转换成整数这个功能。不能使用 <code>atoi</code>或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请<code>返回 0</code>。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 <code>32</code> 位大小的有符号整数，那么其数值范围为<code>[−2^31, 2^31 − 1]</code>。如果数值超过这个范围，请返回  <code>INT_MAX  (2^31 − 1)</code> 或 <code>INT_MIN (−2^31)</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<p><strong>本题与LeetCode8相同：</strong><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="注意整数上下界-和-开头正负号的判别方法"><a href="#注意整数上下界-和-开头正负号的判别方法" class="headerlink" title="注意整数上下界 和 开头正负号的判别方法"></a>注意整数上下界 和 开头正负号的判别方法</h4><p>测试用例中有 <code>&quot;+-1&quot;</code>，应返回 <code>0</code></p>
<p>所以在判别正负号的时候应该这些写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) ++i;</span><br></pre></td></tr></table></figure>

<p> 而不应该这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    flag = <span class="number">-1</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'+'</span>) i++;</span><br></pre></td></tr></table></figure>

<p>对于边界的判别：由于$2^{31}-1= 2147483648 - 1 = 2147483647$，所以设数字边界为 <code>boundary = MAX_INT/10 = 214748364</code>，以下两种情况会发生越界：</p>
<ul>
<li>$res &gt; boundary$：拼接时 $10 \times res &gt; 2147483650$ 越界</li>
<li>$res&gt;boundary，str[i]&gt;7$：拼接时$10 \times res &gt; 2^{31} - 1$ 越界</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!str.empty())</span><br><span class="line">            str.erase(<span class="number">0</span>, str.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">        <span class="keyword">if</span> (str.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">1</span>, boundary = INT_MAX / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) ++i;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; str.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; boundary || res == boundary &amp;&amp; str[i] &gt; <span class="string">'7'</span>)</span><br><span class="line">                <span class="keyword">return</span> flag == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712162728266.png" alt="image-20210712162728266"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 01 - 引言</title>
    <url>/2021/06/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2001%20-%20%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<h1 id="算法导论-01-引言"><a href="#算法导论-01-引言" class="headerlink" title="算法导论 01 - 引言"></a>算法导论 01 - 引言</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%80%E8%AE%B2_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm 第一讲_页面_1"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%80%E8%AE%B2_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm 第一讲_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  65 - 不用加减乘除做加法</title>
    <url>/2021/07/12/SwordToOffer%20-%2065%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-65-不用加减乘除做加法"><a href="#《剑指Offer》-65-不用加减乘除做加法" class="headerlink" title="《剑指Offer》  65 - 不用加减乘除做加法"></a>《剑指Offer》  65 - 不用加减乘除做加法</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法</a></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 <code>“+”、“-”、“*”、“/”</code>四则运算符号。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">a, b 均可能是负数或 0</span><br><span class="line">结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure>



<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="不能用加减乘除，只能用位运算了。。"><a href="#不能用加减乘除，只能用位运算了。。" class="headerlink" title="不能用加减乘除，只能用位运算了。。"></a>不能用加减乘除，只能用位运算了。。</h4><p>将两个数转为二进制，对应二进制位相加，会出现两种结果，进位和不进位，<strong>进位</strong>和<strong>与运算</strong>规律相同（与运算左移一位）。<strong>不进位</strong>和<strong>异或运算</strong>规律相同</p>
<ul>
<li>进位 = <code>(a &amp; b) &lt;&lt; 1</code></li>
<li>不进位 =  <code>a ^ b</code></li>
</ul>
<p>令不进位和等于$s1$，进位和等于$s2$，$s=a+b$ 可以转换为 $s = s1 + s2$，但是 $s1和s2$ 相加的结果可能还会产生进位，所以是一个递归的过程，直到不产生进位，才完成 $s = s1 + s2$</p>
<h4 id="递归写法，更易理解"><a href="#递归写法，更易理解" class="headerlink" title="递归写法，更易理解"></a>递归写法，更易理解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> add(a ^ b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);  <span class="comment">// c++不支持负值左移，需要强制转换为无符号数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712110605937.png" alt="image-20210712110605937"></p>
<h4 id="非递归写法，节省空间"><a href="#非递归写法，节省空间" class="headerlink" title="非递归写法，节省空间"></a>非递归写法，节省空间</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c =  (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;             </span><br><span class="line">            a = a ^ b;  </span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712134225921.png" alt="image-20210712134225921"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 02 - 从Fibonacci序列谈起</title>
    <url>/2021/06/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2002%20-%20%E4%BB%8EFibonacci%E5%BA%8F%E5%88%97%E8%B0%88%E8%B5%B7/</url>
    <content><![CDATA[<h1 id="算法导论-02-从Fibonacci序列谈起"><a href="#算法导论-02-从Fibonacci序列谈起" class="headerlink" title="算法导论 02 - 从Fibonacci序列谈起"></a>算法导论 02 - 从Fibonacci序列谈起</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%BA%8C%E8%AE%B2_%E4%BB%8Efibonacci%E5%BA%8F%E5%88%97%E8%B0%88%E8%B5%B7_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm 第二讲 从fibonacci序列谈起_1"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%BA%8C%E8%AE%B2_%E4%BB%8Efibonacci%E5%BA%8F%E5%88%97%E8%B0%88%E8%B5%B7_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm 第二讲 从fibonacci序列谈起_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》  66 - 构建乘积数组</title>
    <url>/2021/07/12/SwordToOffer%20-%2066%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="《剑指Offer》-66-构建乘积数组"><a href="#《剑指Offer》-66-构建乘积数组" class="headerlink" title="《剑指Offer》  66 - 构建乘积数组"></a>《剑指Offer》  66 - 构建乘积数组</h1><p><strong>题目：</strong><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">剑指 Offer 66. 构建乘积数组</a></p>
<p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是<code>数组 A</code> 中除了<code>下标 i</code>以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">a.length &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>



<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h4 id="双向前缀和"><a href="#双向前缀和" class="headerlink" title="双向前缀和"></a>双向前缀和</h4><p>将<code>B[i]</code> 抽象为一个矩阵，将其分为<code>上三角部分</code>和<code>下三角部分</code>，先求下三角，存入<code>B[i]</code>，在用一个临时变量在循环中计算上<code>三角中每一行的乘积</code>，与<code>B[i]</code>相乘。图片引用LeetCode的<a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener"><strong>Krahets</strong></a>大佬的题解。</p>
<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712143846942.png" alt="image-20210712143846942" style="zoom:67%;" />

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712143904617.png" alt="image-20210712143904617" style="zoom:67%;" />

<p><strong>两次循环写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">            b[i] = b[i<span class="number">-1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712144547850.png" alt="image-20210712144547850"></p>
<p><strong>一次循环：双端同时进行：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] *= left;</span><br><span class="line">            left *= a[i];             <span class="comment">// 持有左边的所有数的乘积</span></span><br><span class="line"></span><br><span class="line">            b[len - i - <span class="number">1</span>] *= right;</span><br><span class="line">            right *= a[len - i - <span class="number">1</span>];  <span class="comment">// 持有右边的所有数的乘积</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210712145136397.png" alt="image-20210712145136397"></p>
]]></content>
      <categories>
        <category>《剑指Offer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《剑指Offer》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 05 - 插入排序与算法分析(算法导论第2章)</title>
    <url>/2021/06/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2005%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="算法导论-05-插入排序与算法分析-算法导论第2章"><a href="#算法导论-05-插入排序与算法分析-算法导论第2章" class="headerlink" title="算法导论 05 - 插入排序与算法分析(算法导论第2章)"></a>算法导论 05 - 插入排序与算法分析(算法导论第2章)</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/5_%E9%A1%B5%E9%9D%A2_1.jpg" alt="5_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/5_%E9%A1%B5%E9%9D%A2_2.jpg" alt="5_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/5_%E9%A1%B5%E9%9D%A2_3.jpg" alt="5_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 04 - 元素去重</title>
    <url>/2021/06/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2004%20-%20%E5%85%83%E7%B4%A0%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h1 id="算法导论-04-元素去重"><a href="#算法导论-04-元素去重" class="headerlink" title="算法导论 04 - 元素去重"></a>算法导论 04 - 元素去重</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm4_1.jpg" alt="Algorithm第四讲元素去重_页面_1"><br>![Algorithm第四讲元素去重_页面_2]<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm4_2.jpg" alt="Algorithm4_2"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm4_3.jpg" alt="Algorithm第四讲元素去重_页面_3"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm4_4.jpg" alt="Algorithm第四讲元素去重_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 06 - 归并排序(算法导论第2章)</title>
    <url>/2021/06/03/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2006%20-%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC2%E7%AB%A0)/</url>
    <content><![CDATA[<h1 id="算法导论-06-归并排序-算法导论第2章"><a href="#算法导论-06-归并排序-算法导论第2章" class="headerlink" title="算法导论 06 - 归并排序(算法导论第2章)"></a>算法导论 06 - 归并排序(算法导论第2章)</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/6_%E9%A1%B5%E9%9D%A2_1.jpg" alt="6_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/6_%E9%A1%B5%E9%9D%A2_2.jpg" alt="6_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/6_%E9%A1%B5%E9%9D%A2_3.jpg" alt="6_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/6_%E9%A1%B5%E9%9D%A2_4.jpg" alt="6_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 03 - 渐进记号</title>
    <url>/2021/06/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2003%20-%20%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="算法导论-03-渐进记号"><a href="#算法导论-03-渐进记号" class="headerlink" title="算法导论 03 - 渐进记号"></a>算法导论 03 - 渐进记号</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%89%E8%AE%B2_%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm 第三讲 渐近记号_1"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%89%E8%AE%B2_%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm 第三讲 渐近记号_页面_2"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%89%E8%AE%B2_%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm 第三讲 渐近记号_页面_3"><br><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm_%E7%AC%AC%E4%B8%89%E8%AE%B2_%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm 第三讲 渐近记号_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 08 - 乐高铺砖问题</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2008%20-%20%E4%B9%90%E9%AB%98%E9%93%BA%E7%A0%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="算法导论-08-乐高铺砖问题"><a href="#算法导论-08-乐高铺砖问题" class="headerlink" title="算法导论 08 - 乐高铺砖问题"></a>算法导论 08 - 乐高铺砖问题</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-08-1.jpg" alt="Algorithm-08-1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-08-2.jpg" alt="Algorithm-08-1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-08-%E4%B9%90%E9%AB%98%E9%93%BA%E7%A0%96%E9%97%AE%E9%A2%98_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-08-2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 10 多路归并及其实现</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2010%20%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="算法导论-10-多路归并及其实现"><a href="#算法导论-10-多路归并及其实现" class="headerlink" title="算法导论 10 多路归并及其实现"></a>算法导论 10 多路归并及其实现</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-10-%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0.jpg" alt="Algorithm-10-多路归并及其实现"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 07 - 二分查找趣谈</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2007%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%B6%A3%E8%B0%88/</url>
    <content><![CDATA[<h1 id="算法导论-07-二分查找趣谈"><a href="#算法导论-07-二分查找趣谈" class="headerlink" title="算法导论 07 - 二分查找趣谈"></a>算法导论 07 - 二分查找趣谈</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-07-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%B6%A3%E8%B0%88_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-07-二分查找趣谈_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-07-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%B6%A3%E8%B0%88_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-07-二分查找趣谈_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-07-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%B6%A3%E8%B0%88_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-07-二分查找趣谈_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-07-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%B6%A3%E8%B0%88_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-07-二分查找趣谈_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 09 递推式的分析（算法导论第4章）</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2009%20%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-09-递推式的分析（算法导论第4章）"><a href="#算法导论-09-递推式的分析（算法导论第4章）" class="headerlink" title="算法导论 09 递推式的分析（算法导论第4章）"></a>算法导论 09 递推式的分析（算法导论第4章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-09-%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-09-递推式的分析（算法导论第4章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-09-%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-09-递推式的分析（算法导论第4章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-09-%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-09-递推式的分析（算法导论第4章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-09-%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-09-递推式的分析（算法导论第4章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-09-%E9%80%92%E6%8E%A8%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-09-递推式的分析（算法导论第4章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 11 主定理（算法导论第4章）</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2011%20%E4%B8%BB%E5%AE%9A%E7%90%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-11-主定理（算法导论第4章）"><a href="#算法导论-11-主定理（算法导论第4章）" class="headerlink" title="算法导论 11 主定理（算法导论第4章）"></a>算法导论 11 主定理（算法导论第4章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-11-%E4%B8%BB%E5%AE%9A%E7%90%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-11-主定理（算法导论第4章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-11-%E4%B8%BB%E5%AE%9A%E7%90%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-11-主定理（算法导论第4章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-11-%E4%B8%BB%E5%AE%9A%E7%90%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-11-主定理（算法导论第4章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 12 最大子数组问题 Strassen矩阵乘法 （算法导论第4章）</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2012%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%20Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%20%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-12-最大子数组问题-Strassen矩阵乘法-（算法导论第4章）"><a href="#算法导论-12-最大子数组问题-Strassen矩阵乘法-（算法导论第4章）" class="headerlink" title="算法导论 12 最大子数组问题 Strassen矩阵乘法 （算法导论第4章）"></a>算法导论 12 最大子数组问题 Strassen矩阵乘法 （算法导论第4章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-12-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98_Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-12-最大子数组问题_Strassen矩阵乘法（算法导论第4章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-12-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98_Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-12-最大子数组问题_Strassen矩阵乘法（算法导论第4章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-12-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98_Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-12-最大子数组问题_Strassen矩阵乘法（算法导论第4章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-12-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98_Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-12-最大子数组问题_Strassen矩阵乘法（算法导论第4章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 15 排序概览</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2015%20%E6%8E%92%E5%BA%8F%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="算法导论-15-排序概览"><a href="#算法导论-15-排序概览" class="headerlink" title="算法导论 15 排序概览"></a>算法导论 15 排序概览</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-15-%E6%8E%92%E5%BA%8F%E6%A6%82%E8%A7%88_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-15-排序概览_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-15-%E6%8E%92%E5%BA%8F%E6%A6%82%E8%A7%88_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-15-排序概览_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 13 概率分析与随机化算法（算法导论第4章）</title>
    <url>/2021/08/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2013%20%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-13-概率分析与随机化算法（算法导论第4章）"><a href="#算法导论-13-概率分析与随机化算法（算法导论第4章）" class="headerlink" title="算法导论 13 概率分析与随机化算法（算法导论第4章）"></a>算法导论 13 概率分析与随机化算法（算法导论第4章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-13-%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-13-概率分析与随机化算法（算法导论第4章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-13-%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-13-概率分析与随机化算法（算法导论第4章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-13-%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-13-概率分析与随机化算法（算法导论第4章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-13-%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-13-概率分析与随机化算法（算法导论第4章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-13-%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-13-概率分析与随机化算法（算法导论第4章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 14 Haffman编码_Majority问题</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2014%20Haffman%E7%BC%96%E7%A0%81_Majority%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>#　算法导论 14 Haffman编码_Majority问题</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-14-Haffman%E7%BC%96%E7%A0%81_Majority%E9%97%AE%E9%A2%98_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-14-Haffman编码_Majority问题_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-14-Haffman%E7%BC%96%E7%A0%81_Majority%E9%97%AE%E9%A2%98_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-14-Haffman编码_Majority问题_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-14-Haffman%E7%BC%96%E7%A0%81_Majority%E9%97%AE%E9%A2%98_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-14-Haffman编码_Majority问题_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-14-Haffman%E7%BC%96%E7%A0%81_Majority%E9%97%AE%E9%A2%98_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-14-Haffman编码_Majority问题_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 16 堆排序（算法导论第6章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2016%20%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-16-堆排序（算法导论第6章）"><a href="#算法导论-16-堆排序（算法导论第6章）" class="headerlink" title="算法导论 16 堆排序（算法导论第6章）"></a>算法导论 16 堆排序（算法导论第6章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-16-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-16-堆排序（算法导论第6章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-16-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-16-堆排序（算法导论第6章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-16-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-16-堆排序（算法导论第6章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-16-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-16-堆排序（算法导论第6章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-16-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC6%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-16-堆排序（算法导论第6章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 17 快速排序_Lomuto划分（算法导论第7章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2017%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Lomuto%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-17-快速排序-Lomuto划分（算法导论第7章）"><a href="#算法导论-17-快速排序-Lomuto划分（算法导论第7章）" class="headerlink" title="算法导论 17 快速排序_Lomuto划分（算法导论第7章）"></a>算法导论 17 快速排序_Lomuto划分（算法导论第7章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-17-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Lomuto%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-17-快速排序_Lomuto划分（算法导论第7章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-17-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Lomuto%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-17-快速排序_Lomuto划分（算法导论第7章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-17-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Lomuto%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-17-快速排序_Lomuto划分（算法导论第7章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-17-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Lomuto%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-17-快速排序_Lomuto划分（算法导论第7章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 18 快速排序_Hoare划分（算法导论第7章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2018%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Hoare%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-18-快速排序-Hoare划分（算法导论第7章）"><a href="#算法导论-18-快速排序-Hoare划分（算法导论第7章）" class="headerlink" title="算法导论 18 快速排序_Hoare划分（算法导论第7章）"></a>算法导论 18 快速排序_Hoare划分（算法导论第7章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-18-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Hoare%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-18-快速排序_Hoare划分（算法导论第7章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-18-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Hoare%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-18-快速排序_Hoare划分（算法导论第7章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-18-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Hoare%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-18-快速排序_Hoare划分（算法导论第7章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-18-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_Hoare%E5%88%92%E5%88%86%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC7%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-18-快速排序_Hoare划分（算法导论第7章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 19 线性时间的排序 - 计数排序（算法导论第8章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2019%20%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F%20-%20%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC8%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-19-线性时间的排序-计数排序（算法导论第8章）"><a href="#算法导论-19-线性时间的排序-计数排序（算法导论第8章）" class="headerlink" title="算法导论 19 线性时间的排序 - 计数排序（算法导论第8章）"></a>算法导论 19 线性时间的排序 - 计数排序（算法导论第8章）</h1><p>![Algorithm-19-线性时间的排序 - 计数排序（算法导论第8章）_页面_1](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序</a> - 计数排序（算法导论第8章）_页面_1.jpg)</p>
<p>![Algorithm-19-线性时间的排序 - 计数排序（算法导论第8章）_页面_2](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序</a> - 计数排序（算法导论第8章）_页面_2.jpg)</p>
<p>![Algorithm-19-线性时间的排序 - 计数排序（算法导论第8章）_页面_3](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-线性时间的排序</a> - 计数排序（算法导论第8章）_页面_3.jpg)</p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 20 线性时间的排序 - 基数排序 - 桶排序（算法导论第8章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2020%20%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F%20-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20-%20%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC8%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-20-线性时间的排序-基数排序-桶排序（算法导论第8章）"><a href="#算法导论-20-线性时间的排序-基数排序-桶排序（算法导论第8章）" class="headerlink" title="算法导论 20 线性时间的排序 - 基数排序 - 桶排序（算法导论第8章）"></a>算法导论 20 线性时间的排序 - 基数排序 - 桶排序（算法导论第8章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-20-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC8%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-20-线性时间的排序-基数排序-桶排序（算法导论第8章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-20-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC8%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-20-线性时间的排序-基数排序-桶排序（算法导论第8章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-20-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC8%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-20-线性时间的排序-基数排序-桶排序（算法导论第8章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 21 中位数与次序统计量（算法导论第9章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2021%20%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-21-中位数与次序统计量（算法导论第9章）"><a href="#算法导论-21-中位数与次序统计量（算法导论第9章）" class="headerlink" title="算法导论 21 中位数与次序统计量（算法导论第9章）"></a>算法导论 21 中位数与次序统计量（算法导论第9章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-21-%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-21-中位数与次序统计量（算法导论第9章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-21-%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-21-中位数与次序统计量（算法导论第9章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-21-%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-21-中位数与次序统计量（算法导论第9章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 22 选择算法分析（算法导论第9章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2022%20%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-22-选择算法分析（算法导论第9章）"><a href="#算法导论-22-选择算法分析（算法导论第9章）" class="headerlink" title="算法导论 22 选择算法分析（算法导论第9章）"></a>算法导论 22 选择算法分析（算法导论第9章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-22-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-22-选择算法分析（算法导论第9章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-22-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC9%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-22-选择算法分析（算法导论第9章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 23 栈和队列（算法导论第10章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2023%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-23-栈和队列（算法导论第10章）"><a href="#算法导论-23-栈和队列（算法导论第10章）" class="headerlink" title="算法导论 23 栈和队列（算法导论第10章）"></a>算法导论 23 栈和队列（算法导论第10章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-23-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-23-栈和队列（算法导论第10章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-23-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-23-栈和队列（算法导论第10章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 25 散列表1（算法导论第11章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2025%20%E6%95%A3%E5%88%97%E8%A1%A81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-25-散列表1（算法导论第11章）"><a href="#算法导论-25-散列表1（算法导论第11章）" class="headerlink" title="算法导论 25 散列表1（算法导论第11章）"></a>算法导论 25 散列表1（算法导论第11章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-25-%E6%95%A3%E5%88%97%E8%A1%A81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-25-散列表1（算法导论第11章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-25-%E6%95%A3%E5%88%97%E8%A1%A81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-25-散列表1（算法导论第11章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 24 链表与树（算法导论第10章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2024%20%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-24-链表与树（算法导论第10章）"><a href="#算法导论-24-链表与树（算法导论第10章）" class="headerlink" title="算法导论 24 链表与树（算法导论第10章）"></a>算法导论 24 链表与树（算法导论第10章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-24-%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-24-链表与树（算法导论第10章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-24-%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-24-链表与树（算法导论第10章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-24-%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC10%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-24-链表与树（算法导论第10章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 26 散列表2（算法导论第11章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2026%20%E6%95%A3%E5%88%97%E8%A1%A82%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-26-散列表2（算法导论第11章）"><a href="#算法导论-26-散列表2（算法导论第11章）" class="headerlink" title="算法导论 26 散列表2（算法导论第11章）"></a>算法导论 26 散列表2（算法导论第11章）</h1><p>![Algorithm-26- 散列表2（算法导论第11章）_页面_1](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-</a> 散列表2（算法导论第11章）_页面_1.jpg)</p>
<p>![Algorithm-26- 散列表2（算法导论第11章）_页面_2](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-</a> 散列表2（算法导论第11章）_页面_2.jpg)</p>
<p>![Algorithm-26- 散列表2（算法导论第11章）_页面_3](<a href="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-" target="_blank" rel="noopener">https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-26-</a> 散列表2（算法导论第11章）_页面_3.jpg)</p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 26 散列表3（算法导论第11章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2027%20%E6%95%A3%E5%88%97%E8%A1%A83%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-27-散列表3（算法导论第11章）"><a href="#算法导论-27-散列表3（算法导论第11章）" class="headerlink" title="算法导论 27 散列表3（算法导论第11章）"></a>算法导论 27 散列表3（算法导论第11章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-27-%E6%95%A3%E5%88%97%E8%A1%A83%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-27-散列表3（算法导论第11章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-27-%E6%95%A3%E5%88%97%E8%A1%A83%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-27-散列表3（算法导论第11章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-27-%E6%95%A3%E5%88%97%E8%A1%A83%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-27-散列表3（算法导论第11章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-27-%E6%95%A3%E5%88%97%E8%A1%A83%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-27-散列表3（算法导论第11章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 28 散列表4（算法导论第11章）</title>
    <url>/2021/06/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2028%20%E6%95%A3%E5%88%97%E8%A1%A84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-28-散列表4（算法导论第11章）"><a href="#算法导论-28-散列表4（算法导论第11章）" class="headerlink" title="算法导论 28 散列表4（算法导论第11章）"></a>算法导论 28 散列表4（算法导论第11章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-28-%E6%95%A3%E5%88%97%E8%A1%A84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-28-散列表4（算法导论第11章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-28-%E6%95%A3%E5%88%97%E8%A1%A84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-28-散列表4（算法导论第11章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-28-%E6%95%A3%E5%88%97%E8%A1%A84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-28-散列表4（算法导论第11章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-28-%E6%95%A3%E5%88%97%E8%A1%A84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC11%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-28-散列表4（算法导论第11章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 31 跳跃表</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2031%20%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<p>#　算法导论 31 跳跃表</p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-31-%E8%B7%B3%E8%B7%83%E8%A1%A8_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-31-跳跃表_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-31-%E8%B7%B3%E8%B7%83%E8%A1%A8_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-31-跳跃表_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-31-%E8%B7%B3%E8%B7%83%E8%A1%A8_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-31-跳跃表_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 19 二叉查找树1（算法导论第12章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2029%20%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%911%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-19-二叉查找树1（算法导论第12章）"><a href="#算法导论-19-二叉查找树1（算法导论第12章）" class="headerlink" title="算法导论 19 二叉查找树1（算法导论第12章）"></a>算法导论 19 二叉查找树1（算法导论第12章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%911%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-19-二叉查找树1（算法导论第12章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%911%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-19-二叉查找树1（算法导论第12章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-19-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%911%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-19-二叉查找树1（算法导论第12章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 30 二叉查找树2（算法导论第12章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2030%20%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-30-二叉查找树2（算法导论第12章）"><a href="#算法导论-30-二叉查找树2（算法导论第12章）" class="headerlink" title="算法导论 30 二叉查找树2（算法导论第12章）"></a>算法导论 30 二叉查找树2（算法导论第12章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-30-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-30-二叉查找树2（算法导论第12章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-30-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-30-二叉查找树2（算法导论第12章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-30-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-30-二叉查找树2（算法导论第12章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-30-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC12%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-30-二叉查找树2（算法导论第12章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 32 红黑色树（算法导论第13章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2032%20%E7%BA%A2%E9%BB%91%E8%89%B2%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-32-红黑色树（算法导论第13章）"><a href="#算法导论-32-红黑色树（算法导论第13章）" class="headerlink" title="算法导论 32 红黑色树（算法导论第13章）"></a>算法导论 32 红黑色树（算法导论第13章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-32-%E7%BA%A2%E9%BB%91%E8%89%B2%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-32-红黑色树（算法导论第13章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-32-%E7%BA%A2%E9%BB%91%E8%89%B2%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-32-红黑色树（算法导论第13章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-32-%E7%BA%A2%E9%BB%91%E8%89%B2%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-32-红黑色树（算法导论第13章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-32-%E7%BA%A2%E9%BB%91%E8%89%B2%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-32-红黑色树（算法导论第13章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 34 增强数据结构1（算法导论第14章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2034%20%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-34-增强数据结构1（算法导论第14章）"><a href="#算法导论-34-增强数据结构1（算法导论第14章）" class="headerlink" title="算法导论 34 增强数据结构1（算法导论第14章）"></a>算法导论 34 增强数据结构1（算法导论第14章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-34-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-34-增强数据结构1（算法导论第14章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-34-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-34-增强数据结构1（算法导论第14章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-34-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-34-增强数据结构1（算法导论第14章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-34-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-34-增强数据结构1（算法导论第14章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 33 红黑树的操作（算法导论第13章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2033%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-33-红黑树的操作（算法导论第13章）"><a href="#算法导论-33-红黑树的操作（算法导论第13章）" class="headerlink" title="算法导论 33 红黑树的操作（算法导论第13章）"></a>算法导论 33 红黑树的操作（算法导论第13章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-33-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-33-红黑树的操作（算法导论第13章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-33-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-33-红黑树的操作（算法导论第13章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-33-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-33-红黑树的操作（算法导论第13章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-33-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC13%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-33-红黑树的操作（算法导论第13章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 35 增强数据结构2（算法导论第14章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2035%20%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-35-增强数据结构2（算法导论第14章）"><a href="#算法导论-35-增强数据结构2（算法导论第14章）" class="headerlink" title="算法导论 35 增强数据结构2（算法导论第14章）"></a>算法导论 35 增强数据结构2（算法导论第14章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-35-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-35-增强数据结构2（算法导论第14章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-35-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-35-增强数据结构2（算法导论第14章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-35-%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC14%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-35-增强数据结构2（算法导论第14章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 36 初步动态规划 - 棍切割1（算法导论第15章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2036%20%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E6%A3%8D%E5%88%87%E5%89%B21%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-36-初步动态规划-棍切割1（算法导论第15章）"><a href="#算法导论-36-初步动态规划-棍切割1（算法导论第15章）" class="headerlink" title="算法导论 36 初步动态规划 - 棍切割1（算法导论第15章）"></a>算法导论 36 初步动态规划 - 棍切割1（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-36-%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A3%8D%E5%88%87%E5%89%B21%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-36-初步动态规划-棍切割1（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-36-%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A3%8D%E5%88%87%E5%89%B21%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-36-初步动态规划-棍切割1（算法导论第15章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-36-%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A3%8D%E5%88%87%E5%89%B21%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-36-初步动态规划-棍切割1（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-36-%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A3%8D%E5%88%87%E5%89%B21%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-36-初步动态规划-棍切割1（算法导论第15章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 37 初步动态规划 - 棍切割2（算法导论第15章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2037%20%E5%88%9D%E6%AD%A5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E6%A3%8D%E5%88%87%E5%89%B22%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-37-初步动态规划-棍切割2（算法导论第15章）"><a href="#算法导论-37-初步动态规划-棍切割2（算法导论第15章）" class="headerlink" title="算法导论 37 初步动态规划 - 棍切割2（算法导论第15章）"></a>算法导论 37 初步动态规划 - 棍切割2（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-37-%E6%A3%8D%E5%88%87%E5%89%B22%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-37-棍切割2（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-37-%E6%A3%8D%E5%88%87%E5%89%B22%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-37-%E6%A3%8D%E5%88%87%E5%89%B22%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-37-棍切割2（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-37-%E6%A3%8D%E5%88%87%E5%89%B22%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-37-棍切割2（算法导论第15章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 38 动态规划 - 矩阵链乘（算法导论第15章）</title>
    <url>/2021/06/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2038%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-38-动态规划-矩阵链乘（算法导论第15章）"><a href="#算法导论-38-动态规划-矩阵链乘（算法导论第15章）" class="headerlink" title="算法导论 38 动态规划 - 矩阵链乘（算法导论第15章）"></a>算法导论 38 动态规划 - 矩阵链乘（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-38-动态规划-矩阵链乘（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-38-动态规划-矩阵链乘（算法导论第15章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-38-动态规划-矩阵链乘（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-38-动态规划-矩阵链乘（算法导论第15章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-38-动态规划-矩阵链乘（算法导论第15章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 39 动态规划精要（算法导论第15章）</title>
    <url>/2021/06/17/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2039%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-39-动态规划精要（算法导论第15章）"><a href="#算法导论-39-动态规划精要（算法导论第15章）" class="headerlink" title="算法导论 39 动态规划精要（算法导论第15章）"></a>算法导论 39 动态规划精要（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-39-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-39-动态规划精要（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-39-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-39-动态规划精要（算法导论第15章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-39-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-39-动态规划精要（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-39-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-39-动态规划精要（算法导论第15章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-39-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-39-动态规划精要（算法导论第15章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 40 最长公共子序列问题（算法导论第15章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2040%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-40-最长公共子序列问题（算法导论第15章）"><a href="#算法导论-40-最长公共子序列问题（算法导论第15章）" class="headerlink" title="算法导论 40 最长公共子序列问题（算法导论第15章）"></a>算法导论 40 最长公共子序列问题（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-40-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-40-最长公共子序列问题（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-40-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-40-最长公共子序列问题（算法导论第15章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-40-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-40-最长公共子序列问题（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-40-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-40-最长公共子序列问题（算法导论第15章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 41 最优二叉查找树（算法导论第15章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2041%20%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-41-最优二叉查找树（算法导论第15章）"><a href="#算法导论-41-最优二叉查找树（算法导论第15章）" class="headerlink" title="算法导论 41 最优二叉查找树（算法导论第15章）"></a>算法导论 41 最优二叉查找树（算法导论第15章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-41-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-41-最优二叉查找树（算法导论第15章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-41-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-41-最优二叉查找树（算法导论第15章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-41-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-41-最优二叉查找树（算法导论第15章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-41-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC15%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-41-最优二叉查找树（算法导论第15章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 42 贪心算法 活动选择问题（算法导论第16章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2042%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-42-贪心算法-活动选择问题（算法导论第16章）"><a href="#算法导论-42-贪心算法-活动选择问题（算法导论第16章）" class="headerlink" title="算法导论 42 贪心算法 活动选择问题（算法导论第16章）"></a>算法导论 42 贪心算法 活动选择问题（算法导论第16章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-42-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-42-贪心算法-活动选择问题（算法导论第16章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-42-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-42-贪心算法-活动选择问题（算法导论第16章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-42-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-42-贪心算法-活动选择问题（算法导论第16章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-42-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-42-贪心算法-活动选择问题（算法导论第16章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 43 贪心策略精要（算法导论第16章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2043%20%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-43-贪心策略精要（算法导论第16章）"><a href="#算法导论-43-贪心策略精要（算法导论第16章）" class="headerlink" title="算法导论 43 贪心策略精要（算法导论第16章）"></a>算法导论 43 贪心策略精要（算法导论第16章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-43-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-43-贪心策略精要（算法导论第16章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-43-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-43-贪心策略精要（算法导论第16章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-43-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-43-贪心策略精要（算法导论第16章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-43-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%B2%BE%E8%A6%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-43-贪心策略精要（算法导论第16章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 44 Huffman编码（算法导论第16章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2044%20Huffman%E7%BC%96%E7%A0%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-44-Huffman编码（算法导论第16章）"><a href="#算法导论-44-Huffman编码（算法导论第16章）" class="headerlink" title="算法导论 44 Huffman编码（算法导论第16章）"></a>算法导论 44 Huffman编码（算法导论第16章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-44-Huffman%E7%BC%96%E7%A0%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-44-Huffman编码（算法导论第16章）_页面_1"></p>
<p><img src="G:%5C%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%5CAlgorithm-44-Huffman%E7%BC%96%E7%A0%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-44-Huffman编码（算法导论第16章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-44-Huffman%E7%BC%96%E7%A0%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-44-Huffman编码（算法导论第16章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-44-Huffman%E7%BC%96%E7%A0%81%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-44-Huffman编码（算法导论第16章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 45 拟阵与贪心算法（算法导论第16章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2045%20%E6%8B%9F%E9%98%B5%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-45-拟阵与贪心算法（算法导论第16章）"><a href="#算法导论-45-拟阵与贪心算法（算法导论第16章）" class="headerlink" title="算法导论 45 拟阵与贪心算法（算法导论第16章）"></a>算法导论 45 拟阵与贪心算法（算法导论第16章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-45-%E6%8B%9F%E9%98%B5%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-45-拟阵与贪心算法（算法导论第16章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-45-%E6%8B%9F%E9%98%B5%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-45-拟阵与贪心算法（算法导论第16章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-45-%E6%8B%9F%E9%98%B5%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-45-拟阵与贪心算法（算法导论第16章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-45-%E6%8B%9F%E9%98%B5%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC16%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-45-拟阵与贪心算法（算法导论第16章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 48 高级数据结构预览</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2048%20%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<h1 id="算法导论-48-高级数据结构预览"><a href="#算法导论-48-高级数据结构预览" class="headerlink" title="算法导论 48 高级数据结构预览"></a>算法导论 48 高级数据结构预览</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-48-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E8%A7%88_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-48-高级数据结构预览_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-48-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E8%A7%88_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-48-高级数据结构预览_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 46 分摊分析 - 总量分析和核算方法（算法导论第17章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2046%20%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90%20-%20%E6%80%BB%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%B8%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-46-分摊分析-总量分析和核算方法（算法导论第17章）"><a href="#算法导论-46-分摊分析-总量分析和核算方法（算法导论第17章）" class="headerlink" title="算法导论 46 分摊分析 - 总量分析和核算方法（算法导论第17章）"></a>算法导论 46 分摊分析 - 总量分析和核算方法（算法导论第17章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-46-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E6%80%BB%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%B8%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-46-分摊分析-总量分析和核算方法（算法导论第17章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-46-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E6%80%BB%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%B8%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-46-分摊分析-总量分析和核算方法（算法导论第17章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-46-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E6%80%BB%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%B8%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-46-分摊分析-总量分析和核算方法（算法导论第17章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-46-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E6%80%BB%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%B8%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-46-分摊分析-总量分析和核算方法（算法导论第17章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 47 分摊分析 - 势方法（算法导论第17章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2047%20%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90%20-%20%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-47-分摊分析-势方法（算法导论第17章）"><a href="#算法导论-47-分摊分析-势方法（算法导论第17章）" class="headerlink" title="算法导论 47 分摊分析 - 势方法（算法导论第17章）"></a>算法导论 47 分摊分析 - 势方法（算法导论第17章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_5"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-47-%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90-%E5%8A%BF%E6%96%B9%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC17%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_6.jpg" alt="Algorithm-47-分摊分析-势方法（算法导论第17章）_页面_6"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 49 B树 上 （算法导论第18章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2049%20B%E6%A0%91%20%E4%B8%8A%20%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-49-B树-上-（算法导论第18章）"><a href="#算法导论-49-B树-上-（算法导论第18章）" class="headerlink" title="算法导论 49 B树 上 （算法导论第18章）"></a>算法导论 49 B树 上 （算法导论第18章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-49-B%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-49-B树上（算法导论第18章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-49-B%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-49-B树上（算法导论第18章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-49-B%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-49-B树上（算法导论第18章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-49-B%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-49-B树上（算法导论第18章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 50 B树 下（算法导论第18章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2050%20B%E6%A0%91%20%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-50-B树-下（算法导论第18章）"><a href="#算法导论-50-B树-下（算法导论第18章）" class="headerlink" title="算法导论 50 B树 下（算法导论第18章）"></a>算法导论 50 B树 下（算法导论第18章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-50-B%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-50-B树下（算法导论第18章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-50-B%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-50-B树下（算法导论第18章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-50-B%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC18%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-50-B树下（算法导论第18章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 51 Fibonacci堆 上（算法导论第19章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2051%20Fibonacci%E5%A0%86%20%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-51-Fibonacci堆-上（算法导论第19章）"><a href="#算法导论-51-Fibonacci堆-上（算法导论第19章）" class="headerlink" title="算法导论 51 Fibonacci堆 上（算法导论第19章）"></a>算法导论 51 Fibonacci堆 上（算法导论第19章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-51-Fibonacci%E5%A0%86-%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-51-Fibonacci堆-上（算法导论第19章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-51-Fibonacci%E5%A0%86-%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-51-Fibonacci堆-上（算法导论第19章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-51-Fibonacci%E5%A0%86-%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-51-Fibonacci堆-上（算法导论第19章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-51-Fibonacci%E5%A0%86-%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-51-Fibonacci堆-上（算法导论第19章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 52 Fibonacci堆 中（算法导论第19章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2052%20Fibonacci%E5%A0%86%20%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-52-Fibonacci堆-中（算法导论第19章）"><a href="#算法导论-52-Fibonacci堆-中（算法导论第19章）" class="headerlink" title="算法导论 52 Fibonacci堆 中（算法导论第19章）"></a>算法导论 52 Fibonacci堆 中（算法导论第19章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-52-Fibonacci%E5%A0%86%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-52-Fibonacci堆中（算法导论第19章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-52-Fibonacci%E5%A0%86%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-52-Fibonacci堆中（算法导论第19章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-52-Fibonacci%E5%A0%86%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-52-Fibonacci堆中（算法导论第19章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-52-Fibonacci%E5%A0%86%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-52-Fibonacci堆中（算法导论第19章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-52-Fibonacci%E5%A0%86%E4%B8%AD%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-52-Fibonacci堆中（算法导论第19章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 53 Fibonacci堆 下（算法导论第19章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2053%20Fibonacci%E5%A0%86%20%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-53-Fibonacci堆-下（算法导论第19章）"><a href="#算法导论-53-Fibonacci堆-下（算法导论第19章）" class="headerlink" title="算法导论 53 Fibonacci堆 下（算法导论第19章）"></a>算法导论 53 Fibonacci堆 下（算法导论第19章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-53-Fibonacci%E5%A0%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-53-Fibonacci堆下（算法导论第19章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-53-Fibonacci%E5%A0%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-53-Fibonacci堆下（算法导论第19章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-53-Fibonacci%E5%A0%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-53-Fibonacci堆下（算法导论第19章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-53-Fibonacci%E5%A0%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-53-Fibonacci堆下（算法导论第19章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-53-Fibonacci%E5%A0%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC19%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-53-Fibonacci堆下（算法导论第19章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 54 vEB树 上（算法导论第20章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2054%20vEB%E6%A0%91%20%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-54-vEB树-上（算法导论第20章）"><a href="#算法导论-54-vEB树-上（算法导论第20章）" class="headerlink" title="算法导论 54 vEB树 上（算法导论第20章）"></a>算法导论 54 vEB树 上（算法导论第20章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-54-vEB%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-54-vEB树上（算法导论第20章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-54-vEB%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-54-vEB树上（算法导论第20章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-54-vEB%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-54-vEB树上（算法导论第20章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-54-vEB%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-54-vEB树上（算法导论第20章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-54-vEB%E6%A0%91%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-54-vEB树上（算法导论第20章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 55 vEB树 下（算法导论第20章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2055%20vEB%E6%A0%91%20%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-55-vEB树-下（算法导论第20章）"><a href="#算法导论-55-vEB树-下（算法导论第20章）" class="headerlink" title="算法导论 55 vEB树 下（算法导论第20章）"></a>算法导论 55 vEB树 下（算法导论第20章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_5"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-55-vEB%E6%A0%91%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC20%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_6.jpg" alt="Algorithm-55-vEB树下（算法导论第20章）_页面_6"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 56 不相交集 上（算法导论第21章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2056%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%20%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-56-不相交集-上（算法导论第21章）"><a href="#算法导论-56-不相交集-上（算法导论第21章）" class="headerlink" title="算法导论 56 不相交集 上（算法导论第21章）"></a>算法导论 56 不相交集 上（算法导论第21章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-56-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-56-不相交集上（算法导论第21章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-56-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-56-不相交集上（算法导论第21章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-56-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-56-不相交集上（算法导论第21章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-56-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8A%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-56-不相交集上（算法导论第21章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 57 不相交集 下（算法导论第21章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2057%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%20%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-57-不相交集-下（算法导论第21章）"><a href="#算法导论-57-不相交集-下（算法导论第21章）" class="headerlink" title="算法导论 57 不相交集 下（算法导论第21章）"></a>算法导论 57 不相交集 下（算法导论第21章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-57-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-57-不相交集下（算法导论第21章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-57-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-57-不相交集下（算法导论第21章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-57-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-57-不相交集下（算法导论第21章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-57-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-57-不相交集下（算法导论第21章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-57-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E4%B8%8B%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC21%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-57-不相交集下（算法导论第21章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 58 图（算法导论第22章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2058%20%E5%9B%BE%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-58-图（算法导论第22章）"><a href="#算法导论-58-图（算法导论第22章）" class="headerlink" title="算法导论 58 图（算法导论第22章）"></a>算法导论 58 图（算法导论第22章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-58-%E5%9B%BE%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-58-图（算法导论第22章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-58-%E5%9B%BE%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-58-图（算法导论第22章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 59 广度优先搜索（算法导论第22章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2059%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-59-广度优先搜索（算法导论第22章）"><a href="#算法导论-59-广度优先搜索（算法导论第22章）" class="headerlink" title="算法导论 59 广度优先搜索（算法导论第22章）"></a>算法导论 59 广度优先搜索（算法导论第22章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_5"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-59-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_6.jpg" alt="Algorithm-59-广度优先搜索（算法导论第22章）_页面_6"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 63 最小生成树（算法导论第23章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2063%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-63-最小生成树（算法导论第23章）"><a href="#算法导论-63-最小生成树（算法导论第23章）" class="headerlink" title="算法导论 63 最小生成树（算法导论第23章）"></a>算法导论 63 最小生成树（算法导论第23章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-63-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-63-最小生成树（算法导论第23章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-63-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-63-最小生成树（算法导论第23章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 61 拓扑排序（算法导论第22章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2061%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-61-拓扑排序（算法导论第22章）"><a href="#算法导论-61-拓扑排序（算法导论第22章）" class="headerlink" title="算法导论 61 拓扑排序（算法导论第22章）"></a>算法导论 61 拓扑排序（算法导论第22章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-61-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-61-拓扑排序（算法导论第22章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-61-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-61-拓扑排序（算法导论第22章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-61-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-61-拓扑排序（算法导论第22章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-61-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-61-拓扑排序（算法导论第22章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 60 深度优先搜索（算法导论第22章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2060%20%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-60-深度优先搜索（算法导论第22章）"><a href="#算法导论-60-深度优先搜索（算法导论第22章）" class="headerlink" title="算法导论 60 深度优先搜索（算法导论第22章）"></a>算法导论 60 深度优先搜索（算法导论第22章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-60-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-60-深度优先搜索（算法导论第22章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-60-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-60-深度优先搜索（算法导论第22章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-60-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-60-深度优先搜索（算法导论第22章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-60-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-60-深度优先搜索（算法导论第22章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-60-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-60-深度优先搜索（算法导论第22章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 62 强连通分量（算法导论第22章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2062%20%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-62-强连通分量（算法导论第22章）"><a href="#算法导论-62-强连通分量（算法导论第22章）" class="headerlink" title="算法导论 62 强连通分量（算法导论第22章）"></a>算法导论 62 强连通分量（算法导论第22章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-62-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-62-强连通分量（算法导论第22章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-62-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-62-强连通分量（算法导论第22章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-62-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-62-强连通分量（算法导论第22章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-62-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC22%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-62-强连通分量（算法导论第22章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 64 Kruskal 与 Prim 算法（算法导论第23章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2064%20Kruskal%20%E4%B8%8E%20Prim%20%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-64-Kruskal-与-Prim-算法（算法导论第23章）"><a href="#算法导论-64-Kruskal-与-Prim-算法（算法导论第23章）" class="headerlink" title="算法导论 64 Kruskal 与 Prim 算法（算法导论第23章）"></a>算法导论 64 Kruskal 与 Prim 算法（算法导论第23章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-64-Kruskal%E4%B8%8EPrim%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-64-Kruskal与Prim算法（算法导论第23章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-64-Kruskal%E4%B8%8EPrim%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-64-Kruskal与Prim算法（算法导论第23章）_页面_2"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 65 最小生成树算法实现（算法导论第23章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2065%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-65-最小生成树算法实现（算法导论第23章）"><a href="#算法导论-65-最小生成树算法实现（算法导论第23章）" class="headerlink" title="算法导论 65 最小生成树算法实现（算法导论第23章）"></a>算法导论 65 最小生成树算法实现（算法导论第23章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-65-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-65-最小生成树算法实现（算法导论第23章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-65-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-65-最小生成树算法实现（算法导论第23章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-65-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-65-最小生成树算法实现（算法导论第23章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-65-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC23%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-65-最小生成树算法实现（算法导论第23章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 66 从Dijkstra算法谈起（算法导论第24章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2066%20%E4%BB%8EDijkstra%E7%AE%97%E6%B3%95%E8%B0%88%E8%B5%B7%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-66-从Dijkstra算法谈起（算法导论第24章）"><a href="#算法导论-66-从Dijkstra算法谈起（算法导论第24章）" class="headerlink" title="算法导论 66 从Dijkstra算法谈起（算法导论第24章）"></a>算法导论 66 从Dijkstra算法谈起（算法导论第24章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-66-%E4%BB%8EDijkstra%E7%AE%97%E6%B3%95%E8%B0%88%E8%B5%B7%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-66-从Dijkstra算法谈起（算法导论第24章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-66-%E4%BB%8EDijkstra%E7%AE%97%E6%B3%95%E8%B0%88%E8%B5%B7%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-66-从Dijkstra算法谈起（算法导论第24章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-66-%E4%BB%8EDijkstra%E7%AE%97%E6%B3%95%E8%B0%88%E8%B5%B7%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-66-从Dijkstra算法谈起（算法导论第24章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 67 Dijkstra算法实现（算法导论第24章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2067%20Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-67-Dijkstra算法实现（算法导论第24章）"><a href="#算法导论-67-Dijkstra算法实现（算法导论第24章）" class="headerlink" title="算法导论 67 Dijkstra算法实现（算法导论第24章）"></a>算法导论 67 Dijkstra算法实现（算法导论第24章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-67-Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-67-Dijkstra算法实现（算法导论第24章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-67-Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-67-Dijkstra算法实现（算法导论第24章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-67-Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-67-Dijkstra算法实现（算法导论第24章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-67-Dijkstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-67-Dijkstra算法实现（算法导论第24章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 68 最短路径导引（算法导论第24章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2068%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%BC%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-68-最短路径导引（算法导论第24章）"><a href="#算法导论-68-最短路径导引（算法导论第24章）" class="headerlink" title="算法导论 68 最短路径导引（算法导论第24章）"></a>算法导论 68 最短路径导引（算法导论第24章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-68-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%BC%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-68-最短路径导引（算法导论第24章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-68-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%BC%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-68-最短路径导引（算法导论第24章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-68-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%BC%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-68-最短路径导引（算法导论第24章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-68-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%BC%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-68-最短路径导引（算法导论第24章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 69 Bellman-Ford-Moore 基于队列的算法实现（算法导论第24章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2069%20Bellman-Ford-Moore%20%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）"><a href="#算法导论-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）" class="headerlink" title="算法导论 69 Bellman-Ford-Moore 基于队列的算法实现（算法导论第24章）"></a>算法导论 69 Bellman-Ford-Moore 基于队列的算法实现（算法导论第24章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-69-Bellman-Ford-Moore-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-69-Bellman-Ford-Moore-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-69-Bellman-Ford-Moore-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-69-Bellman-Ford-Moore-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-69-Bellman-Ford-Moore-基于队列的算法实现（算法导论第24章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 70 差分约束与最短路径性质（算法导论第24章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2070%20%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-70-差分约束与最短路径性质（算法导论第24章）"><a href="#算法导论-70-差分约束与最短路径性质（算法导论第24章）" class="headerlink" title="算法导论 70 差分约束与最短路径性质（算法导论第24章）"></a>算法导论 70 差分约束与最短路径性质（算法导论第24章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-70-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-70-差分约束与最短路径性质（算法导论第24章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-70-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-70-差分约束与最短路径性质（算法导论第24章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-70-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-70-差分约束与最短路径性质（算法导论第24章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-70-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-70-差分约束与最短路径性质（算法导论第24章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-70-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%A7%E8%B4%A8%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC24%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-70-差分约束与最短路径性质（算法导论第24章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 71 所有点对最短路径（算法导论第25章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2071%20%E6%89%80%E6%9C%89%E7%82%B9%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-71-所有点对最短路径（算法导论第25章）"><a href="#算法导论-71-所有点对最短路径（算法导论第25章）" class="headerlink" title="算法导论 71 所有点对最短路径（算法导论第25章）"></a>算法导论 71 所有点对最短路径（算法导论第25章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-71-%E6%89%80%E6%9C%89%E7%82%B9%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-71-所有点对最短路径（算法导论第25章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-71-%E6%89%80%E6%9C%89%E7%82%B9%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-71-所有点对最短路径（算法导论第25章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-71-%E6%89%80%E6%9C%89%E7%82%B9%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-71-所有点对最短路径（算法导论第25章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 72 Floyd-Warshall算法（算法导论第25章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2072%20Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-72-Floyd-Warshall算法（算法导论第25章）"><a href="#算法导论-72-Floyd-Warshall算法（算法导论第25章）" class="headerlink" title="算法导论 72 Floyd-Warshall算法（算法导论第25章）"></a>算法导论 72 Floyd-Warshall算法（算法导论第25章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-72-Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-72-Floyd-Warshall算法（算法导论第25章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-72-Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-72-Floyd-Warshall算法（算法导论第25章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-72-Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-72-Floyd-Warshall算法（算法导论第25章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-72-Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-72-Floyd-Warshall算法（算法导论第25章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 73 稀疏图的Johnson算法（算法导论第25章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2073%20%E7%A8%80%E7%96%8F%E5%9B%BE%E7%9A%84Johnson%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-73-稀疏图的Johnson算法（算法导论第25章）"><a href="#算法导论-73-稀疏图的Johnson算法（算法导论第25章）" class="headerlink" title="算法导论 73 稀疏图的Johnson算法（算法导论第25章）"></a>算法导论 73 稀疏图的Johnson算法（算法导论第25章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-73-%E7%A8%80%E7%96%8F%E5%9B%BE%E7%9A%84Johnson%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-73-稀疏图的Johnson算法（算法导论第25章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-73-%E7%A8%80%E7%96%8F%E5%9B%BE%E7%9A%84Johnson%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-73-稀疏图的Johnson算法（算法导论第25章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-73-%E7%A8%80%E7%96%8F%E5%9B%BE%E7%9A%84Johnson%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC25%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-73-稀疏图的Johnson算法（算法导论第25章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 74 最大流 基础（算法导论第26章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2074%20%E6%9C%80%E5%A4%A7%E6%B5%81%20%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-74-最大流-基础（算法导论第26章）"><a href="#算法导论-74-最大流-基础（算法导论第26章）" class="headerlink" title="算法导论 74 最大流 基础（算法导论第26章）"></a>算法导论 74 最大流 基础（算法导论第26章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-74-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-74-最大流基础（算法导论第26章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-74-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-74-最大流基础（算法导论第26章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-74-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-74-最大流基础（算法导论第26章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-74-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-74-最大流基础（算法导论第26章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-74-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-74-最大流基础（算法导论第26章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 75 最大流 最小割（算法导论第26章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2075%20%E6%9C%80%E5%A4%A7%E6%B5%81%20%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-75-最大流-最小割（算法导论第26章）"><a href="#算法导论-75-最大流-最小割（算法导论第26章）" class="headerlink" title="算法导论 75 最大流 最小割（算法导论第26章）"></a>算法导论 75 最大流 最小割（算法导论第26章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-75-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-75-最大流最小割（算法导论第26章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-75-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-75-最大流最小割（算法导论第26章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-75-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-75-最大流最小割（算法导论第26章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 76 Emonds-Karp算法（算法导论第26章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2076%20Emonds-Karp%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-76-Emonds-Karp算法（算法导论第26章）"><a href="#算法导论-76-Emonds-Karp算法（算法导论第26章）" class="headerlink" title="算法导论 76 Emonds-Karp算法（算法导论第26章）"></a>算法导论 76 Emonds-Karp算法（算法导论第26章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-76-Emonds-Karp%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-76-Emonds-Karp算法（算法导论第26章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-76-Emonds-Karp%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-76-Emonds-Karp算法（算法导论第26章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-76-Emonds-Karp%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-76-Emonds-Karp算法（算法导论第26章）_页面_3"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 77 最大二部匹配以及推入 - 重编号算法（算法导论第26章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2077%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E9%83%A8%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%85%A5%20-%20%E9%87%8D%E7%BC%96%E5%8F%B7%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-77-最大二部匹配以及推入-重编号算法（算法导论第26章）"><a href="#算法导论-77-最大二部匹配以及推入-重编号算法（算法导论第26章）" class="headerlink" title="算法导论 77 最大二部匹配以及推入 - 重编号算法（算法导论第26章）"></a>算法导论 77 最大二部匹配以及推入 - 重编号算法（算法导论第26章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-77-%E6%9C%80%E5%A4%A7%E4%BA%8C%E9%83%A8%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%85%A5-%E9%87%8D%E7%BC%96%E5%8F%B7%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-77-最大二部匹配以及推入-重编号算法（算法导论第26章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-77-%E6%9C%80%E5%A4%A7%E4%BA%8C%E9%83%A8%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%85%A5-%E9%87%8D%E7%BC%96%E5%8F%B7%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-77-最大二部匹配以及推入-重编号算法（算法导论第26章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-77-%E6%9C%80%E5%A4%A7%E4%BA%8C%E9%83%A8%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%85%A5-%E9%87%8D%E7%BC%96%E5%8F%B7%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-77-最大二部匹配以及推入-重编号算法（算法导论第26章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-77-%E6%9C%80%E5%A4%A7%E4%BA%8C%E9%83%A8%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%85%A5-%E9%87%8D%E7%BC%96%E5%8F%B7%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-77-最大二部匹配以及推入-重编号算法（算法导论第26章）_页面_4"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论 78 重编号排头算法 - 基于高度函数的精巧求解（算法导论第26章）</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%2078%20%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95%20-%20%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）"><a href="#算法导论-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）" class="headerlink" title="算法导论 78 重编号排头算法 - 基于高度函数的精巧求解（算法导论第26章）"></a>算法导论 78 重编号排头算法 - 基于高度函数的精巧求解（算法导论第26章）</h1><p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-78-%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_1.jpg" alt="Algorithm-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）_页面_1"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-78-%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_2.jpg" alt="Algorithm-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）_页面_2"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-78-%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_3.jpg" alt="Algorithm-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）_页面_3"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-78-%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_4.jpg" alt="Algorithm-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）_页面_4"></p>
<p><img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/Algorithm-78-%E9%87%8D%E7%BC%96%E5%8F%B7%E6%8E%92%E5%A4%B4%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%B2%BE%E5%B7%A7%E6%B1%82%E8%A7%A3%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC26%E7%AB%A0%EF%BC%89_%E9%A1%B5%E9%9D%A2_5.jpg" alt="Algorithm-78-重编号排头算法-基于高度函数的精巧求解（算法导论第26章）_页面_5"></p>
]]></content>
      <categories>
        <category>《算法导论》</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>算法</tag>
        <tag>《算法导论》</tag>
      </tags>
  </entry>
  <entry>
    <title>PyBullet Quickstart Guide 官方文档翻译</title>
    <url>/2021/06/02/PyBullet/</url>
    <content><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 - Introduction"></a>1 - Introduction</h1><h2 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h2><ul>
<li>p.connect()  <ul>
<li>与physics server 连接，有DIRECT和GUI两个模式，DIRECT模式创建一个新的物理引擎，并直接与它通信。GUI将创造一个带有图形化GUI前端的物理引擎并与之进行通信</li>
</ul>
</li>
<li>p.disconnect()<ul>
<li>与physics server 断开连接</li>
</ul>
</li>
<li>p.getConnectionInfo()<ul>
<li>参数为physicsClientId，返回一个列表[isConnected,connectionMethod]</li>
</ul>
</li>
<li>p.isConnected()<ul>
<li>如果connected返回True，否则为False，参数是physicsClientId</li>
</ul>
</li>
<li>p.setGravity()<ul>
<li>设置重力，p.setGravity(0,0,-9.8)</li>
</ul>
</li>
<li>p.loadURDF(FileName), p.loadSDF(), p.loadMJCF()<ul>
<li>载入urdf模型</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-2-保存和恢复"><a href="#1-2-保存和恢复" class="headerlink" title="1.2 保存和恢复"></a>1.2 保存和恢复</h2><ul>
<li>p.saveState(), p.saveBullet(), p.restoreState(fileName)  <strong>1.2_saveRestoreState.py</strong><ul>
<li>saveState（内存），saveBullet（磁盘），用restoreState恢复存储的快照</li>
</ul>
</li>
<li>p.removeState()<ul>
<li>从内存中删除以前存储的状态,即saveState()存储的状态</li>
</ul>
</li>
<li>p.saveWorld(fileName)<ul>
<li>使用PyBullet Python file存储一个世界快照</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-3-创建一些物体-snake-py"><a href="#1-3-创建一些物体-snake-py" class="headerlink" title="1.3 创建一些物体 snake.py"></a>1.3 创建一些物体 <strong>snake.py</strong></h2><ul>
<li>p.createCollisionShape(shapeType)<ul>
<li>创建物体，可选参数很多</li>
</ul>
</li>
<li>p.createCollisionShapeArray(),是createCollisionShape的数组版本，使用方法在  <strong>createVisualShapeArray.py</strong></li>
<li>p.removeCollisionShape()</li>
</ul>
<br>

<ul>
<li>p.createVisualShape(shapeType) <strong>addPlanarReflection.py</strong> <strong>createVisualShape.py</strong>  <strong>createVisualShapeArray.py</strong> <strong>createTexturedMeshVisualShape.py</strong></li>
<li>p.createVisualShapeArray()</li>
<li>p.createMultiBody()  <strong>createMultiBodyLinks.py</strong></li>
<li>p.getMeshData(bodyUniqueID)<ul>
<li>返回三角形网格的网格信息(顶点，索引)。</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="1-4-仿真执行"><a href="#1-4-仿真执行" class="headerlink" title="1.4 仿真执行"></a>1.4 仿真执行</h2><ul>
<li>stepSimulation()<ul>
<li>step simulation将在一个单一的正向动力学仿真步骤中执行所有的动作，如碰撞检测、约束求解和集成。默认的timestep是1/240秒，可以通过setTimeStep或setPhysicsEngineParameter API修改, 没有返回值</li>
</ul>
</li>
<li>setRealTimeSimulation(enableRealTimeSimulation)<ul>
<li>默认情况下，物理服务器不会步进模拟，除非你显式地发送“stepSimulation”命令。这样就可以保持模拟的控制确定性。通过使用setRealTimeSimulation命令，让物理服务器根据它的实时时钟(RTC)自动步进仿真，实时运行仿真是可能的。如果启用了实时模拟，则不需要调用“步进模拟”。</li>
</ul>
</li>
</ul>
<h2 id="1-5-位置与方位"><a href="#1-5-位置与方位" class="headerlink" title="1.5 位置与方位"></a>1.5 位置与方位</h2><ul>
<li>getBasePositionAndOrientation(objectUniqueID)<ul>
<li>笛卡尔坐标系, the base (or root link) of the body的当前位置和方向。方位是[x,y,z,w]格式的四元数。</li>
<li>返回三个浮点数的位置list和四个浮点数的方位list（顺序是[x,y,z,w]）使用 getEulerFromQuaternion可以将四元数转换为欧拉角</li>
</ul>
</li>
<li>resetBasePositionAndOrientation(bodyUniqueId, posObj, ornObj)<ul>
<li>可以重置每个对象的底部（根）的位置和方向。最好只在开始时执行此操作，而不是在运行模拟期间，因为该命令将覆盖所有物理模拟的效果。将线速度和角速度设置为零。可以使用resetBaseVelocity重置为非零的线性和/或角速度。</li>
</ul>
</li>
<li>getQuaternionFromEuler([x,y,z,w]) &amp; getEulerFromQuaternion([yaw,pitch,roll])<ul>
<li>四元组和欧拉角相互转换</li>
</ul>
</li>
<li>getMatrixFromQuaternion([x,y,z,w]) &amp; getAxisAngleFromQuaternion([x,y,z,w])</li>
</ul>
<p><br><br></p>
<ul>
<li>multiplyTransforms, invertTransform<ul>
<li>PyBullet提供了一些辅助函数来进行乘法和反变换。这对于将坐标从一个坐标系转换到另一个坐标系是很有帮助的</li>
</ul>
</li>
<li>getDifferenceQuaternion(quaternionStart,quaternionEnd)<ul>
<li>返回一个[x,y,z,w]，start和end之间</li>
</ul>
</li>
</ul>
<h1 id="2-Controlling-a-Robot"><a href="#2-Controlling-a-Robot" class="headerlink" title="2 - Controlling a Robot"></a>2 - Controlling a Robot</h1><h2 id="2-1-Base，Joints，Links"><a href="#2-1-Base，Joints，Links" class="headerlink" title="2.1 Base，Joints，Links"></a>2.1 Base，Joints，Links</h2><p>常规link在[0.. getnumnodes()]范围内有link索引，因为base不是常规的“link”，所以使用-1作为base的link索引。采用的惯例是，joint frames相对于the parents center of mass <strong>inertial frame</strong>（惯性坐标系）表示，which is aligned with（对其） the principle axis of inertia</p>
<ul>
<li>getNumJoints(bodyUniqueId)<ul>
<li>返回一个表示关节数的整数</li>
</ul>
</li>
<li>getJointInfo(bodyUniqueId, jointIndex)<ul>
<li>返回一个信息的 list，</li>
</ul>
</li>
</ul>
<h2 id="2-2-控制关节运动模式"><a href="#2-2-控制关节运动模式" class="headerlink" title="2.2 控制关节运动模式"></a>2.2 控制关节运动模式</h2><ul>
<li>setJointMotorControl2() setJointMotorControlArray()<ul>
<li>可以通过设置一个或多个关节马达的控制模式来控制机器人。在stepSimulation过程中，物理引擎将模拟电机以达到给定的目标值，该目标值可以在最大电机力和其他约束条件下达到。</li>
<li>默认情况下，每个转动关节（revolute joint）和移动关节（prismatic joint）都使用一个速度电机来驱动。可以使用最大力0来禁用这些默认电机。这将使你执行扭矩控制。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maxForce = <span class="number">0</span> <span class="comment"># 也可以使用一个小的非零力来模拟关节摩擦</span></span><br><span class="line">mode = p.VELCITY_CONTROL</span><br><span class="line">p.setJointMotorControl2(objUid, jointIndex, controlMode = model, force = maxForce)</span><br><span class="line"><span class="comment"># 如果想让轮子以最大力来保持恒定的速度，可以使用：</span></span><br><span class="line">maxForce = <span class="number">500</span></span><br><span class="line">p.setJointMotorControl2(bodyUniqueId = objUid, </span><br><span class="line">                        jointIndex = <span class="number">0</span>, </span><br><span class="line">                        controlMode = p.VELOCITY_CONTROL, </span><br><span class="line">                        targetVelocity = targetVel, </span><br><span class="line">                        force = maxForce)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>从loadURDF()等返回的唯一Id</td>
</tr>
<tr>
<td>R</td>
<td>jointIndex</td>
<td>int</td>
<td>link索引，范围在[0..getNumJoints(Id)]，注意link索引==joint索引</td>
</tr>
<tr>
<td>R</td>
<td>controlMode</td>
<td>int</td>
<td>POSITION_CONTROL, VELOCITY_CONTROL, TORQUE_CONTROL</td>
</tr>
<tr>
<td>O</td>
<td>targetPosition</td>
<td>float</td>
<td>在POSITION_CONTROL模式中，是joint的目标位置</td>
</tr>
<tr>
<td>O</td>
<td>targetVelocity</td>
<td>float</td>
<td>在POSITION_CONTROL, VELOCITY_CONTROL中joint的期望速度</td>
</tr>
<tr>
<td>O</td>
<td>force</td>
<td>float</td>
<td>在POSITION_CONTROL, VELOCITY_CONTROL中是达到目标值所使用的最大电机力，在TORQUE_CONTROL中，这是施加于每个stepSimulation的力/扭矩</td>
</tr>
<tr>
<td>O</td>
<td>maxVelocity</td>
<td>float</td>
<td>在POSITION_CONTROL中，它将速度限制为最大值</td>
</tr>
</tbody></table>
<br>
一般来说，最好使用VELOCITY_CONTROL或POSITION_CONTROL。由于模拟正确的力依赖于非常精确的URDF/SDF文件参数和系统识别(正确的质量、惯量、质心位置、关节摩擦等)，所以做扭矩控制(力控制)要困难得多

<ul>
<li><p>setJointMotorControlArray()</p>
<ul>
<li>可以为输入传递数组，而不是对每个关节进行单独调用，从而显著减少调用开销,参数和setJointMotorControl2()一样，除了用除了用list of int 代替 int</li>
</ul>
</li>
<li><p>setJointMotorControlMultiDofArray() <strong>umanoidMotionCapture.py</strong></p>
</li>
</ul>
<h2 id="2-3-获取关节信息"><a href="#2-3-获取关节信息" class="headerlink" title="2.3 获取关节信息"></a>2.3 获取关节信息</h2><p>可以使用getJointState()从关节查询几个状态变量，如关节位置、速度、关节反作用力和关节电机扭矩</p>
<ul>
<li>getJointState() 输入参数：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>jointIndex</td>
<td>int</td>
<td>link索引</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>getJointState() 返回：</li>
</ul>
<table>
<thead>
<tr>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>jointPosition</td>
<td>float</td>
<td>joint的位置</td>
</tr>
<tr>
<td>jointVelocity</td>
<td>float</td>
<td>joint的速度值</td>
</tr>
<tr>
<td>jointReactionForces</td>
<td>list of 6 floats</td>
<td>这些是联合反作用力，如果力矩传感器对这个关节启用，则为[Fx, Fy, Fz, Mx, My, Mz]。没有扭矩传感器，则为[0,0,0,0,0]</td>
</tr>
<tr>
<td>appliedJointMotorTorque</td>
<td>float</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>getJointStates():</p>
<ul>
<li>getJointStates是getJointState的数组版本。不是传入单个jointIndex，而是传入一个jointIndex列表。</li>
</ul>
</li>
<li><p>getJointState(s)MultiDof():</p>
<ul>
<li>对于球形关节，还有getJointStateMultiDof</li>
<li>getJointStatesMultiDof允许查询多个关节状态，包括多关节(球形)</li>
</ul>
</li>
<li><p>resetJointState()</p>
<ul>
<li>可以重置关节的状态。最好在一开始就这样做，而不运行模拟:resetJointState覆盖所有的物理模拟。注意，但目前只支持1自由度的机动关节，即滑动关节或转动关节。</li>
</ul>
</li>
<li><p>resetJointState(s)MultiDof()</p>
<ul>
<li>一次重置多个关节。</li>
</ul>
</li>
<li><p>enableJointForceTorqueSensor()</p>
<ul>
<li>可以在每个关节上启用或禁用一个关节力/扭矩传感器</li>
</ul>
</li>
</ul>
<h2 id="2-4-关节状态"><a href="#2-4-关节状态" class="headerlink" title="2.4 关节状态"></a>2.4 关节状态</h2><ul>
<li>getLinkState(s)<ul>
<li>可以使用getLinkState查询每个link的质心在笛卡尔坐标系的位置和方向。</li>
</ul>
</li>
</ul>
<p>输入参数：</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniquedId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引</td>
</tr>
<tr>
<td>O</td>
<td>computeLinkVelocity</td>
<td>int</td>
<td>如果=1，笛卡尔世界速度会被计算并返回</td>
</tr>
<tr>
<td>O</td>
<td>computeForwardKinematics</td>
<td>int</td>
<td>如果=1,笛卡尔世界的位置和方向会被重新计算，通过正向运动学</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>返回值:</p>
<table>
<thead>
<tr>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>linkWorldPosition</td>
<td>vec3,list of 3 floats</td>
<td>质心的笛卡尔位置</td>
</tr>
<tr>
<td>linkWorldOrientation</td>
<td>vec4,list of 4 floats</td>
<td>质心的笛卡尔方向，四元组形式</td>
</tr>
<tr>
<td>localInertialFramePosition</td>
<td>vec3, list of 3 floats</td>
<td>在URDF link frame中表示的惯性系(质心)的局部位置偏移量</td>
</tr>
<tr>
<td>localInertialFrameOrientation</td>
<td>vec4, list of 4 floats</td>
<td>在URDF link frame中表示的惯性系(质心)的局部方向(四元数)偏移量</td>
</tr>
<tr>
<td>worldLinkFramePosition</td>
<td>vec3,list of floats</td>
<td>URDF link frame的 world 位置</td>
</tr>
<tr>
<td>worldLinkFrameOrientation</td>
<td>vec4,list of 4 floats</td>
<td>URDF link frame的 world 方向</td>
</tr>
<tr>
<td>worldLinkLinearVelocity</td>
<td>vec3,list of 3 floats</td>
<td>笛卡尔世界速度，仅当computeLinkVelocity非零时返回</td>
</tr>
<tr>
<td>worldLinkAngularVelocity</td>
<td>vec3,list of 3 floats</td>
<td>笛卡尔世界速度，仅当computeLinkVelocity非零时返回</td>
</tr>
</tbody></table>
<p>URDF link frame 和 the center of mass frame (both in world space) 的关系是: urdfLinkFrame = comLinkFrame * localInertialFrame.inverse().</p>
<ul>
<li>getLinkStates() <ul>
<li>getLinkStates将返回多个link的信息。代替linkIndex，它将接受linkIndices作为一个int类型的列表，这可以通过减少多次调用getLinkState的调用开销来提高性能</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Example Scripts</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>examples/pybullet/tensorflow/humanoid_running.py</td>
<td>加载一个类人，使用一个训练好的神经网络控制运行使用TensorFlow，由OpenAI训练</td>
</tr>
<tr>
<td>examples/pybullet/gym/pybullet_envs/bullet/minitaur.py and minitaur_gym_env.py</td>
<td>OpenAI GYM和TensorFlow的Minitaur环境</td>
</tr>
<tr>
<td>examples/pybullet/examples/quadruped.py</td>
<td>从URDF文件加载一个四足机器人，步进模拟，基于正弦波控制电机进行简单的跳跃步态。使用p.startStateLogging将状态记录到文件中</td>
</tr>
<tr>
<td>examples/quadruped_playback.py</td>
<td>创建一个四足机器人(Minitaur)，读取日志文件并设置位置作为运动控制目标。</td>
</tr>
<tr>
<td>examples/pybullet/examples/testrender.py</td>
<td>加载URDF文件并渲染图像，获取像素(RGB，深度，分割掩码)并使用MatPlotLib显示图像。</td>
</tr>
<tr>
<td>examples/pybullet/examples/testrender_np.py</td>
<td>与testrender相似。但是使用NumPy数组加速像素传输。还包括简单的基准/计时。</td>
</tr>
<tr>
<td>examples/pybullet/examples/saveWorld.py</td>
<td>将对象的状态(位置、方向)保存到pybullet Python脚本中。这主要用于在VR中设置场景并保存初始状态。不是所有的状态都是序列化的。</td>
</tr>
<tr>
<td>examples/pybullet/examples/inverse_kinematics.py</td>
<td>展示如何使用calculateinverse运动学命令，创建一个Kuka手臂时钟</td>
</tr>
<tr>
<td>xamples/pybullet/examples/rollPitchYaw.py</td>
<td>演示如何使用滑块GUI小部件</td>
</tr>
<tr>
<td>examples/pybullet/examples/constraint.py</td>
<td>以编程方式在link之间创建约束。</td>
</tr>
<tr>
<td>examples/pybullet/examples/vrhand.py</td>
<td>使用VR手套控制一只手，由VR控制器跟踪</td>
</tr>
</tbody></table>
<h2 id="2-5-Base-速度"><a href="#2-5-Base-速度" class="headerlink" title="2.5 Base 速度"></a>2.5 Base 速度</h2><ul>
<li>getBaseVelocity(Id)<ul>
<li>可以使用getBaseVelocity获得物体底部的线速度和角速度</li>
<li>这将返回一个包含两个vector的3值的列表，表示笛卡尔世界空间坐标下的线速度[x,y,z]和角速度[wx,wy,wz]。</li>
</ul>
</li>
<li>resetBaseVelocity(Id)<ul>
<li>使用resetBaseVelocity重置物体的线速度或角速度</li>
</ul>
</li>
</ul>
<h2 id="2-6-给力-applyExternalForce-Torque"><a href="#2-6-给力-applyExternalForce-Torque" class="headerlink" title="2.6 给力 applyExternalForce/Torque"></a>2.6 给力 applyExternalForce/Torque</h2><p>可以使用applyExternalForce和applyExternalTorque向物体施加一个力或扭矩。请注意，此方法仅在使用stepSimulation显式步进模拟时有效，换句话说:setRealTimeSimulation(0)。在每一个模拟步骤之后，外力被清除为零。如果你使用’setRealTimeSimulation(1)， applyExternalForce/Torque将有未定义的行为(either 0, 1 or multiple force/torque applications)。</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引或者是代表base的-1</td>
</tr>
<tr>
<td>R</td>
<td>forceObj</td>
<td>vec3f</td>
<td>要施加的力/扭矩矢量[x,y,z]。坐标系见flags</td>
</tr>
<tr>
<td>R</td>
<td>posObj</td>
<td>vec3f</td>
<td>在link上受力的位置，只有applyExternalForce可用，坐标系见flags</td>
</tr>
<tr>
<td>R</td>
<td>flags</td>
<td>int</td>
<td>指定力/位置的坐标系,WORLD_FRAME表示笛卡尔世界坐标，LINK_FRAME表示局部link坐标坐标系。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="2-7-物体"><a href="#2-7-物体" class="headerlink" title="2.7 物体"></a>2.7 物体</h2><ul>
<li>getNumBodies<ul>
<li>getNumBodies将返回物理服务器中物体的总数量。</li>
<li>如果使用过’getNumBodies’,可以使用getBodyUniqueId查询物体id。</li>
<li>所有的api都已经返回物体唯一id，所以如果要跟踪它们，通常不需要使用getBodyUniqueId。</li>
</ul>
</li>
<li>getBodyInfo<ul>
<li>返回base的名字</li>
</ul>
</li>
<li>syncBodyInfo<ul>
<li>syncBodyInfo会同步物体信息(getBodyInfo)，如果多个客户端连接到一个物理服务器改变world(loadURDF, removeBody等)。</li>
</ul>
</li>
<li>removeBody<ul>
<li>通过Id移除物体</li>
</ul>
</li>
</ul>
<h2 id="2-6-约束-constraint-py"><a href="#2-6-约束-constraint-py" class="headerlink" title="2.6 约束 constraint.py"></a>2.6 约束 <strong>constraint.py</strong></h2><ul>
<li>createConstraint() <ul>
<li>URDF、SDF和MJCF将articulated bodies指定为没有循环的树形结构。createConstraint() 允许你连接bodies的特定links来关闭这些循环。<strong>quadruped.py</strong> </li>
<li>可以在对象之间以及对象与特定世界坐标系之间创建任意约束。<strong>constraint.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>parentBodyUniqueId</td>
<td>int</td>
<td>parent body ID</td>
</tr>
<tr>
<td>R</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>parent link索引或者是-1(base)</td>
</tr>
<tr>
<td>R</td>
<td>childBodyUniqueId</td>
<td>int</td>
<td>child body Id，或者是-1表示no body</td>
</tr>
<tr>
<td>R</td>
<td>childLinkIndex</td>
<td>int</td>
<td>child link索引或者是-1(base)</td>
</tr>
<tr>
<td>R</td>
<td>jointType</td>
<td>int</td>
<td>JOINT_PRISMATIC, JOINT_FIXED, JOINT_POINT2POINT, JOINT_GEAR</td>
</tr>
<tr>
<td>R</td>
<td>jointAxis</td>
<td>vec3f</td>
<td>joint axis, in child link frame</td>
</tr>
<tr>
<td>R</td>
<td>parentFramePosition</td>
<td>vec3f</td>
<td>相对于parent质心frame的joint frame的位置</td>
</tr>
<tr>
<td>R</td>
<td>childFramePosition</td>
<td>vec3f</td>
<td>joint frame相对于给定子质心的frame位置(如果没有指定子质心frame，则为world原点)</td>
</tr>
<tr>
<td>O</td>
<td>parentFrameOrientation</td>
<td>vec4f</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>childFrameOrientation</td>
<td>vec4f</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>createConstraint()将返回一个整数唯一id，可用于更改或删除约束。在 <strong>examples/pybullet/examples/mimicJointConstraint.py</strong> 中可以看到JOINT_GEAR的例子，在 <strong>examples/pybullet/examples/minitaur.py</strong> 中可以看到JOINT_POINT2POINT的例子，在 <strong>examples/pybullet/examples/constraint.py</strong> 中可以看到JOINT_FIXED的例子。</p>
<ul>
<li>changeConstraint()<ul>
<li>可以用来更改现有约束的参数</li>
<li></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>userConstraintUniqueId</td>
<td>int</td>
<td>由createConstraint返回的Id</td>
</tr>
<tr>
<td>O</td>
<td>JointChildPivot</td>
<td>vec3f</td>
<td>更新子pivot</td>
</tr>
<tr>
<td>O</td>
<td>JointChildFrameOrientation</td>
<td>vec4f</td>
<td>更新子frame方位,四元组形式</td>
</tr>
<tr>
<td>O</td>
<td>maxForce</td>
<td>float</td>
<td>约束所能施加的最大力</td>
</tr>
<tr>
<td>O</td>
<td>gearRatio</td>
<td>float</td>
<td>两个齿轮的转速之比</td>
</tr>
<tr>
<td>O</td>
<td>gearAuxLink</td>
<td>int</td>
<td>在某些情况下，例如差速传动，第三个(辅助)link被用作参考姿态。见<strong>examples/pybullet/examples/racecar_differential.py</strong></td>
</tr>
<tr>
<td>O</td>
<td>relativePositionTarget</td>
<td>float</td>
<td>两个齿轮之间的相对位置目标偏移量</td>
</tr>
<tr>
<td>O</td>
<td>erp</td>
<td>float</td>
<td>约束误差减小参数</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>See also <strong>Bullet/examples/pybullet/examples/constraint.py</strong></p>
<ul>
<li>removeConstraint()</li>
</ul>
<p>removeConstraint 会移除一个约束, 返回它的唯一Id，它的输入参数为：</p>
<table>
<thead>
<tr>
<th></th>
<th>parameter</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>userConstraintUniqueId</td>
<td>int</td>
<td>createConstraint返回的id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>getNumConstraints(), getConstraintUniqueId()</p>
<ul>
<li>可以查询 使用“createConstraint”创建的约束的总数。</li>
</ul>
</li>
<li><p>getConstraintUniqueId()</p>
<ul>
<li>getConstraintUniqueId()将在范围[0..getNumConstraints()]，约束的唯一id可能不是连续的，因为可能会删除约束。输入是int serial index。</li>
</ul>
</li>
<li><p>getConstraintInfo/State</p>
<ul>
<li>可以查询约束信息，并给出约束唯一id</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>constraintUniqueId</td>
<td>int</td>
<td>createConstraint得到的唯一Id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>parentBodyUniqueId</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>parentJointIndex</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>childBodyUniqueId</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>childLinkIndex</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>constraintType</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointAxis</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointPivotInParent</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointPivotInChild</td>
<td>vec3f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointFrameOrientationParent</td>
<td>vec4f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>jointFrameOrientationChild</td>
<td>vec4f</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>maxAppliedForce</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>gearRatio</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>gearAuxLink</td>
<td>int</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>relativePositionTarget</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
<tr>
<td>erp</td>
<td>float</td>
<td>see createConstraint</td>
</tr>
</tbody></table>
<ul>
<li>getConstraintState()<ul>
<li>给出约束唯一id，可以在最近的模拟步骤中查询应用的约束力。输入是一个约束唯一id，输出是一个约束力向量，其维度是受约束影响的自由度(例如，固定约束影响6自由度)。</li>
</ul>
</li>
</ul>
<h2 id="2-7-动力-Dynamics"><a href="#2-7-动力-Dynamics" class="headerlink" title="2.7 动力 Dynamics"></a>2.7 动力 Dynamics</h2><ul>
<li>getDynamicsInfo()<ul>
<li>可以得到关于质量，质心，摩擦和其他属性的base和links。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link(joint)索引或者-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Returned Value</th>
<th>type</th>
<th>descriotion</th>
</tr>
</thead>
<tbody><tr>
<td>mass</td>
<td>double</td>
<td>单位kg</td>
</tr>
<tr>
<td>lateral_friction</td>
<td>double</td>
<td>摩擦系数</td>
</tr>
<tr>
<td>local inertia diagonal</td>
<td>vec3f</td>
<td>Note that links and base are centered around the center of mass and aligned with the principal axes of inertia.</td>
</tr>
<tr>
<td>local inertial pos</td>
<td>vec3</td>
<td>position of inertial frame in local coordinates of the joint frame</td>
</tr>
<tr>
<td>local inertial orn</td>
<td>vec4</td>
<td>orientation of inertial frame in local coordinates of joint frame</td>
</tr>
<tr>
<td>restitution</td>
<td>double</td>
<td>恢复系数（e）是碰撞前后两物体沿接触处法线方向上的分离速度与接近速度之比，只与碰撞物体的材料有关</td>
</tr>
<tr>
<td>rolling friction</td>
<td>double</td>
<td>滚动摩擦系数,与接触法线正交</td>
</tr>
<tr>
<td>spinning friction</td>
<td>double</td>
<td>接触法线周围的旋转摩擦系数</td>
</tr>
<tr>
<td>contact damping</td>
<td>double</td>
<td>接触约束阻尼，如果没有则为-1</td>
</tr>
<tr>
<td>contact stiffness</td>
<td>double</td>
<td>接触约束刚度，如果没有则为-1</td>
</tr>
<tr>
<td>body type</td>
<td>int</td>
<td>1=rigid body, 2 = multi body, 3 = soft body</td>
</tr>
<tr>
<td>collision margin</td>
<td>double</td>
<td>advanced/internal/unsupported info.碰撞边缘的碰撞形状。碰撞边缘取决于形状类型，它是不一致的</td>
</tr>
</tbody></table>
<ul>
<li>changeDynamics()<ul>
<li>changeDynamics()可以改变属性，如质量，摩擦和恢复系数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引或-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>mass</td>
<td>double</td>
<td>改变link的mass</td>
</tr>
<tr>
<td>O</td>
<td>lateralFriction</td>
<td>double</td>
<td>横向(线性)接触摩擦</td>
</tr>
<tr>
<td>O</td>
<td>spinningFriction</td>
<td>double</td>
<td>接触法线周围的扭转摩擦</td>
</tr>
<tr>
<td>O</td>
<td>rollingFriction</td>
<td>double</td>
<td>扭转摩擦与接触法线正交(保持这个值非常接近于零，否则模拟会变得非常不现实。</td>
</tr>
<tr>
<td>O</td>
<td>restitution</td>
<td>double</td>
<td>接触的反弹力，让它略小于1，最好更接近0</td>
</tr>
<tr>
<td>O</td>
<td>linearDamping</td>
<td>double</td>
<td>link的线性阻尼(默认为0.04)</td>
</tr>
<tr>
<td>O</td>
<td>angularDamping</td>
<td>double</td>
<td>link的角阻尼(默认为0.04)</td>
</tr>
<tr>
<td>O</td>
<td>contactStiffness</td>
<td>double</td>
<td>接触约束的刚度，与接触阻尼一起使用</td>
</tr>
<tr>
<td>O</td>
<td>contactDamping</td>
<td>double</td>
<td>此bidy/link的接触约束的阻尼。与接触刚度一起使用。如果该值是在contact部分的URDF文件中指定的，那么它将覆盖该值。</td>
</tr>
<tr>
<td>O</td>
<td>frictionAnchor</td>
<td>int</td>
<td>启用或禁用friction anchor:摩擦漂移校正(默认禁用，除非在URDF接触部分设置)</td>
</tr>
<tr>
<td>O</td>
<td>localInertiaDiagnoal</td>
<td>vec3</td>
<td></td>
</tr>
<tr>
<td>。。。</td>
<td>。。。</td>
<td>。。。</td>
<td>。。。</td>
</tr>
</tbody></table>
<h2 id="2-8-模拟-Simulation"><a href="#2-8-模拟-Simulation" class="headerlink" title="2.8 模拟 Simulation"></a>2.8 模拟 Simulation</h2><ul>
<li>setTimeStep()<ul>
<li>在许多情况下，最好将timeStep保留为默认值，即240Hz。几个参数根据这个值进行了调优。例如，求解器迭代次数和接触、摩擦和非接触关节的误差减少参数(erp)都与时间步长有关。如果您更改了时间步长，您可能需要相应地重新调整这些值，特别是erp值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>timeStep</td>
<td>float</td>
<td>每次调用“stepSimulation”时，timeStep将继续执行“timeStep”</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>setPhysicsEngineParameter()<ul>
<li>通过setPhysicsEngineParameter API可以设置物理引擎参数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
</table>
<ul>
<li>setDefaultContactERP<ul>
<li>设置默认contact 参数，将被纳入setPhysicsEngineParameter API</li>
</ul>
</li>
</ul>
<ul>
<li>getPhysicsEngineParameters<ul>
<li>查询物理引擎参数</li>
</ul>
</li>
</ul>
<ul>
<li>resetSimulation<ul>
<li>从世界中移除所有对象，并将世界重置为初始条件。</li>
</ul>
</li>
</ul>
<h2 id="2-9-日志-logging"><a href="#2-9-日志-logging" class="headerlink" title="2.9 日志 logging"></a>2.9 日志 logging</h2><ul>
<li><p>startStateLogging</p>
<ul>
<li><p>该命令将返回一个非负的int loggingUniqueId，可以与stopStateLogging一起使用。</p>
</li>
<li><p>状态日志可以记录模拟的状态，比如在每个模拟步骤之后(在每次对stepSimulation的调用之后，或者在启用setRealTimesSimulation时在每个模拟步骤之后自动记录)一个或多个对象的状态。可以记录物体的轨迹。也可以选择记录body的共同状态，如基座位置和方向，关节位置(角度)和关节马达力。</p>
</li>
<li><p>所有使用startStateLogging生成的日志文件都可以使用c++或Python脚本读取。见<strong>quadruped_playback.py</strong>和<strong>kuka_with_cube_playback.py</strong>查看Python脚本读取日志文件</p>
</li>
<li><p>对于MP4视频的录制，可以使用记录选项STATE_LOGGING_VIDEO_MP4。</p>
</li>
<li><p>作为一个特例，PyBullet实现了Minitaur机器人的日志记录。PyBullet模拟的日志文件与真实的Minitaur四足动物日志文件相同。见<strong>Bullet/examples/pybullet/examples/logMinitaur.py</strong></p>
</li>
<li><p>重要提示:各种日志记录器包括它们自己的内部时间戳，创建时从0开始。这意味着需要同时启动所有的记录器，以保持同步。在启动记录器时，您需要确保模拟不是在实时模式下运行:在创建记录器之前使用pybullet.setRealTimesSimulation(0)。</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>loggingType</td>
<td>int</td>
<td>STATE_LOGGING_MINITAUR:quadruped.urdf 专用 <br>STATE_LOGGING_GENERIC_ROBOT:这将记录所有对象或所选对象的数据日志(如果提供了objectUniqueIds)<br>STATE_LOGGING_VIDEO_MP4:这将打开一个MP4文件，并开始使用ffmpeg管道将OpenGL 3D visualizer像素流到文件中。它需要安装ffmpeg。你也可以使用avconv (Ubuntu默认)，只需要创建一个符号链接，这样ffmpeg就可以指向avconv。在Windows上，ffmpeg有一些问题，导致撕裂/颜色工件在某些情况下<br>STATE_LOGGING_PROFILE_TIMINGS：这将转储一个JSON格式的计时文件，可以使用谷歌Chrome打开关于://跟踪加载<br>STATE_LOGGING_CONTACT_POINTS<br>STATE_LOGGING_VR_CONTROLLERS.</td>
</tr>
<tr>
<td>R</td>
<td>fileName</td>
<td>string</td>
<td>文件名(绝对或相对路径)用于存储日志文件数据。</td>
</tr>
<tr>
<td>O</td>
<td>objectUniqueIds</td>
<td>list of int</td>
<td>如果为空，记录器可能记录每个对象，否则记录器只记录objectUniqueIds列表中的对象。</td>
</tr>
<tr>
<td>O</td>
<td>maxLogDof</td>
<td>int</td>
<td>要记录的最大关节自由度数(不包括基自由度)。这适用于STATE_LOGGING_GENERIC_ROBOT_DATA。缺省值为12。如果一个机器人超过了dofs的数量，它根本不会被记录。</td>
</tr>
<tr>
<td>O</td>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及bodyUniqueIdA的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及bodyUniqueIdB的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录涉及linkIndexA bodyUniqueIdA的接触点</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>适用于STATE_LOGGING_CONTACT_POINTS。如果提供，只记录bodyUniqueIdA中涉及linkIndexB的接触点。</td>
</tr>
<tr>
<td>O</td>
<td>deviceTypeFilter</td>
<td>int</td>
<td>deviceTypeFilter允许您选择要记录的VR设备</td>
</tr>
<tr>
<td>O</td>
<td>logFlags</td>
<td>int</td>
<td>STATE_LOG_JOINT_TORQUES,记录由关节电机引起的关节力矩</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>stopStateLogging</p>
<ul>
<li>使用它的loggingUniqueId来停止logging</li>
</ul>
</li>
<li><p>submitProfileTime <strong>profile_Timing.py</strong></p>
<ul>
<li>允许插入开始和停止计时来分析Python代码</li>
</ul>
</li>
</ul>
<h1 id="3-Deformables-and-Cloth-using-FEM-PBD"><a href="#3-Deformables-and-Cloth-using-FEM-PBD" class="headerlink" title="3. Deformables and Cloth (using FEM, PBD)"></a>3. Deformables and Cloth (using FEM, PBD)</h1><p>Finite Element Method (FEM) 有限元法<br><br>position based dynamics（PBD）基于位置的模拟<br><br>可以通过如下方式重置世界来启用基于有限元法(FEM)的模拟：<br><strong>deformable_torus.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pybullet.resetSimulation(p.RESET_USE_DEFORMABLE_WORLD)</span><br></pre></td></tr></table></figure>

<ul>
<li>loadSoftBody/loadURDF<ul>
<li>从VTK或OBJ文件加载一个可变形的对象。</li>
</ul>
</li>
</ul>
<h1 id="4-Synthetic-Camera-Rendering"><a href="#4-Synthetic-Camera-Rendering" class="headerlink" title="4. Synthetic Camera Rendering"></a>4. Synthetic Camera Rendering</h1><p>PyBullet有一个内置的OpenGL GPU可视化工具和一个基于TinyRenderer的内置CPU渲染器。这使得从任意相机位置渲染图像变得非常容易。在Linux上，你也可以在没有X11上下文的情况下启用硬件加速的OpenGL渲染。<br><br><strong>eglRenderTest.py</strong><br><br>合成相机由两个4 × 4矩阵指定:视图矩阵和投影矩阵。由于这些不是很直观，有一些辅助方法来计算视图和投影矩阵从可理解的参数。<br><a href="http://ksimek.github.io/2013/08/13/intrinsic/" target="_blank" rel="noopener">http://ksimek.github.io/2013/08/13/intrinsic/</a></p>
<ul>
<li>computeView/ProjectionMatrix</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Inupt parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraEyePosition</td>
<td>vec3f</td>
<td>eye position在笛卡尔坐标系中</td>
</tr>
<tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>vec3f</td>
<td>目标(焦点)点的位置，以笛卡尔世界坐标表示</td>
</tr>
<tr>
<td>R</td>
<td>cameraUpVector</td>
<td>vec3f</td>
<td>在笛卡尔坐标系下，相机的up vector</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4视图矩阵，存储为包含16个浮点数的列表。<br></p>
<ul>
<li>computeViewMatrixFromYawPitchRoll</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>list of 3 f</td>
<td>目标焦点在笛卡尔世界坐标</td>
</tr>
<tr>
<td>R</td>
<td>distance</td>
<td>float</td>
<td>从eye到焦点的距离</td>
</tr>
<tr>
<td>R</td>
<td>yaw</td>
<td>float</td>
<td>yaw angle in degrees left/right around up-axis.</td>
</tr>
<tr>
<td>R</td>
<td>pitch</td>
<td>float</td>
<td>pitch in degrees up/down.</td>
</tr>
<tr>
<td>R</td>
<td>roll</td>
<td>float</td>
<td>roll in degrees around forward vector</td>
</tr>
<tr>
<td>R</td>
<td>upAxisIndex</td>
<td>int</td>
<td>Y轴是1,Z轴是2。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4视图矩阵，存储为包含16个浮点数的列表。</p>
<ul>
<li>computeProjectionMatrix</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>left</td>
<td>float</td>
<td>左屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>right</td>
<td>float</td>
<td>右屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>bottom</td>
<td>float</td>
<td>下方屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>top</td>
<td>float</td>
<td>上方屏幕(画布)坐标</td>
</tr>
<tr>
<td>R</td>
<td>near</td>
<td>float</td>
<td>近平面的距离</td>
</tr>
<tr>
<td>R</td>
<td>far</td>
<td>float</td>
<td>远平面的距离</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<p>输出是4x4投影矩阵，存储为一个包含16个浮点数的列表。</p>
<ul>
<li>computeProjectionMatrixFOV<ul>
<li>这个命令还将使用不同的参数返回一个4x4投影矩阵。你可以查看OpenGL文档了解这些参数的含义</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>fov</td>
<td>float</td>
<td>视野</td>
</tr>
<tr>
<td>R</td>
<td>aspect</td>
<td>float</td>
<td>纵横比；屏幕高宽比</td>
</tr>
<tr>
<td>R</td>
<td>nearVal</td>
<td>float</td>
<td>近平面的距离</td>
</tr>
<tr>
<td>R</td>
<td>farVal</td>
<td>flaot</td>
<td>远平面的距离</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>unused</td>
</tr>
</tbody></table>
<ul>
<li>getCameraImage<ul>
<li>getCameraImage API将返回一个RGB图像，一个深度缓冲区和一个分割掩码缓冲区，其中包含每个像素的可见对象的body unique id。请注意，PyBullet可以使用numpy选项进行编译:使用numpy将提高从C到Python复制摄像机像素的性能。注意:旧的renderImage API已经过时了，被getCameraImage所取代。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>width</td>
<td>int</td>
<td>以像素为单位的水平图像分辨率</td>
</tr>
<tr>
<td>R</td>
<td>height</td>
<td>int</td>
<td>以像素为单位的垂直图像分辨率</td>
</tr>
<tr>
<td>O</td>
<td>viewMatrix</td>
<td>16 floats</td>
<td>4x4视图矩阵，参见computeViewMatrix*</td>
</tr>
<tr>
<td>O</td>
<td>projectionMatrix</td>
<td>16 floats</td>
<td>4x4投影矩阵，参见computeProjection*</td>
</tr>
<tr>
<td>O</td>
<td>lightDirection</td>
<td>vec3f</td>
<td>lightDirection指定光源的世界位置，方向是从光源位置到世界框架的原点。</td>
</tr>
<tr>
<td>O</td>
<td>lightColor</td>
<td>vec3f</td>
<td>方向光颜色在[红，绿，蓝]范围0..1、仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightDistance</td>
<td>float</td>
<td>光沿归一化光方向的距离，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>shadow</td>
<td>int</td>
<td>1表示阴影，0表示没有阴影，只适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightAmbientCoeff</td>
<td>float</td>
<td>光环境系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightDiffuseCoeff</td>
<td>float</td>
<td>光漫反射系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>lightSpecularCoeff</td>
<td>float</td>
<td>光反射系数，仅适用于ER_TINY_RENDERER</td>
</tr>
<tr>
<td>O</td>
<td>renderer</td>
<td>int</td>
<td>ER_BULLET_HARDWARE_OPENGL或ER_TINY_RENDERER。注意，直接模式没有OpenGL，所以它需要ER_TINY_RENDERER。</td>
</tr>
<tr>
<td>O</td>
<td>flags</td>
<td>int</td>
<td>ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX，参见下面的segmentationMaskBuffer的描述和示例代码。使用ER_NO_SEGMENTATION_MASK来避免计算分割掩码。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>int</td>
<td>宽度图像分辨率(以像素为单位)(水平)</td>
</tr>
<tr>
<td>height</td>
<td>int</td>
<td>高度图像分辨率(以像素为单位)(垂直)</td>
</tr>
<tr>
<td>rgbPixel</td>
<td>list of [char RED,char GREEN,char BLUE, char ALPHA] [0..width*height]</td>
<td>R,G,B格式的像素颜色列表，范围[0..]每一种颜色</td>
</tr>
<tr>
<td>depthPixels</td>
<td>list of float [0..width*height]</td>
<td>depth buffer. Bullet uses OpenGL to render, and the convention is non-linear z-buffer.See <a href="https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer" target="_blank" rel="noopener">https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer</a> <br> far=1000. 取决于投影矩阵，这是默认的<br> near=0.01 取决于投影矩阵<br> depth = far<em>near/(far-(far-near)\</em>depthImg) depthImg是从getCameraImage函数得到的depth。demo见 <strong>pointCloudFromCameraImage.py</strong></td>
</tr>
<tr>
<td>segmentationMaskBuffer</td>
<td>list of int [0..width*height]</td>
<td>对于每个像素，可见对象的唯一id如果使用ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX, segmentationMaskBuffer将对象唯一id和链接索引结合如下:<br> value = objectUniqueId + (linkIndex+1)&lt;&lt;24 Demo见 <strong>segmask_linkindex.py</strong> <br>所以对于一个没有joints/links的自由浮动我要吐，分割掩码等于它本身的唯一id，因为它的link索引是-1。</td>
</tr>
</tbody></table>
<ul>
<li><p>isNumpyEnabled</p>
<ul>
<li>对于大图像，将像素从C/C++复制到Python可能会非常慢，除非使用NumPy编译PyBullet。可以使用PyBullet.isNumpyEnabled()检查是否启用了NumPy。如果系统上可用，则pip install pybullet启用了NumPy。目前，只有getCameraImage使用numpy加速。</li>
</ul>
</li>
<li><p>getVisualShapeData</p>
<ul>
<li>可以使用getVisualShapeData访问视觉形状信息。可以使用此方法将自己的呈现方法与PyBullet模拟连接起来，并在每个模拟步骤之后手动同步世界转换。也可以使用getMeshData来接收顶点位置的数据，特别是对于可变形的对象。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>O</td>
<td>flags</td>
<td>int</td>
<td>VISUAL_SHAPE_DATA_TEXTURE_UNIQUE_IDS也将提供textureUniqueId</td>
</tr>
<tr>
<td>O</td>
<td>pyhsicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Output parameters</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>objectUniqueId</td>
<td>int</td>
<td>Id,和输入参数相同</td>
</tr>
<tr>
<td>linkIndex</td>
<td>int</td>
<td>link索引或-1(base)</td>
</tr>
<tr>
<td>visualGeometryType</td>
<td>int</td>
<td>视觉几何类型(TBD)</td>
</tr>
<tr>
<td>dimentsions</td>
<td>vec3f</td>
<td>几何的尺寸(大小，局部比例尺)</td>
</tr>
<tr>
<td>meshAssetFileName</td>
<td>string,list of chars</td>
<td>triangle mesh的路径，如果有的话。通常是相对于URDF、SDF或MJCF文件位置，但也可以是绝对位置</td>
</tr>
<tr>
<td>localVisualFrame position</td>
<td>vec3f</td>
<td>局部visual frame相对于link/joint的位置</td>
</tr>
<tr>
<td>localVisualFrame orientation</td>
<td>vec4f</td>
<td>局部visual frame相对于link/joint的方向</td>
</tr>
<tr>
<td>rgbaColor</td>
<td>vec4f</td>
<td>URDF颜色(如果有指定)为红色/绿色/蓝色/alpha</td>
</tr>
<tr>
<td>textureUniqueId</td>
<td>int</td>
<td>(此字段仅在使用VISUAL_SHAPE_DATA_TEXTURE_UNIQUE_IDS标志时存在)纹理形状的唯一id，无时为-1</td>
</tr>
</tbody></table>
<p>物理模拟使用质心作为笛卡尔世界变换的参考，在getBasePositionAndOrientation和getLinkState中。如果实现自己的渲染，需要将局部视觉转换转换到世界空间，利用质心世界变换和(反向)localInertialFrame。可以使用getLinkState API访问localInertialFrame。</p>
<ul>
<li>changeVisualShape, loadTexture<ul>
<li>可以使用changeVisualShape来改变Shape的纹理、RGBA颜色和其他属性。</li>
</ul>
</li>
</ul>
<p>||Input Parameters|type|descriptions|<br>|R|objectUniqueId|int|Id|<br>|R|linkIndex|int|link索引|<br>|O|shapeIndex|int|对于内部使用的实验，建议忽略shapeIndex或将其保留为-1。其目的是让可以选择要修改的特定shape的索引，因为URDF（和SDF等）每个link可以有多个visual shape。此shapeIndex与getVisualShapeData返回的列表顺序匹配。|<br>|O|textureUniqueId|int|纹理的唯一id，由loadTexture方法返回|<br>|O|rgbaColor|vec4f|颜色组件为红色，绿色，蓝色和ALPHA，每个范围[0..1]。Alpha必须是0(不可见)或1(可见)。注意，TinyRenderer不支持透明，但是GUI/EGL OpenGL3渲染器支持。|<br>|O|specularColor|vec3|高光颜色成分，红、绿、蓝，可以从0到大的数(&gt;100)。|<br>|R|physicsClientId|int|物理客户端id由’connect’返回|</p>
<ul>
<li>loadTexture<ul>
<li>从文件中加载一个纹理，如果加载成功，返回一个非负的纹理唯一id。这个唯一的id可以与changeVisualShape一起使用。</li>
</ul>
</li>
</ul>
<h1 id="5-Collision-Detection-Queries-碰撞检测查询"><a href="#5-Collision-Detection-Queries-碰撞检测查询" class="headerlink" title="5. Collision Detection Queries 碰撞检测查询"></a>5. Collision Detection Queries 碰撞检测查询</h1><p>可以查询上次“stepSimulation”过程中存在的接触点信息。要获得接触点，你可以使用’getContactPoints’ API。请注意，’getContactPoints’将不会重新计算任何接触点信息。</p>
<ul>
<li>getOverlappingObjects<ul>
<li>此查询将返回与给定轴对齐边框重叠的轴对齐边框对象的所有唯一id。注意，该查询是保守的，可能返回没有实际AABB重叠的附加对象。这是因为加速结构有一些启发式，扩大了一点aabb(额外的边缘和挤压沿速度矢量)。</li>
<li>getOverlappingObjects将返回对象惟一id的列表。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>aabbMin</td>
<td>vec3f</td>
<td>aabb最小坐标</td>
</tr>
<tr>
<td>R</td>
<td>aabbMax</td>
<td>vec3f</td>
<td>aabb最大坐标</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>getAABB<ul>
<li>可以查询轴对齐的边界框(在世界空间中)，给定对象唯一id和link索引(可选)。(当不传递link索引，或使用-1，得到的是AABB的base)。</li>
<li>返回的结构是世界空间坐标下的vec3、aabbMin (x,y,z)和aabbMax (x,y,z)的列表。</li>
<li>AABB盒，一个3D的AABB就是一个简单的六面体，每一边都平行于一个坐标平面，矩形边界框不一定都是立方体，它的长、宽、高可以彼此不同。</li>
<li>坐标轴平行（Axially-aligned）不仅指盒体与世界坐标轴平行，同时也指盒体的每个面都和一条坐标轴垂直，这样一个基本信息就能减少转换盒体时操作的次数。</li>
<li><strong>getAABB.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Paramets</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id as returened by creation methods</td>
</tr>
<tr>
<td>O</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引，范围在[0…getNumJoints(..)]</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<ul>
<li>getContactPoints<ul>
<li>getContactPoints API返回在最近的stepSimulation调用中计算的接触点。请注意，如果在stepSimulation之后更改模拟的状态，“getContactPoints”不会被更新，而且可能是无效的。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Paramets</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>O</td>
<td>bodyA</td>
<td>int</td>
<td>只报告涉及A体的接触点</td>
</tr>
<tr>
<td>O</td>
<td>bodyB</td>
<td>int</td>
<td>只报告涉及B体的接触点。重要:如果你提供B体，你需要有一个有效的a体。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>只报告bodyA的linkIndexA接触点</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>只报告涉及bodyB的linkIndexB的接触点</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br><br>getContactPoints将返回一个接触点列表。每个接触点有以下字段:<br><br><br></p>
<table>
<thead>
<tr>
<th>Returned Values</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>contactFlag</td>
<td>int</td>
<td>reserved</td>
</tr>
<tr>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>物体A的Id</td>
</tr>
<tr>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>物体B的Id</td>
</tr>
<tr>
<td>linkIndexA</td>
<td>int</td>
<td>物体A的link索引，-1(base)</td>
</tr>
<tr>
<td>linkIndexB</td>
<td>int</td>
<td>物体B的link索引，-1(base)</td>
</tr>
<tr>
<td>positionOnA</td>
<td>vec3f</td>
<td>在笛卡尔世界坐标下，A上的接触位置</td>
</tr>
<tr>
<td>positionOnB</td>
<td>vec3f</td>
<td>在笛卡尔世界坐标下，B上的接触位置</td>
</tr>
<tr>
<td>contactNormalOnB</td>
<td>vec3f</td>
<td>B上的接触法线，指向A</td>
</tr>
<tr>
<td>contactDistance</td>
<td>float</td>
<td>接触距离，正的用于分离，负的用于渗透</td>
</tr>
<tr>
<td>nornalForce</td>
<td>float</td>
<td>在最后的“stepSimulation”中施加的法向力</td>
</tr>
<tr>
<td>lateralFriction1</td>
<td>float</td>
<td>lateralFrictionDir1方向上的横向摩擦力</td>
</tr>
<tr>
<td>lateralFrictionDir1</td>
<td>vec3f</td>
<td>第一横向摩擦方向</td>
</tr>
<tr>
<td>lateralFriction2</td>
<td>float</td>
<td>lateralFrictionDir2方向上的横向摩擦力</td>
</tr>
</tbody></table>
<p>|<br>|lateralFrictionDir2|float|lateralFrictionDir2方向上的横向摩擦力|<br><br><br></p>
<ul>
<li>getClosestPoints<ul>
<li>它也可以计算最近的点，独立于stepSimulation。这也可以让你用任意的分离距离计算物体的最近点。在这个查询中将没有正常的力报告。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyA</td>
<td>int</td>
<td>第一个物体A的Id</td>
</tr>
<tr>
<td>R</td>
<td>bodyB</td>
<td>int</td>
<td>第二个物体B的Id</td>
</tr>
<tr>
<td>R</td>
<td>distance</td>
<td>float</td>
<td>如果物体之间的距离超过这个最大距离，则不能返回任何点。</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexA</td>
<td>int</td>
<td>物体A的link索引, -1(base)</td>
</tr>
<tr>
<td>O</td>
<td>linkIndexB</td>
<td>int</td>
<td>物体B的link索引, -1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p>getClosePoints以与getContactPoints相同的格式返回最近点的列表(但normalForce在这种情况下总是为零)</p>
<ul>
<li>rayTest<ul>
<li>可以执行一个光线投射来找到第一个被击中的物体的交叉信息。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>rayFromPosition</td>
<td>vec3f</td>
<td>从世界坐标的光线开始</td>
</tr>
<tr>
<td>R</td>
<td>rayToPosition</td>
<td>vec3f</td>
<td>射线在世界坐标的末端</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>linkIndex</td>
<td>int</td>
<td>命中对象的link索引，if none/parent，则为-1</td>
</tr>
<tr>
<td>hit fraction</td>
<td>float</td>
<td>沿射线范围[0,1]内沿射线的hit fraction。</td>
</tr>
<tr>
<td>hit position</td>
<td>vec3f</td>
<td>笛卡尔世界坐标系下的hit position</td>
</tr>
<tr>
<td>hit normal</td>
<td>vec3f</td>
<td>笛卡尔世界坐标系下的hit position</td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>rayTestBatch<ul>
<li>这与rayTest类似，但允许提供一个射线数组，以更快地执行。rayFromPositions的大小需要等于rayToPositions的大小。可以每条射线都有一个射线结果，即使没有交集:你需要使用objectUniqueId字段来检查射线是否击中了任何东西:如果objectUniqueId是-1，就没有击中。在这种情况下，“hit fraction”是1。每批射线的最大数量是pybullet.MAX_RAY_INTERSECTION_BATCH_SIZE。</li>
<li>输出是每条输入射线的一条射线相交结果，信息与上面的rayTest查询相同。见 <strong>batchRayTest.py</strong> Demo<br>

</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>rayFromPositions</td>
<td>list of vec3,list of list of 3f</td>
<td>每个射线的起始点的列表，在世界坐标中</td>
</tr>
<tr>
<td>R</td>
<td>rayToPositions</td>
<td>list of vec3,list of list of 3f</td>
<td>每个射线的终点的列表，在世界坐标中</td>
</tr>
<tr>
<td>O</td>
<td>parentObjectUniquedId</td>
<td>int</td>
<td>ray from/to is in local space of a parent object</td>
</tr>
<tr>
<td>O</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>ray from/to is in local space of a parent object</td>
</tr>
<tr>
<td>O</td>
<td>numThreads</td>
<td>int</td>
<td>使用多个线程来计算射线测试(0 =使用所有可用的线程，正数=正好这个线程数，默认=-1 =单线程)</td>
</tr>
<tr>
<td>O</td>
<td>reportHitNumber</td>
<td>int</td>
<td>可以报告第n次hit，而不是第一次hit</td>
</tr>
<tr>
<td>O</td>
<td>collisionFilterMask</td>
<td>int</td>
<td>只有当collisionFilterMask和body collision filter组的按位和之间的值是非零时，才测试命中。请参阅setCollisionFilterGroupMask来了解如何修改主体过滤器的掩码/组。</td>
</tr>
<tr>
<td>O</td>
<td>fractionEpsilon</td>
<td>float</td>
<td>仅在使用reportHitNumber时有用:如果分数与这个fractionEpsilon中的现有命中率相似，则忽略重复命中率。例如，一束射线可能击中一个物体的许多共面三角形，你可能只对其中一个感兴趣。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>getCollisionShapeData<ul>
<li>可以使用此查询查询现有body base和links的碰撞几何类型和其他碰撞形状信息。它的工作原理与getVisualShapeData非常相似。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link索引,-1(base)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th>Retured Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>object unique id</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>linkIndex</td>
<td>int</td>
<td>link索引,-1(base)</td>
</tr>
<tr>
<td>geometry type</td>
<td>int</td>
<td>geometry type: GEOM_BOX, GEOM_SPHERE, GEOM_CAPSULE, GEOM_MESH, GEOM_PLANE</td>
</tr>
<tr>
<td>dimensions</td>
<td>vec3</td>
<td>取决于几何类型: <br>for GEOM_BOX: extents,<br> for GEOM_SPHERE dimensions[0] = radius,<br> for GEOM_CAPSULE and GEOM_CYLINDER, dimensions[0] = height (length), dimensions[1] = radius. <br>For GEOM_MESH, dimensions is the scaling factor.</td>
</tr>
<tr>
<td>filename</td>
<td>string</td>
<td>仅用于GEOM_MESH:collision mesh asset的文件名(和路径)</td>
</tr>
<tr>
<td>local frame pos</td>
<td>vec3</td>
<td>碰撞坐标系相对于质心/惯性坐标系的局部位置。</td>
</tr>
<tr>
<td>local frame orn</td>
<td>vec4</td>
<td>碰撞坐标系相对于惯性坐标系的局部方向。</td>
</tr>
</tbody></table>
<ul>
<li><p>Enable/Disable Collisions</p>
<ul>
<li>默认情况下，在不同动态移动的物体之间启用碰撞检测。同一body和links之间的自碰撞可以使用loadURDF中的  <strong>URDF_USE_SELF_COLLISION</strong>标志来启用(参见loadURDF命令获取更多信息)。</li>
<li>可以使用setCollisionFilterGroupMask API来启用和禁用对象组之间的碰撞检测。</li>
</ul>
</li>
<li><p>V-HACD</p>
<ul>
<li>PyBullet包含了一个由Khaled Mamou实现的体积分层近似分解(Volumetric Hierarchical Approximate Decomposition, vhacd)。这可以导入一个concave Wavefront .obj文件，并导出一个新的包含凸分解部分的Wavefront obj文件。这可以在PyBullet中使用，以有效地处理凹面移动几何图形</li>
<li>concave 凹的，凹面的</li>
<li>wavefront  波前；波阵面</li>
<li>对于静态的(非移动的)凹三角形网格环境，你可以在URDF文件中使用标签(<link concave ="yes" name="baseLink">)或使用带有标记的createCollisionShape,标记为p.GEOM_FORCE_CONCAVE_TRIMESH。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>fileNameIn</td>
<td>string</td>
<td>source (concave) Wavefront obj文件名</td>
</tr>
<tr>
<td>R</td>
<td>fileNameOut</td>
<td>string</td>
<td>目标(凸分解)Wavefront obj文件名</td>
</tr>
<tr>
<td>R</td>
<td>fileNameLog</td>
<td>string</td>
<td>日志文件名</td>
</tr>
<tr>
<td>O</td>
<td>concavity</td>
<td>double</td>
<td>最大允许凹度(default=0.0025, range=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>alpha</td>
<td>double</td>
<td>控制沿对称平面剪切的偏向(默认值=0.05，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>beta</td>
<td>double</td>
<td>控制沿旋转轴剪切的偏向(默认值=0.05，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>gamma</td>
<td>double</td>
<td>控制合并阶段允许的最大凹面(默认值=0.00125，范围=0.0-1.0)</td>
</tr>
<tr>
<td>O</td>
<td>minVolumePerCH</td>
<td>double</td>
<td>控制对生成的convex-hulls的自适应采样(默认值=0.0001，范围=0.0-0.01)</td>
</tr>
<tr>
<td>O</td>
<td>resolution</td>
<td>int</td>
<td>在体素化阶段生成的最大体素值(默认值=100,000，范围=10,000-16,000,000)</td>
</tr>
</tbody></table>
<p>|O|maxNumVerticesPerCH|int|控制每个convex-hull的最大三角形数(默认为64，范围为4-1024)<br>|O|depth|int|最大剪切段数。在每个分割阶段，凹度高于用户定义阈值的部分将根据最佳裁剪平面进行裁剪(默认为20，范围为1-32)|<br>|O|planeDownsampling|int|控制搜索\“最佳\”剪切平面的间隔尺寸(默认为4，范围为1-16)|<br>|O|convechullDownsamping|int|在剪切平面选择阶段控制convex-hull生成过程的精度(默认值=4，范围=1-16)|<br>|O|pca|int|在应用凸分解之前启用/禁用网格的规格化(默认值=0，范围={0,1})|<br>|O|mode|int|0:基于体素的近似凸分解，1:基于四面体的近似凸分解(默认为0,range={0,1})|<br>|O|convexhullApproximation|int|在计算凸壳时启用/禁用近似(默认值=1，范围={0,1})|<br>|O|physicsClientId|int||<br><br><br></p>
<ul>
<li>setCollisionFilterGroupMask<ul>
<li>每个body都是一个group的一部分。如果其他的body与mask匹配，它就会与之碰撞，反之亦然。下面的检查是使用两个body的group和mask进行的。这取决于碰撞过滤器模式</li>
<li>可以对特定link对之间的碰撞检测进行更细粒度的控制。这里使用setCollisionFilterPair API:可以启用或禁用碰撞检测。setCollisionFilterPair将覆盖过滤组/掩码和其他逻辑。<br>

</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>配置的Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexA</td>
<td>int</td>
<td>需要配置的body的linl索引</td>
</tr>
<tr>
<td>R</td>
<td>collisionFilterGroup</td>
<td>int</td>
<td>过滤器的bitwise group，参见下面的解释</td>
</tr>
<tr>
<td>R</td>
<td>collisionFilterMask</td>
<td>int</td>
<td>过滤器的bitwise mask，参见下面的解释</td>
</tr>
<tr>
<td>O</td>
<td>pyhsicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>setCollisionFilterPair</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueIdA</td>
<td>int</td>
<td>A的Id，被过滤后的</td>
</tr>
<tr>
<td>R</td>
<td>bodyUniqueIdB</td>
<td>int</td>
<td>B的Id，被过滤后的，A==B 意味着自碰撞</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexA</td>
<td>int</td>
<td>linkIndex of body A</td>
</tr>
<tr>
<td>R</td>
<td>linkIndexB</td>
<td>int</td>
<td>linkIndex of body B</td>
</tr>
<tr>
<td>R</td>
<td>enableCollision</td>
<td>int</td>
<td>1表示启用碰撞，0表示禁用碰撞</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<h1 id="6-Inverse-Dynamics-Kinematics"><a href="#6-Inverse-Dynamics-Kinematics" class="headerlink" title="6. Inverse Dynamics, Kinematics"></a>6. Inverse Dynamics, Kinematics</h1><h2 id="6-1-calculateInverseDynamics-2"><a href="#6-1-calculateInverseDynamics-2" class="headerlink" title="6.1 calculateInverseDynamics(2)"></a>6.1 calculateInverseDynamics(2)</h2><p>  calculateInverseDynamics将计算达到给定关节加速度所需的力，从指定的关节位置和速度开始。逆动力学计算使用递推牛顿欧拉算法(RNEA)。<br><br><br><br>  calculateInverseDynamics返回每个自由度的联合力列表。<br>注意，当涉及到多自由度(球形)关节时，calculateInverseDynamics使用不同的代码路径，会稍微慢一些。还要注意的是，calculateInverseDynamics忽略了joint/link阻尼，而正向动力学(在stepSimulation中)包含了这些阻尼项。所以如果想比较逆动力学和正动力学，确保将这些阻尼项设为零，使用带有关节阻尼和线性阻尼和角阻尼的连杆阻尼的变化动力学。</p>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>list of float</td>
<td>每个自由度(DoF)的关节位置(角)。注意，固定关节的自由度为0。base在所有情况下(浮动基座和固定基座)都会被跳过/忽略</td>
</tr>
<tr>
<td>R</td>
<td>objVelocities</td>
<td>list of float</td>
<td>每个自由度的关节速度</td>
</tr>
<tr>
<td>R</td>
<td>objAccelerations</td>
<td>list of float</td>
<td>每个自由度的期望关节加速度</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="6-2-calculateJacobian-MassMatrix"><a href="#6-2-calculateJacobian-MassMatrix" class="headerlink" title="6.2 calculateJacobian, MassMatrix"></a>6.2 calculateJacobian, MassMatrix</h2><ul>
<li>calculateJacobian<ul>
<li>calculateJacobian将计算link上一个点的平移和旋转雅可比矩阵，例如x_dot = J * q_dot。根据root link是固定的还是浮动的，返回的雅可比矩阵略有不同。如果是浮动的，雅可比矩阵将包括对应root link自由度的列;如果固定，雅可比矩阵就只有和joint相关的列。这个函数调用获得了运动学状态的完整描述，这是因为calculateInverseDynamics实际上是首先被调用的，并从中提取出所需的雅可比矩阵;因此，如果需要，通过关节速度和加速度的零向量是合理的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>int</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>雅可比矩阵的link索引</td>
</tr>
<tr>
<td>R</td>
<td>localPosition</td>
<td>list of float</td>
<td>给定link上的点，在其质心周围的link局部坐标中计算雅可比矩阵。</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>list of float</td>
<td>joint positions(angles)</td>
</tr>
<tr>
<td>R</td>
<td>objVelocities</td>
<td>list of float</td>
<td>joint velocities</td>
</tr>
<tr>
<td>R</td>
<td>objAccelerations</td>
<td>list of float</td>
<td>期望的joint加速度</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<table>
<thead>
<tr>
<th></th>
<th>CalculateJacobian Returns</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>linear Jacobian</td>
<td>mat3x((dof),(dof),dof))</td>
<td>the translational jacobian, x_dot = J_t * q_dot.</td>
</tr>
<tr>
<td>R</td>
<td>angular Jacobian</td>
<td>mat3x((dof),(dof),dof))</td>
<td>the rotational jacobian, r_dot = J_r * q_dot.</td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>calculateMassMatrix<ul>
<li>calculateMassMatrix将计算一个articulated body给定其joint位置的系统惯性。采用复合刚体算法(CBRA)计算质量矩阵。</li>
<li>Composite Rigid Body Algorithm, CBRA</li>
<li>结果是尺寸为dofCount * dofCount的质量方阵，存储为dofCount行列表，每一行是dofCount质量矩阵元素列表。</li>
<li>注意，当涉及到多自由度(球形)关节时，calculateMassMatrix将使用不同的代码路径，这有点慢。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>objPositions</td>
<td>array of float</td>
<td>jointPositions for each link</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="6-3-calculateInverseKinematics-2"><a href="#6-3-calculateInverseKinematics-2" class="headerlink" title="6.3 calculateInverseKinematics(2)"></a>6.3 calculateInverseKinematics(2)</h2><ul>
<li><p>Inverse Kinematics</p>
<ul>
<li>你可以计算使末端执行器达到笛卡尔世界空间中给定目标位置的joint angles。在内部，Bullet使用了Samuel Buss逆运动学库的改进版本。针对单末端执行器目标，目前只公开了带或不带零空间控制的阻尼最小二乘方法。</li>
<li>还可以指定末端执行器的目标方向。此外，还可以使用null-space来指定joint limits和rest poses。这个可选的null-space支持需要所有4个列(lowerLimits, upperLimits, jointRanges, restPoses),否则将使用常规的IK。</li>
<li><strong>inverse_kinematics.py</strong></li>
</ul>
</li>
<li><p>calculateInverseKinematics</p>
<ul>
<li>返回每个自由度的关节位置列表，因此这个列表的长度就是关节的自由度(跳过基本关节和固定关节)。</li>
<li>默认情况下，IK将refine解决方案，直到目标执行器与实际执行器之间的距离低于residual阈值(1e-4)或达到最大迭代次数。</li>
<li><strong>inverse_kinematics.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>endEffectorLinkIndex</td>
<td>int</td>
<td>末端执行器的link index</td>
</tr>
<tr>
<td>R</td>
<td>targetPosition</td>
<td>vec3f</td>
<td>末端执行器的目标位置(它的是link坐标,不是质心坐标!)默认情况下，这是在笛卡尔世界空间中，除非你提供了currentPosition joint angles)</td>
</tr>
<tr>
<td>O</td>
<td>targetOrientation</td>
<td>vec3,list of 4 floats</td>
<td>笛卡尔世界空间中的目标方向，四元数[x,y,w,z]。如果未指定，将使用纯位置IK。</td>
</tr>
<tr>
<td>O</td>
<td>lowerLimits</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.只提供有它们的关节的限制(跳过固定关节)，所以长度是自由度的数目.注意，lowerLimits, upperLimits, jointRanges很容易在IK解决方案中引起冲突和不稳定。首先，尝试使用一个广泛的范围和限制，with just the rest pose.</td>
</tr>
<tr>
<td>O</td>
<td>upperLimits</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.lowerLimit and upperLimit 指定 joint limits</td>
</tr>
<tr>
<td>O</td>
<td>jointRanges</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.</td>
</tr>
<tr>
<td>O</td>
<td>restPoses</td>
<td>list of floats [0..nDof]</td>
<td>可选的null-space IK需要所有4个列表(lowerLimits,upperLimits,jointRanges,restPoses).否则将使用常规IK.Favor an IK solution closer to a given rest pose</td>
</tr>
<tr>
<td>O</td>
<td>jointDamping</td>
<td>list of floats [0..nDof]</td>
<td>jointDamping允许使用joint阻尼因子来调整IK解决方案</td>
</tr>
<tr>
<td>O</td>
<td>solver</td>
<td>int</td>
<td>p.IK_DLS或p.IK_SDLS，阻尼最小二乘或选择性阻尼最小二乘，如Samuel Buss的论文“逆运动学的选择性阻尼最小二乘”所述。</td>
</tr>
<tr>
<td>O</td>
<td>currentPosition</td>
<td>list of floats [0..nDof]</td>
<td>list of joint  positions.默认情况下，PyBullet使用body的joint位置。如果提供了，the targetPosition and targetOrientation is in local space!</td>
</tr>
<tr>
<td>O</td>
<td>maxNumIterations</td>
<td>int</td>
<td>Refine the IK solution(细化IK解)，直到目标与实际末端执行器位置之间的距离低于这个阈值，或者达到最大迭代次数。默认为20次迭代</td>
</tr>
<tr>
<td>O</td>
<td>residualThreshold</td>
<td>double</td>
<td>Refine the IK solution(细化IK解)，直到目标与实际末端执行器位置之间的距离低于这个阈值，或者达到最大迭代次数。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>calculateInverseKinematics2<ul>
<li>类似于calculateInverseKinematics，但它接受一组末端执行器索引及其目标位置(此刻没有方向)。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>bodyUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>endEffectorLinkIndics</td>
<td>list of int</td>
<td>end effector link index</td>
</tr>
<tr>
<td>R</td>
<td>targetPositions</td>
<td>list of vec3</td>
<td>末端执行器的目标位置(它的link坐标，而不是质心坐标!)默认情况下，这是在笛卡尔世界空间中，除非你提供了currentPosition joint angles。</td>
</tr>
<tr>
<td>…</td>
<td>For other arguments,see calculateInverseSknematics</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><br><br></p>
<h1 id="7-Reinforcement-Learning-Gym-Envs"><a href="#7-Reinforcement-Learning-Gym-Envs" class="headerlink" title="7. Reinforcement Learning Gym Envs"></a>7. Reinforcement Learning Gym Envs</h1><p>在“pip install pybullet”期间安装了一套RL Gym环境。这包括PyBullet版本的OpenAI Gym Env，如ant, hopper, humanoid和walker。还有一些环境适用于模拟和真实的机器人，如Ghost<br>Robotics Minitaur quadruped，麻省理工赛车和库卡机器人手臂抓取环境。<br><br><br>pybullet, pybullet_envs, pybullet_data的源代码和示例: <a href="https://github.com/bulletphysics/bullet3/tree/master/examples/pybullet/gym" target="_blank" rel="noopener">https://github.com/bulletphysics/bullet3/tree/master/examples/pybullet/gym</a>.<br><br><br><br>可以使用RL训练算法来训练环境，例如DQN、PPO、TRPO和<br>DDPG。以下是一些经过训练的例子:<br><strong>python -m pybullet_envs.examples.enjoy_TF_HumanoidBulletEnv_v0_2017may</strong><br><strong>python -m pybullet_envs.examples.kukaGymEnvTest</strong></p>
<h2 id="7-1-Environments-and-Data"><a href="#7-1-Environments-and-Data" class="headerlink" title="7.1 Environments and Data"></a>7.1 Environments and Data</h2><h2 id="7-2-Stable-Baselines-amp-ARS-Es-…"><a href="#7-2-Stable-Baselines-amp-ARS-Es-…" class="headerlink" title="7.2 Stable Baselines &amp; ARS,Es,…"></a>7.2 Stable Baselines &amp; ARS,Es,…</h2><h1 id="8-Virtual-Reality"><a href="#8-Virtual-Reality" class="headerlink" title="8. Virtual Reality"></a>8. Virtual Reality</h1><h1 id="9-Debug-GUI-Lines-Text-Parameters"><a href="#9-Debug-GUI-Lines-Text-Parameters" class="headerlink" title="9. Debug GUI, Lines, Text, Parameters"></a>9. Debug GUI, Lines, Text, Parameters</h1><p>PyBullet有一些功能，可以更容易地调试、可视化和调优模拟。<br>这个功能只有在有一些3D可视化窗口时才有用，例如GUI模式或连接到单独的物理服务器(例如“物理服务器”模式的浏览器或独立的OpenGL GUI物理服务器)。</p>
<h2 id="9-1-addUserDebugLine-Text-Parameter"><a href="#9-1-addUserDebugLine-Text-Parameter" class="headerlink" title="9.1 addUserDebugLine, Text, Parameter"></a>9.1 addUserDebugLine, Text, Parameter</h2><ul>
<li>addUserDebugline  <ul>
<li>可以添加由3d起始点(从)和结束点(到)指定的3d线条，以及颜色<br>(红、绿、蓝)，线宽和持续时间(以秒为单位)。</li>
<li>addUserDebugLine将返回一个非负的唯一id，它允许使用removeUserDebugItem删除这个line。(当使用’replaceItemUniqueId’参数时，它将返回replaceItemUniqueId)。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>lineFromXYZ</td>
<td>vec3f</td>
<td>直线在笛卡尔世界坐标中的起始点</td>
</tr>
<tr>
<td>R</td>
<td>lineToXYZ</td>
<td>vec3f</td>
<td>直线在笛卡尔世界坐标中的终点</td>
</tr>
</tbody></table>
<p>|O|lineColorRGB|vec3f|RGB颜色[红、绿、蓝]范围内各分量<br>(0…1)|<br>|O|lineWidth|float|线宽(受OpenGL实现限制)|<br>|O|lifeTime|float|使用0为永久线路，或正时间秒<br>(之后会自动删除一行)|<br>|O|parentObjectUniqueId|int|即将到来的PyBullet 1.0.8新增功能:在parent object/link局部坐标中绘制直线。|<br>|O|replaceItemUniqueId|int|替换现有的line(以提高性能和避免移除/添加的闪烁)参见<strong>f10_racecar.py</strong>示例。|<br>|O|physicsClientId|int||</p>
<p><br><br></p>
<ul>
<li>addUserDebugText<ul>
<li>可以使用颜色和大小在特定位置添加一些3d文本</li>
<li>addUserDebugText将返回一个非负的唯一id，它允许你使用removeUserDebugItem删除行</li>
<li>See also <strong>pybullet/examples/debugDrawItems.py</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>text</td>
<td>text</td>
<td>表示为字符串(字符数组)的文本</td>
</tr>
<tr>
<td>R</td>
<td>textPosition</td>
<td>vec3f</td>
<td>文本在笛卡尔世界坐标中的三维位置[x, y, z]</td>
</tr>
<tr>
<td>O</td>
<td>textColorRGB</td>
<td>vec3f</td>
<td>RGB颜色[红、绿、蓝]范围内各分量(0 . . 1)</td>
</tr>
<tr>
<td>O</td>
<td>textSize</td>
<td>float</td>
<td>Text大小</td>
</tr>
<tr>
<td>O</td>
<td>lifeTime</td>
<td>float</td>
<td>为永久文本使用0，或以秒为单位的正时间(之后文本将自动删除)</td>
</tr>
<tr>
<td>O</td>
<td>textOrientation</td>
<td>vec4f</td>
<td>默认情况下，调试文本将始终面向摄像头，自动旋转。通过指定文本方向(四元数)，定向将固定在世界空间或局部空间(当parent指定时)。注意，不同的实现/着色器用于面向摄像机的文本，具有不同的外观:面向摄像机的文本使用位图字体，指定方向的文本使用TrueType字体。</td>
</tr>
<tr>
<td>O</td>
<td>parentObjectUniquedId</td>
<td>int</td>
<td>即将到来的PyBullet 1.0.8新增功能:在parent object/link的局部坐标中绘制直线。</td>
</tr>
<tr>
<td>O</td>
<td>parentLinkIndex</td>
<td>int</td>
<td>即将到来的PyBullet 1.0.8新增功能:在parent object/link的局部坐标中绘制直线。</td>
</tr>
<tr>
<td>O</td>
<td>replaceItemUniqueId</td>
<td>int</td>
<td>替换现有的文本项(以避免移除/添加的闪烁)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>addUserDebugParameter<ul>
<li>：addUserDebugParameter允许你添加自定义滑块和按钮来调整参数。它将返回一个唯一的id。这使用readUserDebugParameter读取参数的值。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>paramName</td>
<td>string</td>
<td>参数名</td>
</tr>
<tr>
<td>R</td>
<td>rangeMin</td>
<td>float</td>
<td>最小值。如果最小值&gt;最大值将出现一个按钮而不是滑块</td>
</tr>
<tr>
<td>R</td>
<td>rangeMax</td>
<td>float</td>
<td>最大值</td>
</tr>
<tr>
<td>R</td>
<td>startValue</td>
<td>float</td>
<td>开始值</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>readUserDebugParameter<ul>
<li>对于滑块，返回值是该参数的最新读取值。对于按钮，每按一次按钮，按钮的getUserDebugParameter的值增加1。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>itemUniqueId</td>
<td>int</td>
<td>由’addUserDebugParameter’返回的唯一id</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.addUserDebugParameter(<span class="string">"button"</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">p.addUserDebugParameter(<span class="string">"my_slider"</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<br>
<br>

<ul>
<li><p>removeAllUserParameters</p>
<ul>
<li>这将删除所有滑块和按钮</li>
<li>| O | physicsClient | int | … |</li>
</ul>
</li>
<li><p>removeUserDebugItem/All</p>
<ul>
<li>函数添加user debug lines ，如果成功，文本将返回一个非负的唯一id。可以使用removeUserDebugItem这个惟一id删除调试项</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>itemUniquedId</td>
<td>int</td>
<td>要删除的调试项的唯一id(line, text etc)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>removeAllUserDebugItems</p>
<ul>
<li>删除所有debug items (text, lines etc)</li>
</ul>
</li>
<li><p>setDebugObjectColor</p>
<ul>
<li>内置的OpenGL可视化工具有一个线框调试渲染特性:按“w”键切换。<br>线框有一些默认颜色。可以使用setDebugObjectColor覆盖特定对象的颜色和link</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>objectUniqueId</td>
<td>int</td>
<td>Id</td>
</tr>
<tr>
<td>R</td>
<td>linkIndex</td>
<td>int</td>
<td>link 索引</td>
</tr>
<tr>
<td>O</td>
<td>objectDebugColorRGB</td>
<td>vec3f</td>
<td>调试颜色为[红，绿，蓝]。如果不提供，自定义颜色将被删除。</td>
</tr>
<tr>
<td>O</td>
<td>physicsClient</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<br>

<h2 id="9-2-addUserData"><a href="#9-2-addUserData" class="headerlink" title="9.2 addUserData"></a>9.2 addUserData</h2><ul>
<li><p>addUserData</p>
<ul>
<li>简而言之，添加、删除和查询用户数据，此时文本字符串，附加到主体的任何链接上。请参阅userData.py示例了解如何使用它。它将返回一个userDataId。注意，您还可以在urdf文件中添加用户数据。</li>
</ul>
</li>
<li><p>getUserData</p>
<ul>
<li>getUserData将根据addUserData返回的userDataId接收用户数据。</li>
<li><strong>userData.py</strong></li>
</ul>
</li>
<li><p>syncUserData</p>
<ul>
<li>syncUserData将在多个客户端更改用户数据(addUserData等)的情况下同步用户数据(getUserData)。</li>
</ul>
</li>
<li><p>removeUserData</p>
<ul>
<li>给定userDataId, removeUserData将删除先前添加的用户数据。</li>
</ul>
</li>
<li><p>getUserDataId and getNumUserData</p>
<ul>
<li>getNumUserData将根据bodyUniqueId返回用户数据条目的数量。</li>
</ul>
</li>
<li><p>getUserDataInfo</p>
<ul>
<li>getUserDataInfo检索用户数据的键和标识符为(userDataId, key, bodyUniqueId, linkIndex, visualShapeIndex)</li>
</ul>
</li>
</ul>
<h2 id="9-3-configureDebugVisualizer"><a href="#9-3-configureDebugVisualizer" class="headerlink" title="9.3 configureDebugVisualizer"></a>9.3 configureDebugVisualizer</h2><ul>
<li>configureDebugVisualizer<ul>
<li>可以配置一些内置OpenGL可视化工具的设置，例如启用或禁用线框图、阴影和GUI渲染。这是非常有用的，因为一些笔记本电脑或桌面gui与我们的OpenGL 3可视化工具有性能问题</li>
<li>pybullet.configureDebugVisualizer(pybullet.COV_ENABLE_WIREFRAME,1)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>flag</td>
<td>int</td>
<td>要启用或禁用的功能:such as <br>COV_ENABLE_WIREFRAME,<br>COV_ENABLE_SHADOWS,<br>COV_ENABLE_GUI,COV_ENABLE_VR_PICKING,<br> COV_ENABLE_VR_TELEPORTING,<br>COV_ENABLE_RENDERING,<br> COV_ENABLE_TINY_RENDERER,<br>COV_ENABLE_VR_RENDER_CONTROLLERS,<br>COV_ENABLE_KEYBOARD_SHORTCUTS,<br>COV_ENABLE_MOUSE_PICKING,<br>COV_ENABLE_Y_AXIS_UP (Z is default world up axis),<br>COV_ENABLE_RGB_BUFFER_PREVIEW,<br>COV_ENABLE_DEPTH_BUFFER_PREVIEW,<br>COV_ENABLE_SEGMENTATION_MARK_PREVIEW</td>
</tr>
<tr>
<td>R</td>
<td>enable</td>
<td>int</td>
<td>0 or 1</td>
</tr>
<tr>
<td>O</td>
<td>lightPosition</td>
<td>vec3</td>
<td>visualizer的灯光位置</td>
</tr>
<tr>
<td>O</td>
<td>shadowMapResolution</td>
<td>int</td>
<td>阴影贴图纹理的大小，对于许多gpu来说通常是power of 2。默认是4096。现代gpu可以处理16384或32768或更高</td>
</tr>
<tr>
<td>O</td>
<td>shadowMapWorldSize</td>
<td>int</td>
<td>阴影地图在世界空间的大小(单位为米，默认为10)</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<h2 id="9-4-get-resetDebugVisualizerCamera"><a href="#9-4-get-resetDebugVisualizerCamera" class="headerlink" title="9.4 get/resetDebugVisualizerCamera"></a>9.4 get/resetDebugVisualizerCamera</h2><ul>
<li><p>get/resetDebugVisualizerCamera</p>
<ul>
<li>Warning:getDebugVisualizerCamera的返回参数与resetDebugVisualizerCamera的返回参数顺序不同。将在未来的API修订版(主要的新版本)中修复</li>
</ul>
</li>
<li><p>resetDebugVisualizerCamera</p>
<ul>
<li>可以重置3D OpenGL调试visualizer摄像机距离(眼睛和摄像机目标位置之间)，摄像机偏航和俯仰和摄像机目标位置。</li>
<li>pybullet.resetDebugVisualizerCamera( cameraDistance=3, cameraYaw=30,<br>cameraPitch=52, cameraTargetPosition=[0,0,0])</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>cameraDistance</td>
<td>float</td>
<td>从eye到camera目标位置的距离</td>
</tr>
<tr>
<td>R</td>
<td>cameraYaw</td>
<td>float</td>
<td>相机yaw(偏移)角度(以角度表示)左右</td>
</tr>
<tr>
<td>R</td>
<td>cameraPitch</td>
<td>float</td>
<td>摄像机Pitch(俯仰)角度(以度表示)向上/向下</td>
</tr>
<tr>
<td>R</td>
<td>cameraTargetPosition</td>
<td>vec3f</td>
<td>cameraTargetPosition是相机的焦点</td>
</tr>
<tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td></td>
</tr>
</tbody></table>
<p><br><br></p>
<ul>
<li>getDebugVisualizerCamera<ul>
<li>可以得到相机的宽度和高度(以像素为单位)，它的视图和投影矩阵使用这个命令。输入参数是可选的physicsClientId,输出信息见下表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>int</td>
<td>相机图像的像素宽度</td>
</tr>
<tr>
<td>height</td>
<td>int</td>
<td>相机图像的像素高度</td>
</tr>
<tr>
<td>viewMatrix</td>
<td>float16,list of 16 floats</td>
<td>相机的view matrix</td>
</tr>
<tr>
<td>projectionMatrix</td>
<td>float16,list of 16 floats</td>
<td>相机投影矩阵</td>
</tr>
<tr>
<td>cameraUp</td>
<td>float3,list of 3 floats</td>
<td>相机的上轴，在笛卡尔世界空间坐标中</td>
</tr>
<tr>
<td>cameraForward</td>
<td>float3,list of 3 floats</td>
<td>相机的前轴，在笛卡尔世界空间坐标</td>
</tr>
<tr>
<td>horizontal</td>
<td>float3,list of 3 floats</td>
<td>TBD。这是一个水平矢量，可以用来生成射线(例如，用于鼠标选择或创建一个简单的射线跟踪器)</td>
</tr>
<tr>
<td>vertical</td>
<td>float3,list of 3 floats</td>
<td>：TBD。这是一个垂直矢量，可以用来生成射线(例如，鼠标选择或创建一个简单的射线追踪器)。</td>
</tr>
<tr>
<td>yaw</td>
<td>float</td>
<td>相机的偏移角，在笛卡尔局部空间坐标中</td>
</tr>
<tr>
<td>pitch</td>
<td>float</td>
<td>相机俯仰角，在笛卡尔局部空间坐标中</td>
</tr>
<tr>
<td>dist</td>
<td>float</td>
<td>相机与相机目标之间的距离</td>
</tr>
<tr>
<td>target</td>
<td>float3,list of 3 floats</td>
<td>相机的目标，在笛卡尔世界空间坐标</td>
</tr>
</tbody></table>
<p><br><br></p>
<h2 id="9-5-getKeyboardEvents-getMouseEvents"><a href="#9-5-getKeyboardEvents-getMouseEvents" class="headerlink" title="9.5 getKeyboardEvents, getMouseEvents"></a>9.5 getKeyboardEvents, getMouseEvents</h2><ul>
<li>getKeyboardEvents<ul>
<li>调用getKeyboardEvents可以接收自上次调用以来发生的所有键盘事件,每个事件有一个键码和状态，状态是位标志KEY_IS_DOWN, KEY_WAS_TRIGGERED 和 KEY_WAS_RELEASED的组合，如果键盘是from up to down状态，会接收到KEY_IS_DOWN和KEY_WAS_TRIGGERED状态，如果键盘已经被按下，然后松开，会接收到KEY_IS_DOWN和KEY_WAS_RELEASED状态</li>
<li>定义了一些特殊的键：B3G_F1 … B3G_F12, B3G_LEFT_ARROW,B3G_RIGHT_ARROW, B3G_UP_ARROW, B3G_DOWN_ARROW, B3G_PAGE_UP,B3G_PAGE_DOWN, B3G_PAGE_END, B3G_HOME, B3G_DELETE, B3G_INSERT,B3G_ALT, B3G_SHIFT, B3G_CONTROL, B3G_RETURN.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Input Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>O</td>
<td>physicsClientId</td>
<td>int</td>
<td>…</td>
</tr>
</tbody></table>
<p><br><br><br><strong>输出是一个keycode ‘key’和键盘状态’value’的字典。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qKey = ord(<span class="string">'q'</span>)</span><br><span class="line">keys = p.getKeyboardEvents()</span><br><span class="line"><span class="keyword">if</span> qKey <span class="keyword">in</span> keys <span class="keyword">and</span> keys[qKey]&amp;p.KEY_WAS_TRIGGERED:</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>getMouseEvents<ul>
<li>与getKeyboardEvents类似，可以获得自上次调用getMouseEvents以来发生的鼠标事件。所有鼠标移动事件合并到一个最新位置的单个鼠标移动事件中。此外，给定按钮的所有鼠标按钮事件将被合并。如果一个按钮向下和向上，状态将是’KEY_WAS_TRIGGERED ‘。对于鼠标按钮状态，我们重用KEY_WAS_TRIGGERED /KEY_IS_DOWN /KEY_WAS_RELEASED。</li>
<li>输入参数只有 | O | physicsClient | int | … |</li>
<li>See <strong>createVisualShape.py</strong> for an example of mouse events, to select/color objects.</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Output Parameters</th>
<th>type</th>
<th>descriptions</th>
</tr>
</thead>
<tbody><tr>
<td>eventType</td>
<td>int</td>
<td>MOUSE_MOVE_EVENT=1, MOUSE_BUTTON_EVENT=2</td>
</tr>
<tr>
<td>mousePosX</td>
<td>float</td>
<td>鼠标指针的x坐标</td>
</tr>
<tr>
<td>mousePosY</td>
<td>float</td>
<td>鼠标指针的y坐标</td>
</tr>
<tr>
<td>buttonIndex</td>
<td>int</td>
<td>鼠标左键/中键/右键索引</td>
</tr>
<tr>
<td>buttonState</td>
<td>int</td>
<td>：flag KEY_WAS_TRIGGERED / KEY_IS_DOWN / KEY_WAS_RELEASED</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器人仿真</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>教程</tag>
        <tag>PyBullet</tag>
        <tag>机器人仿真</tag>
      </tags>
  </entry>
</search>
